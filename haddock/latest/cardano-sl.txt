-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cardano SL main implementation
--   
--   Please see README.md
@package cardano-sl
@version 0.2.0


-- | Common things used in <a>Arbitrary</a> and <a>Arbitrary</a>
module Pos.Util.TimeWarp

-- | Full node address.
type NetworkAddress = (ByteString, Word16)

-- | <tt>"127.0.0.1"</tt>.
localhost :: ByteString

-- | Temporal solution
currentTime :: MonadIO m => m Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
mcs :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
ms :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
sec :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
minute :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
hour :: Int -> Microsecond
addressToNodeId :: NetworkAddress -> NodeId
addressToNodeId' :: Word32 -> NetworkAddress -> NodeId
nodeIdToAddress :: NodeId -> Maybe NetworkAddress


-- | Contains all Shared Seed Calculation algorithms implemented in our
--   prototype. For now only NIST Beacon and more smart algorithm known as
--   <i>Coin tossing with guaranteed output delivery</i>
--   (<tt>GodTossing</tt>).
module Pos.Ssc.SscAlgo

-- | Options for command line
data SscAlgo
GodTossingAlgo :: SscAlgo
NistBeaconAlgo :: SscAlgo
instance GHC.Classes.Eq Pos.Ssc.SscAlgo.SscAlgo
instance GHC.Show.Show Pos.Ssc.SscAlgo.SscAlgo


-- | Exceptions related to error reporting.
module Pos.Reporting.Exceptions
data ReportingError
CantRetrieveLogs :: [FilePath] -> ReportingError
SendingError :: Text -> ReportingError
instance GHC.Show.Show Pos.Reporting.Exceptions.ReportingError
instance GHC.Exception.Exception Pos.Reporting.Exceptions.ReportingError


-- | DHT types.
module Pos.DHT.Model.Types

-- | Dummy data for DHT.
newtype DHTData
DHTData :: () -> DHTData

-- | DHT key, 32-byte long (18-byte hash + 14-byte nonce)
newtype DHTKey
DHTKey :: HashId -> DHTKey
[hashNodeId] :: DHTKey -> HashId

-- | DHT node.
data DHTNode
DHTNode :: NetworkAddress -> DHTKey -> DHTNode
[dhtAddr] :: DHTNode -> NetworkAddress
[dhtNodeId] :: DHTNode -> DHTKey

-- | Converts <a>ByteString</a> into <a>DHTKey</a> if possible.
bytesToDHTKey :: IsString s => ByteString -> Either s DHTKey

-- | Generate random <a>DHTKey</a>.
randomDHTKey :: MonadIO m => m DHTKey
getMeaningPart :: DHTKey -> ByteString
meaningPartLength :: Int
instance GHC.Show.Show Pos.DHT.Model.Types.DHTNode
instance GHC.Classes.Ord Pos.DHT.Model.Types.DHTNode
instance GHC.Classes.Eq Pos.DHT.Model.Types.DHTNode
instance GHC.Generics.Generic Pos.DHT.Model.Types.DHTKey
instance GHC.Classes.Ord Pos.DHT.Model.Types.DHTKey
instance GHC.Classes.Eq Pos.DHT.Model.Types.DHTKey
instance GHC.Generics.Generic Pos.DHT.Model.Types.DHTData
instance GHC.Show.Show Pos.DHT.Model.Types.DHTData
instance GHC.Classes.Ord Pos.DHT.Model.Types.DHTData
instance GHC.Classes.Eq Pos.DHT.Model.Types.DHTData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.DHT.Model.Types.DHTData
instance Data.Hashable.Class.Hashable Pos.DHT.Model.Types.DHTKey
instance Data.Text.Buildable.Buildable Pos.DHT.Model.Types.DHTKey
instance GHC.Show.Show Pos.DHT.Model.Types.DHTKey
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.DHT.Model.Types.DHTKey
instance Data.Text.Buildable.Buildable Pos.DHT.Model.Types.DHTNode
instance Data.Text.Buildable.Buildable [Pos.DHT.Model.Types.DHTNode]

module Pos.DHT.Model.Class

-- | Data type for DHT exceptions.
data DHTException
NodeDown :: DHTException
AllPeersUnavailable :: DHTException

-- | Monad for Distributed Hash Table operations.
class Monad m => MonadDHT m
joinNetwork :: MonadDHT m => [DHTNode] -> m ()

-- | Peer discovery: query DHT for random key Processing request, node will
--   discover few other nodes We return these newly discovered nodes among
--   with already known (List of known nodes is updated as well)
discoverPeers :: MonadDHT m => m [DHTNode]
getKnownPeers :: MonadDHT m => m [DHTNode]
currentNodeKey :: MonadDHT m => m DHTKey
dhtLoggerName :: MonadDHT m => Proxy m -> LoggerName

-- | Perform some action using <a>dhtLoggerName</a>.
withDhtLogger :: (HasLoggerName m, MonadDHT m) => m a -> m a
instance GHC.Show.Show Pos.DHT.Model.Class.DHTException
instance Pos.DHT.Model.Class.MonadDHT m => Pos.DHT.Model.Class.MonadDHT (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Exception.Exception Pos.DHT.Model.Class.DHTException

module Pos.DHT.Model.Util

-- | Join distributed network without throwing <a>AllPeersUnavailable</a>
--   exception.
joinNetworkNoThrow :: (MonadDHT m, Mockable Catch m, Mockable Throw m, WithLogger m) => [DHTNode] -> m ()

module Pos.Util.TimeLimit
execWithTimeLimit :: (Mockable Async m, Mockable Delay m, Mockable Bracket m) => Microsecond -> m a -> m (Maybe a)

-- | Constraint for something that can be logged in parallel with other
--   action.
type CanLogInParallel m = (Mockable Delay m, Mockable Fork m, WithLogger m, Mockable Bracket m)

-- | Data type to represent waiting strategy for printing warnings if
--   action take too much time.
--   
--   <ul>
--   <li><i>LW-4</i> this probably will be moved somewhere from here</li>
--   </ul>
data WaitingDelta

-- | wait s seconds and stop execution
WaitOnce :: Second -> WaitingDelta

-- | wait s, s * 2, s * 3 , s * 4 , ... seconds
WaitLinear :: Second -> WaitingDelta

-- | wait m, m * q, m * q^2, m * q^3, ... microseconds
WaitGeometric :: Microsecond -> Double -> WaitingDelta

-- | Run action and print warning if it takes more time than expected.
logWarningLongAction :: CanLogInParallel m => WaitingDelta -> Text -> m a -> m a

-- | Specialization of <a>logWarningLongAction</a> with <a>WaitOnce</a>.
logWarningWaitOnce :: CanLogInParallel m => Second -> Text -> m a -> m a

-- | Specialization of <a>logWarningLongAction</a> with <tt>WaiLinear</tt>.
logWarningWaitLinear :: CanLogInParallel m => Second -> Text -> m a -> m a

-- | Specialization of <a>logWarningLongAction</a> with
--   <a>WaitGeometric</a> with parameter <tt>1.3</tt>. Accepts
--   <a>Second</a>.
logWarningWaitInf :: CanLogInParallel m => Second -> Text -> m a -> m a

-- | Wait random interval and then perform given action.
runWithRandomIntervals' :: (MonadIO m, Mockable Delay m) => Microsecond -> Microsecond -> m () -> m ()

-- | Wait random number of <tt>Microsecond'</tt>s between min and max.
waitRandomInterval' :: (MonadIO m, Mockable Delay m) => Microsecond -> Microsecond -> m ()

-- | Wait random interval and then perform given action.
runWithRandomIntervals :: (MonadIO m, WithLogger m, Mockable Fork m, Mockable Delay m) => Microsecond -> Microsecond -> m () -> m ()

-- | Like <a>runWithRandomIntervals</a>, but performs action immidiatelly
--   at first time.
runWithRandomIntervalsNow :: (MonadIO m, WithLogger m, Mockable Fork m, Mockable Delay m) => Microsecond -> Microsecond -> m () -> m ()

-- | Wait random number of <tt>Microsecond'</tt>s between min and max.
waitRandomInterval :: (MonadIO m, Mockable Delay m) => Microsecond -> Microsecond -> m ()
instance GHC.Show.Show Pos.Util.TimeLimit.WaitingDelta

module Pos.DHT.Real.Types

-- | Node of <i>Kademlia DHT</i> algorithm with access to
--   <tt>KademliaDHTContext</tt>.
newtype KademliaDHT m a
KademliaDHT :: ReaderT KademliaDHTInstance m a -> KademliaDHT m a

-- | Instance of node for <i>Kademlia DHT</i> algorithm.
data KademliaDHTInstance
KademliaDHTInstance :: !DHTHandle -> !DHTKey -> ![DHTNode] -> !Bool -> !(TVar [Node DHTKey]) -> KademliaDHTInstance

-- | Instance of part of config.
data KademliaDHTInstanceConfig
KademliaDHTInstanceConfig :: !Word16 -> !(Maybe DHTKey) -> ![DHTNode] -> !Bool -> !FilePath -> KademliaDHTInstanceConfig
type DHTHandle = KademliaInstance DHTKey DHTData

-- | Class for getting KademliaDHTInstance from <a>KademliaDHT</a>
class WithKademliaDHTInstance m
getKademliaDHTInstance :: WithKademliaDHTInstance m => m KademliaDHTInstance
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Trans.Class.MonadTrans Pos.DHT.Real.Types.KademliaDHT
instance (System.Wlog.LoggerNameBox.HasLoggerName m, GHC.Base.Monad m) => System.Wlog.LoggerNameBox.HasLoggerName (Pos.DHT.Real.Types.KademliaDHT m)
instance System.Wlog.CanLog.CanLog m => System.Wlog.CanLog.CanLog (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTData => Network.Kademlia.Types.Serialize Pos.DHT.Model.Types.DHTData
instance Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTKey => Network.Kademlia.Types.Serialize Pos.DHT.Model.Types.DHTKey
instance GHC.Base.Monad m => Pos.DHT.Real.Types.WithKademliaDHTInstance (Pos.DHT.Real.Types.KademliaDHT m)
instance (GHC.Base.Monad m, Pos.DHT.Real.Types.WithKademliaDHTInstance m) => Pos.DHT.Real.Types.WithKademliaDHTInstance (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Base.Monad m, Pos.DHT.Real.Types.WithKademliaDHTInstance m) => Pos.DHT.Real.Types.WithKademliaDHTInstance (Control.Monad.Trans.State.Lazy.StateT a m)
instance (Mockable.Class.Mockable d m, Mockable.Class.MFunctor' d (Control.Monad.Trans.Reader.ReaderT Pos.DHT.Real.Types.KademliaDHTInstance m) m, Mockable.Class.MFunctor' d (Pos.DHT.Real.Types.KademliaDHT m) (Control.Monad.Trans.Reader.ReaderT Pos.DHT.Real.Types.KademliaDHTInstance m)) => Mockable.Class.Mockable d (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Monad m => Serokell.Util.Lens.WrappedM (Pos.DHT.Real.Types.KademliaDHT m)


-- | Re-export of Crypto modules.
module Pos.Crypto

-- | <a>PublicKey</a> with corresponding <a>SecretKey</a>.
data KeyPair
KeyPair :: PublicKey -> SecretKey -> KeyPair
[getPub] :: KeyPair -> PublicKey
[getSec] :: KeyPair -> SecretKey
data WithHash a
WithHash :: a -> Hash a -> WithHash a
[whData] :: WithHash a -> a
[whHash] :: WithHash a -> Hash a
withHash :: Bi a => a -> WithHash a
_whData :: forall a_a1gdE. Lens' (WithHash a_a1gdE) a_a1gdE

-- | Lenses for <a>WithHash</a>
_whHash :: forall a_a1gdE. Lens' (WithHash a_a1gdE) (Hash a_a1gdE)

-- | Hash wrapper with phantom type for more type-safety. Made abstract in
--   order to support different algorithms in different situations
newtype AbstractHash algo a
AbstractHash :: (Digest algo) -> AbstractHash algo a

-- | Encode hash from base64 form.
encodeAbstractHash :: forall algo a. Bi (AbstractHash algo a) => AbstractHash algo a -> Text

-- | Parses given hash in base64 form.
decodeAbstractHash :: forall algo a. Bi (AbstractHash algo a) => Text -> AbstractHash algo a

-- | Encode hash from base64 form.
encodeHash :: Bi (Hash a) => Hash a -> Text

-- | Parses given hash in base64 form.
decodeHash :: Bi (Hash a) => Text -> Hash a

-- | Encode thing as <tt>Binary</tt> data and then wrap into constructor.
abstractHash :: (HashAlgorithm algo, Bi a) => a -> AbstractHash algo a

-- | Unsafe version of abstractHash.
unsafeAbstractHash :: (HashAlgorithm algo, Bi a) => a -> AbstractHash algo b

-- | Type alias for commonly used hash
type Hash = AbstractHash Blake2s_256

-- | Specialized formatter for <a>Hash</a>.
hashHexF :: Format r (AbstractHash algo a -> r)

-- | Smart formatter for <a>Hash</a> to show only first <tt>8</tt>
--   characters of <a>Hash</a>.
shortHashF :: Format r (AbstractHash algo a -> r)

-- | Short version of <a>unsafeHash</a>.
hash :: Bi a => a -> Hash a

-- | Raw constructor application.
hashRaw :: ByteString -> Hash Raw

-- | Encode thing as <a>Bi</a> data and then wrap into constructor.
unsafeHash :: Bi a => a -> Hash b

-- | Type class for unsafe cast between hashes. You must ensure that types
--   have identical Bi instances.
class CastHash a b where castHash (AbstractHash x) = AbstractHash x
castHash :: CastHash a b => AbstractHash algo a -> AbstractHash algo b
class HashAlgorithm a

-- | You can use <a>runSecureRandom</a> on any <a>MonadRandom</a>
--   computation to make it use a Really Secure™ randomness source (that
--   is, OpenSSL).
newtype SecureRandom a
SecureRandom :: IO a -> SecureRandom a
[runSecureRandom] :: SecureRandom a -> IO a

-- | Generate a cryptographically random <a>ByteString</a> of specific
--   length.
secureRandomBS :: MonadIO m => Int -> m ByteString

-- | You can use <a>deterministic</a> on any <a>MonadRandom</a> computation
--   to make it use a seed (hopefully produced by a Really Secure™
--   randomness source). The seed has to have enough entropy to make this
--   function secure.
deterministic :: ByteString -> MonadPseudoRandom ChaChaDRG a -> a

-- | Generate a random number in range [0, n).
--   
--   We want to avoid modulo bias, so we use the arc4random_uniform
--   implementation (http:/<i>stackoverflow.com</i>a<i>20051580</i>615030).
--   Specifically, we repeatedly generate a random number in range [0, 2^x)
--   until we hit on something outside of [0, 2^x mod n), which means that
--   it'll be in range [2^x mod n, 2^x). The amount of numbers in this
--   interval is guaranteed to be divisible by n, and thus applying
--   <a>mod</a> to it will be safe.
randomNumber :: MonadRandom m => Integer -> m Integer

-- | This key is used as public key in VSS.
newtype VssPublicKey
VssPublicKey :: PublicKey -> VssPublicKey
[getVssPublicKey] :: VssPublicKey -> PublicKey

-- | This key pair is used to decrypt share generated by VSS.
newtype VssKeyPair
VssKeyPair :: KeyPair -> VssKeyPair

-- | Extract VssPublicKey from VssKeyPair.
toVssPublicKey :: VssKeyPair -> VssPublicKey

-- | Generate VssKeyPair using Really Secure™ randomness.
vssKeyGen :: MonadIO m => m VssKeyPair

-- | Generate VssKeyPair using given seed.
deterministicVssKeyGen :: ByteString -> VssKeyPair
newtype DhSecret :: *
DhSecret :: ByteString -> DhSecret
type ShareId = Integer

-- | Encrypted share which needs to be decrypted using VssKeyPair first.
newtype EncShare
EncShare :: EncryptedShare -> EncShare
[getEncShare] :: EncShare -> EncryptedShare

-- | Secret can be generated by <a>genSharedSecret</a> function along with
--   shares.
newtype Secret
Secret :: Secret -> Secret
[getSecret] :: Secret -> Secret

-- | SecretProof may be used to commit Secret without revealing it.
newtype SecretProof
SecretProof :: Proof -> SecretProof

-- | This extra data may be used to verify encrypted share.
data SecretSharingExtra
SecretSharingExtra :: !ExtraGen -> ![Commitment] -> SecretSharingExtra

-- | Shares can be used to reconstruct Secret.
newtype Share
Share :: DecryptedShare -> Share
[getShare] :: Share -> DecryptedShare
type Threshold = Integer

-- | Returns id of <a>Share</a>.
shareId :: Share -> ShareId

-- | Returns id of encrypted share.
encShareId :: EncShare -> ShareId

-- | Decrypt share using secret key. Doesn't verify if an encrypted share
--   is valid, for this you need to use verifyEncShare.
decryptShare :: MonadRandom m => VssKeyPair -> EncShare -> m Share

-- | Extract ByteString from DhSecret.
getDhSecret :: DhSecret -> ByteString

-- | Generate random secret using MonadRandom and share it between given
--   public keys.
genSharedSecret :: MonadRandom m => Threshold -> NonEmpty VssPublicKey -> m (SecretSharingExtra, Secret, SecretProof, [EncShare])

-- | Get #Threshold decrypted shares from given list, or less if there is
--   not enough.
getValidShares :: Threshold -> [(EncShare, VssPublicKey, Share)] -> [Share]

-- | Recover secret if there are enough correct shares.
recoverSecret :: Threshold -> [(EncShare, VssPublicKey, Share)] -> Maybe Secret

-- | Transform a Secret into a usable random value.
secretToDhSecret :: Secret -> DhSecret

-- | Recover Secret from shares. Assumes that number of shares is enough to
--   do it. Consider using <a>getValidShares</a> first or use
--   <a>recoverSecret</a>
unsafeRecoverSecret :: [Share] -> Secret

-- | Verify an encrypted share using SecretSharingExtra.
verifyEncShare :: SecretSharingExtra -> VssPublicKey -> EncShare -> Bool

-- | Verify that SecretProof corresponds to Secret.
verifySecretProof :: SecretSharingExtra -> Secret -> SecretProof -> Bool

-- | Verify that Share has been decrypted correctly.
verifyShare :: EncShare -> VssPublicKey -> Share -> Bool

-- | Wrapper around <a>PublicKey</a>.
newtype PublicKey
PublicKey :: PublicKey -> PublicKey

-- | Wrapper around <a>SecretKey</a>.
newtype SecretKey
SecretKey :: SecretKey -> SecretKey

-- | Generate a key pair.
keyGen :: MonadIO m => m (PublicKey, SecretKey)

-- | Create key pair deterministically from 32 bytes.
deterministicKeyGen :: ByteString -> Maybe (PublicKey, SecretKey)

-- | Generate a public key from a secret key. Fast (it just drops some
--   bytes off the secret key).
toPublic :: SecretKey -> PublicKey

-- | <a>Builder</a> for <a>PublicKey</a> to show it in base64 encoded form.
formatFullPublicKey :: PublicKey -> Builder

-- | Formatter for <a>PublicKey</a> to show it in base64.
fullPublicKeyF :: Format r (PublicKey -> r)

-- | Formatter for <a>PublicKey</a> to show it in hex.
fullPublicKeyHexF :: Format r (PublicKey -> r)

-- | Parse <a>PublicKey</a> from base64 encoded string.
parseFullPublicKey :: (Bi PublicKey) => Text -> Maybe PublicKey

-- | Wrapper around <a>Signature</a>.
newtype Signature a
Signature :: Signature -> Signature a

-- | Encode something with <tt>Binary</tt> and sign it.
sign :: Bi a => SecretKey -> a -> Signature a

-- | Verify a signature. #verifyRaw
checkSig :: Bi a => PublicKey -> a -> Signature a -> Bool

-- | Formatter for <a>Signature</a> to show it in hex.
fullSignatureHexF :: Format r (Signature a -> r)

-- | Value and signature for this value.
data Signed a
Signed :: !a -> !(Signature a) -> Signed a

-- | Value to be signed
[signedValue] :: Signed a -> !a

-- | <a>Signature</a> of <a>signedValue</a>
[signedSig] :: Signed a -> !(Signature a)

-- | Smart constructor for <a>Signed</a> data type with proper signing.
mkSigned :: (Bi a) => SecretKey -> a -> Signed a

-- | Alias for constructor.
signRaw :: SecretKey -> ByteString -> Signature Raw

-- | Verify raw <a>ByteString</a>.
verifyRaw :: PublicKey -> ByteString -> Signature Raw -> Bool

-- | Proxy certificate, made of ω + public key of delegate.
newtype ProxyCert w
ProxyCert :: Signature -> ProxyCert w
[unProxyCert] :: ProxyCert w -> Signature

-- | Proxy certificate creation from secret key of issuer, public key of
--   delegate and the message space ω.
createProxyCert :: (Bi w) => SecretKey -> PublicKey -> w -> ProxyCert w

-- | Checks if certificate is valid, given issuer pk, delegate pk and ω.
verifyProxyCert :: (Bi w) => PublicKey -> PublicKey -> w -> ProxyCert w -> Bool

-- | Convenient wrapper for secret key, that's basically ω plus
--   certificate.
data ProxySecretKey w
ProxySecretKey :: w -> PublicKey -> PublicKey -> ProxyCert w -> ProxySecretKey w
[pskOmega] :: ProxySecretKey w -> w
[pskIssuerPk] :: ProxySecretKey w -> PublicKey
[pskDelegatePk] :: ProxySecretKey w -> PublicKey
[pskCert] :: ProxySecretKey w -> ProxyCert w

-- | Creates proxy secret key
createProxySecretKey :: (Bi w) => SecretKey -> PublicKey -> w -> ProxySecretKey w

-- | Checks if proxy secret key is valid (the signature/cert inside is
--   correct).
verifyProxySecretKey :: (Bi w) => ProxySecretKey w -> Bool

-- | Delegate signature made with certificate-based permission. <tt>a</tt>
--   stays for message type used in proxy (ω in the implementation notes),
--   <tt>b</tt> for type of message signed.
data ProxySignature w a
ProxySignature :: w -> PublicKey -> ProxyCert w -> Signature -> ProxySignature w a
[pdOmega] :: ProxySignature w a -> w
[pdDelegatePk] :: ProxySignature w a -> PublicKey
[pdCert] :: ProxySignature w a -> ProxyCert w
[pdSig] :: ProxySignature w a -> Signature

-- | Make a proxy delegate signature with help of certificate. If the
--   delegate secret key passed doesn't pair with delegate public key in
--   certificate inside, we panic. Please check this condition outside of
--   this function.
proxySign :: (Bi a) => SecretKey -> ProxySecretKey w -> a -> ProxySignature w a

-- | Verify delegated signature given issuer's pk, signature, message space
--   predicate and message itself.
proxyVerify :: (Bi w, Bi a) => PublicKey -> ProxySignature w a -> (w -> Bool) -> a -> Bool


-- | Helper data type for block, tx attributes.
--   
--   Map with integer 1-byte keys, arbitrary-type polymorph values. Needed
--   primarily for partial serialization. Values are either parsed and put
--   to some constructor or left as unparsed.
module Pos.Data.Attributes

-- | Convenient wrapper for the datatype to represent it (in binary format)
--   as k-v map.
data Attributes h
Attributes :: h -> ByteString -> Attributes h

-- | Data, containing known keys (deserialized)
[attrData] :: Attributes h -> h

-- | Unparsed ByteString
[attrRemain] :: Attributes h -> ByteString

-- | Generate <a>Attributes</a> reader given mapper from keys to
--   <a>Get</a>, maximum input length and the attribute value <tt>h</tt>
--   itself.
--   
--   The mapper will be applied until it returns <a>Nothing</a>.
getAttributes :: (Word8 -> h -> Maybe (Get h)) -> Maybe Word32 -> h -> Get (Attributes h)

-- | Generate <a>Put</a> given the way to serialize inner attribute value
--   into set of keys and values.
putAttributes :: (h -> [(Word8, Put)]) -> Attributes h -> Put
mkAttributes :: h -> Attributes h
instance Control.DeepSeq.NFData h_6989586621679427216 => Control.DeepSeq.NFData (Pos.Data.Attributes.Attributes h_6989586621679427216)
instance GHC.Generics.Generic (Pos.Data.Attributes.Attributes h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Pos.Data.Attributes.Attributes h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Pos.Data.Attributes.Attributes h)
instance Data.Default.Class.Default h => Data.Default.Class.Default (Pos.Data.Attributes.Attributes h)
instance GHC.Show.Show h => GHC.Show.Show (Pos.Data.Attributes.Attributes h)
instance Data.Text.Buildable.Buildable h => Data.Text.Buildable.Buildable (Pos.Data.Attributes.Attributes h)
instance Data.Hashable.Class.Hashable h => Data.Hashable.Class.Hashable (Pos.Data.Attributes.Attributes h)
instance Data.SafeCopy.SafeCopy.SafeCopy h => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Data.Attributes.Attributes h)


-- | Merkle tree implementation.
--   
--   See <a>https://tools.ietf.org/html/rfc6962</a>.
module Pos.Merkle

-- | Data type for root of merkle tree.
newtype MerkleRoot a
MerkleRoot :: Hash Raw -> MerkleRoot a

-- | returns root <a>Hash</a> of Merkle Tree
[getMerkleRoot] :: MerkleRoot a -> Hash Raw

-- | Straightforward merkle tree representation in Haskell.
data MerkleTree a
MerkleEmpty :: MerkleTree a
MerkleTree :: Word32 -> (MerkleNode a) -> MerkleTree a

-- | Returns root of merkle tree.
mtRoot :: MerkleTree a -> MerkleRoot a

-- | Smart constructor for <a>MerkleTree</a>.
mkMerkleTree :: Bi a => [a] -> MerkleTree a
data MerkleNode a
MerkleBranch :: MerkleRoot a -> MerkleNode a -> MerkleNode a -> MerkleNode a
[mRoot] :: MerkleNode a -> MerkleRoot a
[mLeft] :: MerkleNode a -> MerkleNode a
[mRight] :: MerkleNode a -> MerkleNode a
MerkleLeaf :: MerkleRoot a -> a -> MerkleNode a
[mRoot] :: MerkleNode a -> MerkleRoot a
[mVal] :: MerkleNode a -> a
mkBranch :: MerkleNode a -> MerkleNode a -> MerkleNode a
mkLeaf :: Bi a => a -> MerkleNode a
instance Data.SafeCopy.SafeCopy.SafeCopy a0 => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Merkle.MerkleTree a0)
instance Data.SafeCopy.SafeCopy.SafeCopy a0 => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Merkle.MerkleNode a0)
instance GHC.Generics.Generic (Pos.Merkle.MerkleTree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Pos.Merkle.MerkleTree a)
instance GHC.Generics.Generic (Pos.Merkle.MerkleNode a)
instance GHC.Show.Show a => GHC.Show.Show (Pos.Merkle.MerkleNode a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Pos.Merkle.MerkleNode a)
instance Data.SafeCopy.SafeCopy.SafeCopy a0 => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Merkle.MerkleRoot a0)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Pos.Merkle.MerkleTree a)
instance Data.Foldable.Foldable Pos.Merkle.MerkleTree
instance GHC.Show.Show a => GHC.Show.Show (Pos.Merkle.MerkleTree a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Pos.Merkle.MerkleNode a)
instance Data.Foldable.Foldable Pos.Merkle.MerkleNode
instance Control.DeepSeq.NFData (Pos.Merkle.MerkleRoot a)
instance Data.ByteArray.Types.ByteArrayAccess (Pos.Merkle.MerkleRoot a)
instance GHC.Generics.Generic (Pos.Merkle.MerkleRoot a)
instance GHC.Classes.Ord (Pos.Merkle.MerkleRoot a)
instance GHC.Classes.Eq (Pos.Merkle.MerkleRoot a)
instance GHC.Show.Show (Pos.Merkle.MerkleRoot a)

module Pos.Script.Type

-- | A script for inclusion into a transaction.
data Script

-- | Serialized script
Script :: ScriptVersion -> LByteString -> Script

-- | Version
[scrVersion] :: Script -> ScriptVersion
[scrScript] :: Script -> LByteString

-- | Deserialized script (i.e. an AST), version 0.
type Script_v0 = Program

-- | Version of script
type ScriptVersion = Word16
instance GHC.Show.Show (f PlutusCore.Term.PatternF) => GHC.Show.Show (PlutusCore.Term.PatternF (f PlutusCore.Term.PatternF))
instance GHC.Show.Show r => GHC.Show.Show (PlutusCore.Term.ClauseF r)
instance Language.Haskell.TH.Syntax.Lift Utils.Vars.FreeVar
instance Language.Haskell.TH.Syntax.Lift Utils.Vars.MetaVar
instance Language.Haskell.TH.Syntax.Lift Utils.Vars.BoundVar
instance Language.Haskell.TH.Syntax.Lift PlutusTypes.Type.TyConSig
instance Language.Haskell.TH.Syntax.Lift PlutusTypes.ConSig.ConSig
instance Language.Haskell.TH.Syntax.Lift PlutusTypes.Type.PolymorphicType
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Utils.Names.Sourced a)
instance Language.Haskell.TH.Syntax.Lift Utils.ABT.Variable
instance Language.Haskell.TH.Syntax.Lift (f (Utils.ABT.Scope f)) => Language.Haskell.TH.Syntax.Lift (Utils.ABT.ABT f)
instance Language.Haskell.TH.Syntax.Lift (f (Utils.ABT.Scope f)) => Language.Haskell.TH.Syntax.Lift (Utils.ABT.Scope f)
instance Language.Haskell.TH.Syntax.Lift r => Language.Haskell.TH.Syntax.Lift (PlutusCore.Term.ClauseF r)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (PlutusCore.Term.TermF a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (PlutusCore.Term.PatternF a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (PlutusTypes.Type.TypeF a)
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Term.PrimData
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Program.Program
instance Data.Functor.Classes.Eq1 PlutusTypes.Type.TypeF
instance Data.Binary.Class.Binary Utils.Vars.FreeVar
instance Data.Binary.Class.Binary Utils.Vars.MetaVar
instance Data.Binary.Class.Binary Utils.Vars.BoundVar
instance Data.Binary.Class.Binary PlutusTypes.Type.TyConSig
instance Data.Binary.Class.Binary PlutusTypes.ConSig.ConSig
instance Data.Binary.Class.Binary PlutusTypes.Type.PolymorphicType
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Utils.Names.Sourced a)
instance Data.Binary.Class.Binary Utils.ABT.Variable
instance Data.Binary.Class.Binary (f (Utils.ABT.Scope f)) => Data.Binary.Class.Binary (Utils.ABT.ABT f)
instance Data.Binary.Class.Binary (f (Utils.ABT.Scope f)) => Data.Binary.Class.Binary (Utils.ABT.Scope f)
instance Data.Binary.Class.Binary r => Data.Binary.Class.Binary (PlutusCore.Term.ClauseF r)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (PlutusCore.Term.TermF a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (PlutusCore.Term.PatternF a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (PlutusTypes.Type.TypeF a)
instance Data.Binary.Class.Binary PlutusCore.Term.PrimData
instance Data.Binary.Class.Binary PlutusCore.Program.Program
instance Control.DeepSeq.NFData Utils.Vars.FreeVar
instance Control.DeepSeq.NFData Utils.Vars.MetaVar
instance Control.DeepSeq.NFData Utils.Vars.BoundVar
instance Control.DeepSeq.NFData PlutusTypes.Type.TyConSig
instance Control.DeepSeq.NFData PlutusTypes.ConSig.ConSig
instance Control.DeepSeq.NFData PlutusTypes.Type.PolymorphicType
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Utils.Names.Sourced a)
instance Control.DeepSeq.NFData Utils.ABT.Variable
instance Control.DeepSeq.NFData (f (Utils.ABT.Scope f)) => Control.DeepSeq.NFData (Utils.ABT.ABT f)
instance Control.DeepSeq.NFData (f (Utils.ABT.Scope f)) => Control.DeepSeq.NFData (Utils.ABT.Scope f)
instance Control.DeepSeq.NFData r => Control.DeepSeq.NFData (PlutusCore.Term.ClauseF r)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Term.TermF a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Term.PatternF a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusTypes.Type.TypeF a)
instance Control.DeepSeq.NFData PlutusCore.Term.PrimData
instance Control.DeepSeq.NFData PlutusCore.Program.Program
instance Pos.Binary.Class.Bi PlutusCore.Term.Term => Data.SafeCopy.SafeCopy.SafeCopy PlutusCore.Term.Term
instance Pos.Binary.Class.Bi PlutusCore.Program.Program => Data.SafeCopy.SafeCopy.SafeCopy PlutusCore.Program.Program
instance Data.Hashable.Class.Hashable PlutusCore.Term.Term
instance Data.Hashable.Class.Hashable PlutusCore.Program.Program
instance Data.Functor.Classes.Eq1 PlutusCore.Term.TermF
instance Data.Functor.Classes.Eq1 PlutusCore.Term.ClauseF
instance Data.Functor.Classes.Eq1 PlutusCore.Term.PatternF
instance GHC.Show.Show PlutusCore.Term.PrimData
instance (GHC.Show.Show a, GHC.Show.Show (PlutusCore.Term.ClauseF a)) => GHC.Show.Show (PlutusCore.Term.TermF a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (PlutusCore.Term.ClauseF a)) => GHC.Classes.Eq (PlutusCore.Term.TermF a)
instance GHC.Classes.Eq PlutusTypes.Type.TyConSig
instance GHC.Classes.Eq PlutusTypes.ConSig.ConSig
instance GHC.Classes.Eq PlutusTypes.Type.PolymorphicType
instance GHC.Classes.Eq PlutusCore.Program.Program
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Script.Type.Script
instance GHC.Generics.Generic Pos.Script.Type.Script
instance GHC.Show.Show Pos.Script.Type.Script
instance GHC.Classes.Eq Pos.Script.Type.Script
instance Control.DeepSeq.NFData Pos.Script.Type.Script
instance Data.Hashable.Class.Hashable Pos.Script.Type.Script
instance Data.Text.Buildable.Buildable Pos.Script.Type.Script

module Pos.Types.Address

-- | Address is where you can send coins.
data Address
PubKeyAddress :: !(AddressHash PublicKey) -> !(Attributes AddrPkAttrs) -> Address
[addrKeyHash] :: Address -> !(AddressHash PublicKey)
[addrPkAttributes] :: Address -> !(Attributes AddrPkAttrs)
ScriptAddress :: !(AddressHash Script) -> Address
[addrScriptHash] :: Address -> !(AddressHash Script)
UnknownAddressType :: !Word8 -> !ByteString -> Address
newtype AddrPkAttrs
AddrPkAttrs :: Maybe [Word32] -> AddrPkAttrs
[addrPkDerivationPath] :: AddrPkAttrs -> Maybe [Word32]

-- | Specialized formatter for <a>Address</a>.
addressF :: Bi Address => Format r (Address -> r)

-- | A formatter showing guts of an <a>Address</a>.
addressDetailedF :: Format r (Address -> r)

-- | Check if given <a>Address</a> is created from given <a>PublicKey</a>
checkPubKeyAddress :: PublicKey -> Address -> Bool

-- | Check if given <a>Address</a> is created from given validation script
checkScriptAddress :: Bi Script => Script -> Address -> Bool

-- | Check if given <a>Address</a> has given type
checkUnknownAddressType :: Word8 -> Address -> Bool

-- | A function for making an address from PublicKey
makePubKeyAddress :: PublicKey -> Address

-- | A function for making an HDW address
makePubKeyHdwAddress :: PublicKey -> [Word32] -> Address

-- | A function for making an address from a validation script
makeScriptAddress :: Bi Script => Script -> Address
decodeTextAddress :: Bi Address => Text -> Either Text Address

-- | Stakeholder identifier (stakeholders are identified by their public
--   keys)
type StakeholderId = AddressHash PublicKey
type AddressHash = AbstractHash Blake2s_224
addressHash :: Bi a => a -> AddressHash a
unsafeAddressHash :: Bi a => a -> AddressHash b
instance Pos.Binary.Class.Bi Pos.Types.Core.Address => Data.Hashable.Class.Hashable Pos.Types.Core.Address
instance Pos.Binary.Class.Bi Pos.Types.Core.Address => Data.Text.Buildable.Buildable Pos.Types.Core.Address
instance Data.Text.Buildable.Buildable Pos.Types.Core.AddrPkAttrs

module Pos.Security.CLI
data AttackType
AttackNoBlocks :: AttackType
AttackNoCommitments :: AttackType
data AttackTarget
NetworkAddressTarget :: NetworkAddress -> AttackTarget
[attNetworkAddr] :: AttackTarget -> NetworkAddress
PubKeyAddressTarget :: StakeholderId -> AttackTarget
[attPkAddr] :: AttackTarget -> StakeholderId
data NodeAttackedError
AttackNoBlocksTriggered :: NodeAttackedError
instance GHC.Show.Show Pos.Security.CLI.NodeAttackedError
instance GHC.Show.Show Pos.Security.CLI.AttackTarget
instance GHC.Classes.Eq Pos.Security.CLI.AttackTarget
instance GHC.Show.Show Pos.Security.CLI.AttackType
instance GHC.Classes.Eq Pos.Security.CLI.AttackType
instance GHC.Exception.Exception Pos.Security.CLI.NodeAttackedError

module Pos.Types.Block.Class

-- | Blockchain type class generalizes some functionality common for
--   different blockchains.
class Blockchain p where data BodyProof p :: * data ConsensusData p :: * type ExtraHeaderData p :: * type BBlockHeader p :: * type BHeaderHash p :: * data Body p :: * type ExtraBodyData p :: * type BBlock p :: * type ExtraHeaderData p = () type BBlockHeader p = GenericBlockHeader p type BHeaderHash p = HeaderHash type ExtraBodyData p = () type BBlock p = GenericBlock p checkBodyProof body proof = mkBodyProof body == proof where {
    data family BodyProof p :: *;
    data family ConsensusData p :: *;
    type family ExtraHeaderData p :: *;
    type family BBlockHeader p :: *;
    type family BHeaderHash p :: *;
    data family Body p :: *;
    type family ExtraBodyData p :: *;
    type family BBlock p :: *;
    type ExtraHeaderData p = ();
    type BBlockHeader p = GenericBlockHeader p;
    type BHeaderHash p = HeaderHash;
    type ExtraBodyData p = ();
    type BBlock p = GenericBlock p;
}
mkBodyProof :: Blockchain p => Body p -> BodyProof p
checkBodyProof :: Blockchain p => Body p -> BodyProof p -> Bool
checkBodyProof :: (Blockchain p, Eq (BodyProof p)) => Body p -> BodyProof p -> Bool
verifyBBlock :: Blockchain p => GenericBlock p -> Either Text ()

-- | Header of block contains some kind of summary. There are various
--   benefits which people get by separating header from other data.
data GenericBlockHeader b
GenericBlockHeader :: !(BHeaderHash b) -> !(BodyProof b) -> !(ConsensusData b) -> !(ExtraHeaderData b) -> GenericBlockHeader b

-- | Pointer to the header of the previous block.
[_gbhPrevBlock] :: GenericBlockHeader b -> !(BHeaderHash b)

-- | Proof of body.
[_gbhBodyProof] :: GenericBlockHeader b -> !(BodyProof b)

-- | Consensus data to verify consensus algorithm.
[_gbhConsensus] :: GenericBlockHeader b -> !(ConsensusData b)

-- | Any extra data.
[_gbhExtra] :: GenericBlockHeader b -> !(ExtraHeaderData b)

-- | In general Block consists of header and body. It may contain extra
--   data as well.
data GenericBlock b
GenericBlock :: !(GenericBlockHeader b) -> !(Body b) -> !(ExtraBodyData b) -> GenericBlock b
[_gbHeader] :: GenericBlock b -> !(GenericBlockHeader b)
[_gbBody] :: GenericBlock b -> !(Body b)
[_gbExtra] :: GenericBlock b -> !(ExtraBodyData b)
class HasPrevBlock s
prevBlockL :: HasPrevBlock s => Lens' s HeaderHash
gbBody :: forall b_a2FRP. Lens' (GenericBlock b_a2FRP) (Body b_a2FRP)
gbHeader :: forall b_a2FRP. Lens' (GenericBlock b_a2FRP) (GenericBlockHeader b_a2FRP)
gbExtra :: forall b_a2FRP. Lens' (GenericBlock b_a2FRP) (ExtraBodyData b_a2FRP)

-- | Lens from <a>GenericBlock</a> to <a>BodyProof</a>.
gbBodyProof :: Lens' (GenericBlock b) (BodyProof b)
gbhConsensus :: forall b_a2FRQ. Lens' (GenericBlockHeader b_a2FRQ) (ConsensusData b_a2FRQ)
gbhExtra :: forall b_a2FRQ. Lens' (GenericBlockHeader b_a2FRQ) (ExtraHeaderData b_a2FRQ)
gbhPrevBlock :: forall b_a2FRQ. Lens' (GenericBlockHeader b_a2FRQ) (BHeaderHash b_a2FRQ)
gbhBodyProof :: forall b_a2FRQ. Lens' (GenericBlockHeader b_a2FRQ) (BodyProof b_a2FRQ)
instance GHC.Generics.Generic (Pos.Types.Block.Class.GenericBlockHeader b)
instance GHC.Generics.Generic (Pos.Types.Block.Class.GenericBlock b)
instance (GHC.Show.Show (Pos.Types.Block.Class.BHeaderHash b), GHC.Show.Show (Pos.Types.Block.Class.BodyProof b), GHC.Show.Show (Pos.Types.Block.Class.ConsensusData b), GHC.Show.Show (Pos.Types.Block.Class.ExtraHeaderData b)) => GHC.Show.Show (Pos.Types.Block.Class.GenericBlockHeader b)
instance (GHC.Classes.Eq (Pos.Types.Block.Class.BHeaderHash b), GHC.Classes.Eq (Pos.Types.Block.Class.BodyProof b), GHC.Classes.Eq (Pos.Types.Block.Class.ConsensusData b), GHC.Classes.Eq (Pos.Types.Block.Class.ExtraHeaderData b)) => GHC.Classes.Eq (Pos.Types.Block.Class.GenericBlockHeader b)
instance (GHC.Show.Show (Pos.Types.Block.Class.GenericBlockHeader b), GHC.Show.Show (Pos.Types.Block.Class.Body b), GHC.Show.Show (Pos.Types.Block.Class.ExtraBodyData b)) => GHC.Show.Show (Pos.Types.Block.Class.GenericBlock b)
instance (GHC.Classes.Eq (Pos.Types.Block.Class.BHeaderHash b), GHC.Classes.Eq (Pos.Types.Block.Class.Body b), GHC.Classes.Eq (Pos.Types.Block.Class.BodyProof b), GHC.Classes.Eq (Pos.Types.Block.Class.ConsensusData b), GHC.Classes.Eq (Pos.Types.Block.Class.ExtraBodyData b), GHC.Classes.Eq (Pos.Types.Block.Class.ExtraHeaderData b)) => GHC.Classes.Eq (Pos.Types.Block.Class.GenericBlock b)
instance (Control.DeepSeq.NFData (Pos.Types.Block.Class.BHeaderHash b), Control.DeepSeq.NFData (Pos.Types.Block.Class.BodyProof b), Control.DeepSeq.NFData (Pos.Types.Block.Class.ConsensusData b), Control.DeepSeq.NFData (Pos.Types.Block.Class.ExtraHeaderData b)) => Control.DeepSeq.NFData (Pos.Types.Block.Class.GenericBlockHeader b)

module Pos.Types.Coin

-- | Coin formatter which restricts type.
coinF :: Format r (Coin -> r)
sumCoins :: [Coin] -> Integer

-- | Make Coin from Word64.
mkCoin :: Word64 -> Coin

-- | Unwraps <a>Coin</a>. It's called “unsafe” so that people wouldn't use
--   it willy-nilly if they want to sum coins or something. It's actually
--   safe.
unsafeGetCoin :: Coin -> Word64
coinToInteger :: Coin -> Integer
unsafeIntegerToCoin :: Integer -> Coin

-- | Only use if you're sure there'll be no overflow.
unsafeAddCoin :: Coin -> Coin -> Coin

-- | Only use if you're sure there'll be no underflow.
unsafeSubCoin :: Coin -> Coin -> Coin

-- | Only use if you're sure there'll be no overflow.
unsafeMulCoin :: Integral a => Coin -> a -> Coin
divCoin :: Integral a => Coin -> a -> Coin

-- | Apply CoinPortion to Coin. 'applyCoinPortion a b' is basically 'round
--   (a * b)'.
applyCoinPortion :: CoinPortion -> Coin -> Coin
instance Data.Text.Buildable.Buildable Pos.Types.Core.CoinPortion


-- | Slotting functionality.
module Pos.Types.Timestamp

-- | Timestamp is a number which represents some point in time. It is used
--   in MonadSlots and its meaning is up to implementation of this type
--   class. The only necessary knowledge is that difference between
--   timestamps is microsecond. Hence underlying type is Microsecond.
newtype Timestamp
Timestamp :: Microsecond -> Timestamp
[getTimestamp] :: Timestamp -> Microsecond

-- | Specialized formatter for <a>Timestamp</a> data type.
timestampF :: Format r (Timestamp -> r)
instance GHC.Show.Show Pos.Types.Core.Timestamp
instance GHC.Read.Read Pos.Types.Core.Timestamp
instance Data.Text.Buildable.Buildable Pos.Types.Core.Timestamp


-- | Miscellaneous unclassified utility functions.
module Pos.Util

-- | Type for generating list of unique (nonrepeating) elemets.
class Nonrepeating a
nonrepeating :: Nonrepeating a => Int -> Gen [a]

-- | ArbitraryUnsafe class ~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   This class is the same as <a>Arbitrary</a>, except instances of this
--   class for stuff like public/secret keys, VSS shares, commitments etc.
--   are designed not to mimic real data as presisely as possible (using
--   OpenSSL random), but rather to be simple and efficient.
--   
--   This is especially useful for benchmarking.
--   
--   Note: we don't need <a>Generic</a> to derive instances of
--   <a>ArbitraryUnsafe</a>. We can either use one-line instance
--   declaration, or <tt>-XStandaloneDeriving</tt> or
--   <tt>-XDeriveAnyClass</tt> to write something like <tt>deriving
--   (Arbitrary, ArbitraryUnsafe)</tt>.
class ArbitraryUnsafe a where arbitraryUnsafe = arbitrary
arbitraryUnsafe :: ArbitraryUnsafe a => Gen a
arbitraryUnsafe :: (ArbitraryUnsafe a, Arbitrary a) => Gen a
makeSmall :: Gen a -> Gen a

-- | Choose a random (shuffled) subset of length n. Throws an error if
--   there's not enough elements.
sublistN :: Int -> [a] -> Gen [a]

-- | Unsafely create list of <tt>n</tt> random values to be picked (see
--   note in <a>Arbitrary</a> for explanation) Used because genSharedSecret
--   already returns a list of EncShares, making the <a>replicateM</a>
--   unneeded.
unsafeMakeList :: Text -> IO [a] -> [a]

-- | Unsafely create pool of <tt>n</tt> random values to be picked (see
--   note in <a>Arbitrary</a> for explanation)
unsafeMakePool :: Text -> Int -> IO a -> [a]

-- | Make arbitrary <a>ByteString</a> of given length.
arbitrarySizedS :: Int -> Gen ByteString

-- | Make arbitrary <a>Lazy</a> of given length.
arbitrarySizedSL :: Int -> Gen ByteString

-- | Get something out of a quickcheck <a>Gen</a> without having to do IO
runGen :: Gen a -> a

-- | A wrapper over <a>ByteString</a> for adding type safety to
--   <a>encryptRaw</a> and friends.
data Raw

-- | A helper for <a>Data.SafeCopy</a> that creates <a>getCopy</a> given a
--   <tt>Binary</tt> instance.
getCopyBinary :: Bi a => String -> Contained (Get a)

-- | A helper for <a>Data.SafeCopy</a> that creates <a>putCopy</a> given a
--   <tt>Binary</tt> instance.
putCopyBinary :: Bi a => a -> Contained Put

-- | See <a>SerTypes</a> for details on this types
newtype AsBinary a
AsBinary :: ByteString -> AsBinary a
[getAsBinary] :: AsBinary a -> ByteString
class AsBinaryClass a
asBinary :: AsBinaryClass a => a -> AsBinary a
fromBinary :: AsBinaryClass a => AsBinary a -> Either String a
fromBinaryM :: (AsBinaryClass a, MonadFail m) => AsBinary a -> m a

-- | Serialize something together with its length in bytes. The length
--   comes first.
putWithLength :: PutM a -> PutM a

-- | Read length in bytes and then parse something (which has to have
--   exactly that length).
getWithLength :: Get a -> Get a

-- | Read length in bytes, check that it's not bigger than the limit, and
--   then parse something (which has to have exactly parsed length).
getWithLengthLimited :: Int64 -> Get a -> Get a

-- | Like <a>putWithLength</a>, but should only be used for things that
--   take less than <tt>2^14</tt> bytes.
--   
--   Uses <tt>TinyVarInt</tt> for storing length, thus guaranteeing that it
--   won't take more than 2 bytes and won't be ambiguous.
putSmallWithLength :: PutM a -> PutM a

-- | Like <a>getWithLength</a> but for <a>putSmallWithLength</a>.
getSmallWithLength :: Get a -> Get a
getRemainingByteString :: Get ByteString
getAsciiString1b :: String -> Word8 -> Get String
putAsciiString1b :: String -> Put
mappendPair :: (Monoid a, Monoid b) => (a, b) -> (a, b) -> (a, b)
mconcatPair :: (Monoid a, Monoid b) => [(a, b)] -> (a, b)

-- | Convert (Reader s) to any (MonadState s)
readerToState :: MonadState s m => Reader s a -> m a

-- | A helper for simple error handling in executables
eitherPanic :: Show a => Text -> Either a b -> b

-- | This function performs checks at compile-time for different actions.
--   May slowdown implementation. To disable such checks (especially in
--   benchmarks) one should compile with: <tt>stack build --flag
--   cardano-sl:-asserts</tt>
inAssertMode :: Applicative m => m a -> m ()

-- | Remove elements which are in <tt>b</tt> from <tt>a</tt>
diffDoubleMap :: forall k1 k2 v. (Eq k1, Eq k2, Hashable k1, Hashable k2) => HashMap k1 (HashMap k2 v) -> HashMap k1 (HashMap k2 v) -> HashMap k1 (HashMap k2 v)

-- | Create HashSet from HashMap's keys
getKeys :: HashMap k v -> HashSet k
maybeThrow :: (MonadThrow m, Exception e) => e -> Maybe a -> m a
maybeThrow' :: (Mockable Throw m, Exception e) => e -> Maybe a -> m a
parseIntegralSafe :: Integral a => Parser a
allDistinct :: Ord a => [a] -> Bool
type NE = NonEmpty
neZipWith3 :: (x -> y -> z -> q) -> NonEmpty x -> NonEmpty y -> NonEmpty z -> NonEmpty q
newtype NewestFirst f a
NewestFirst :: f a -> NewestFirst f a
[getNewestFirst] :: NewestFirst f a -> f a
newtype OldestFirst f a
OldestFirst :: f a -> OldestFirst f a
[getOldestFirst] :: OldestFirst f a -> f a
toNewestFirst :: Chrono f => OldestFirst f a -> NewestFirst f a
toOldestFirst :: Chrono f => NewestFirst f a -> OldestFirst f a

-- | Make lenses for a data family instance.
makeLensesData :: Name -> Name -> DecsQ

-- | A <a>magnify</a> which in <a>MonadReader</a>.
magnify' :: MonadReader s m => LensLike' (Magnified (Reader s) a) s t -> ReaderT t Identity a -> m a

-- | Lens for the head of <a>NonEmpty</a>.
--   
--   We can't use <tt>_head</tt> because it doesn't work for
--   <a>NonEmpty</a>:
--   <a>https://github.com/ekmett/lens/issues/636#issuecomment-213981096</a>.
--   Even if we could though, it wouldn't be a lens, only a traversal.
_neHead :: Lens' (NonEmpty a) a

-- | Lens for the tail of <a>NonEmpty</a>.
_neTail :: Lens' (NonEmpty a) [a]

-- | Lens for the last element of <a>NonEmpty</a>.
_neLast :: Lens' (NonEmpty a) a

-- | A <a>zoom</a> which works in <a>MonadState</a>.
--   
--   See <a>https://github.com/ekmett/lens/issues/580</a>. You might be
--   surprised but actual <a>zoom</a> doesn't work in any
--   <a>MonadState</a>, it only works in a handful of state monads and
--   their combinations defined by <tt>Zoom</tt>.
zoom' :: MonadState s m => LensLike' (Zoomed (State s) a) s t -> StateT t Identity a -> m a
data Color :: *
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color

-- | Prettify <a>Text</a> message with <a>Vivid</a> color.
colorize :: Color -> Text -> Text

-- | Write colored message, do some action, write colored message. Intended
--   for debug only.
withColoredMessages :: MonadIO m => Color -> Text -> m a -> m a

-- | Remove all items from LRU, retaining maxSize property.
clearLRU :: Ord k => LRU k v -> LRU k v

-- | Makes a span on the list, considering tail only. Predicate has list
--   head as first argument. Used to take non-null prefix that depends on
--   the first element.
spanSafe :: (a -> a -> Bool) -> NonEmpty a -> (NonEmpty a, [a])
eitherToVerRes :: Either Text a -> VerificationRes
clearMVar :: MonadIO m => MVar a -> m ()
forcePutMVar :: MonadIO m => MVar a -> a -> m ()

-- | Block until value in MVar satisfies given predicate. When value
--   satisfies, it is returned.
readMVarConditional :: (MonadIO m) => (x -> Bool) -> MVar x -> m x

-- | Read until value is equal to stored value comparing by some function.
readUntilEqualMVar :: (Eq a, MonadIO m) => (x -> a) -> MVar x -> a -> m x

-- | Block until value in TVar satisfies given predicate. When value
--   satisfies, it is returned.
readTVarConditional :: (MonadIO m) => (x -> Bool) -> TVar x -> m x

-- | Read until value is equal to stored value comparing by some function.
readUntilEqualTVar :: (Eq a, MonadIO m) => (x -> a) -> TVar x -> a -> m x
withReadLifted :: (MonadIO m, MonadMask m) => RWLock -> m a -> m a
withWriteLifted :: (MonadIO m, MonadMask m) => RWLock -> m a -> m a
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (System.Wlog.LoggerNameBox.LoggerNameBox m)
instance Pos.Util.OldestFirst f0 a0 ~ t0 => Control.Lens.Wrapped.Rewrapped (Pos.Util.OldestFirst f1 a1) t0
instance Control.Lens.Wrapped.Wrapped (Pos.Util.OldestFirst f0 a0)
instance Control.Lens.Each.Each (f a) (f b) a b => Control.Lens.Each.Each (Pos.Util.NewestFirst f a) (Pos.Util.NewestFirst f b) a b
instance Control.Lens.Each.Each (f a) (f b) a b => Control.Lens.Each.Each (Pos.Util.OldestFirst f a) (Pos.Util.OldestFirst f b) a b
instance Containers.One (f a) => Containers.One (Pos.Util.NewestFirst f a)
instance Containers.One (f a) => Containers.One (Pos.Util.OldestFirst f a)
instance Pos.Util.Chrono []
instance Pos.Util.Chrono Data.List.NonEmpty.NonEmpty
instance Language.Haskell.TH.Syntax.Lift Serokell.Data.Memory.Units.Byte
instance Data.Aeson.Types.Class.FromJSON Serokell.Data.Memory.Units.Byte
instance Data.Aeson.Types.Class.ToJSON Serokell.Data.Memory.Units.Byte
instance Data.SafeCopy.SafeCopy.SafeCopy a => Data.SafeCopy.SafeCopy.SafeCopy (Data.List.NonEmpty.NonEmpty a)
instance Data.SafeCopy.SafeCopy.SafeCopy Data.Time.Units.Millisecond
instance Data.SafeCopy.SafeCopy.SafeCopy Data.Time.Units.Microsecond
instance (GHC.Classes.Ord k, Data.SafeCopy.SafeCopy.SafeCopy k, Data.SafeCopy.SafeCopy.SafeCopy v) => Data.SafeCopy.SafeCopy.SafeCopy (Data.Cache.LRU.Internal.LRU k v)
instance Data.String.IsString s => Control.Monad.Fail.MonadFail (Data.Either.Either s)
instance Control.Monad.Fail.MonadFail (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Pos.Util.NewestFirst f0 a0 ~ t0 => Control.Lens.Wrapped.Rewrapped (Pos.Util.NewestFirst f1 a1) t0
instance Control.Lens.Wrapped.Wrapped (Pos.Util.NewestFirst f0 a0)
instance Test.QuickCheck.Arbitrary.Arbitrary (f a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Util.OldestFirst f a)
instance Pos.Binary.Class.Bi (f a) => Pos.Binary.Class.Bi (Pos.Util.OldestFirst f a)
instance Data.Binary.Class.Binary (f a) => Data.Binary.Class.Binary (Pos.Util.OldestFirst f a)
instance Containers.NontrivialContainer (f a) => Containers.NontrivialContainer (Pos.Util.OldestFirst f a)
instance Containers.Container (f a) => Containers.Container (Pos.Util.OldestFirst f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Pos.Util.OldestFirst f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Pos.Util.OldestFirst f)
instance GHC.Base.Functor f => GHC.Base.Functor (Pos.Util.OldestFirst f)
instance GHC.Show.Show (f a) => GHC.Show.Show (Pos.Util.OldestFirst f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Pos.Util.OldestFirst f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Pos.Util.OldestFirst f a)
instance Test.QuickCheck.Arbitrary.Arbitrary (f a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Util.NewestFirst f a)
instance Pos.Binary.Class.Bi (f a) => Pos.Binary.Class.Bi (Pos.Util.NewestFirst f a)
instance Data.Binary.Class.Binary (f a) => Data.Binary.Class.Binary (Pos.Util.NewestFirst f a)
instance Containers.NontrivialContainer (f a) => Containers.NontrivialContainer (Pos.Util.NewestFirst f a)
instance Containers.Container (f a) => Containers.Container (Pos.Util.NewestFirst f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Pos.Util.NewestFirst f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Pos.Util.NewestFirst f)
instance GHC.Base.Functor f => GHC.Base.Functor (Pos.Util.NewestFirst f)
instance GHC.Show.Show (f a) => GHC.Show.Show (Pos.Util.NewestFirst f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Pos.Util.NewestFirst f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Pos.Util.NewestFirst f a)
instance Data.SafeCopy.SafeCopy.SafeCopy Serokell.Util.Verify.VerificationRes


-- | Exceptions hierarchy in cardano-sl.
module Pos.Exception

-- | Root of exceptions in cardano-sl.
data CardanoException
CardanoException :: e -> CardanoException

-- | Helper to define sub-exception of CardanoException.
cardanoExceptionToException :: (Buildable e, Exception e) => e -> SomeException

-- | Helper to define sub-exception of CardanoException.
cardanoExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Error indicating that something really bad happened. Should be used
--   when serious assertions fail (local equivalent of <a>panic</a>).
--   <a>panic</a> is still alright to use, but preferably in pure
--   environment.
data CardanoFatalError
CardanoFatalError :: !Text -> CardanoFatalError

-- | Print red message about fatal error and throw exception.
reportFatalError :: (WithLogger m, MonadThrow m) => Text -> m a

-- | Report <a>CardanoFatalError</a> for failed assertions.
assertionFailed :: (WithLogger m, MonadThrow m) => Text -> m a
instance GHC.Show.Show Pos.Exception.CardanoFatalError
instance GHC.Show.Show Pos.Exception.CardanoException
instance GHC.Exception.Exception Pos.Exception.CardanoException
instance Data.Text.Buildable.Buildable Pos.Exception.CardanoException
instance Data.Text.Buildable.Buildable Pos.Exception.CardanoFatalError
instance GHC.Exception.Exception Pos.Exception.CardanoFatalError

module Pos.Types.Version

-- | Communication protocol version.
data BlockVersion
BlockVersion :: !Word16 -> !Word16 -> !Word8 -> BlockVersion
[bvMajor] :: BlockVersion -> !Word16
[bvMinor] :: BlockVersion -> !Word16
[bvAlt] :: BlockVersion -> !Word8
parseBlockVersion :: Parser BlockVersion

-- | Numeric software version associated with ApplicationName.
type NumSoftwareVersion = Word32

-- | Software version.
data SoftwareVersion
SoftwareVersion :: !ApplicationName -> !NumSoftwareVersion -> SoftwareVersion
[svAppName] :: SoftwareVersion -> !ApplicationName
[svNumber] :: SoftwareVersion -> !NumSoftwareVersion
newtype ApplicationName
ApplicationName :: Text -> ApplicationName
[getApplicationName] :: ApplicationName -> Text
mkApplicationName :: MonadFail m => Text -> m ApplicationName
applicationNameMaxLength :: Integral i => i
parseSoftwareVersion :: Parser SoftwareVersion
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Types.Core.SoftwareVersion
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Types.Core.BlockVersion
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Types.Core.ApplicationName
instance GHC.Show.Show Pos.Types.Core.BlockVersion
instance Data.Text.Buildable.Buildable Pos.Types.Core.BlockVersion
instance Data.Hashable.Class.Hashable Pos.Types.Core.BlockVersion
instance Data.Text.Buildable.Buildable Pos.Types.Core.SoftwareVersion
instance GHC.Show.Show Pos.Types.Core.SoftwareVersion
instance Data.Hashable.Class.Hashable Pos.Types.Core.SoftwareVersion


-- | Core of Update System.
module Pos.Update.Core

-- | Proposal for software update
data UpdateProposal
UpdateProposal :: !BlockVersion -> !BlockVersionData -> !SoftwareVersion -> !(HashMap SystemTag UpdateData) -> !UpAttributes -> UpdateProposal
[upBlockVersion] :: UpdateProposal -> !BlockVersion
[upBlockVersionData] :: UpdateProposal -> !BlockVersionData
[upSoftwareVersion] :: UpdateProposal -> !SoftwareVersion

-- | UpdateData for each system which this update affects. It must be
--   non-empty.
[upData] :: UpdateProposal -> !(HashMap SystemTag UpdateData)

-- | Attributes which are currently empty, but provide extensibility.
[upAttributes] :: UpdateProposal -> !UpAttributes

-- | ID of softwaree update proposal
type UpId = Hash UpdateProposal
type UpAttributes = Attributes ()

-- | Data which describes update. It is specific for each system.
data UpdateData
UpdateData :: !(Hash Raw) -> !(Hash Raw) -> !(Hash Raw) -> !(Hash Raw) -> UpdateData

-- | Hash of binary diff between two applications. This diff can be passed
--   to updater to create new application.
[udAppDiffHash] :: UpdateData -> !(Hash Raw)

-- | Hash of package to install new application. This package can be used
--   to install new application from scratch instead of updating existing
--   application.
[udPkgHash] :: UpdateData -> !(Hash Raw)

-- | Hash if update application which can be used to install this update
--   (relevant only when updater is used, not package).
[udUpdaterHash] :: UpdateData -> !(Hash Raw)

-- | Hash of metadata relevant to this update. It is raw hash, because
--   metadata can include image or something (maybe). Anyway, we can always
--   use <a>unsafeHash</a>.
[udMetadataHash] :: UpdateData -> !(Hash Raw)

-- | Data which is associated with <a>BlockVersion</a>.
data BlockVersionData
BlockVersionData :: !ScriptVersion -> !Millisecond -> !Byte -> !Byte -> !CoinPortion -> !CoinPortion -> !CoinPortion -> !CoinPortion -> !FlatSlotId -> !CoinPortion -> BlockVersionData
[bvdScriptVersion] :: BlockVersionData -> !ScriptVersion
[bvdSlotDuration] :: BlockVersionData -> !Millisecond
[bvdMaxBlockSize] :: BlockVersionData -> !Byte
[bvdMaxTxSize] :: BlockVersionData -> !Byte
[bvdMpcThd] :: BlockVersionData -> !CoinPortion
[bvdHeavyDelThd] :: BlockVersionData -> !CoinPortion
[bvdUpdateVoteThd] :: BlockVersionData -> !CoinPortion
[bvdUpdateProposalThd] :: BlockVersionData -> !CoinPortion
[bvdUpdateImplicit] :: BlockVersionData -> !FlatSlotId
[bvdUpdateSoftforkThd] :: BlockVersionData -> !CoinPortion

-- | Tag of system for which update data is purposed, e.g. win64, mac32
data SystemTag
mkSystemTag :: MonadFail m => Text -> m SystemTag
systemTagMaxLength :: Integral i => i
patakUpdateData :: HashMap SystemTag UpdateData
skovorodaUpdateData :: Hash Raw -> HashMap SystemTag UpdateData
upScriptVersion :: UpdateProposal -> ScriptVersion
upSlotDuration :: UpdateProposal -> Millisecond
upMaxBlockSize :: UpdateProposal -> Byte

-- | Format <a>UpdateVote</a> compactly.
formatVoteShort :: UpdateVote -> Builder

-- | Formatter for <a>UpdateVote</a> which displays it compactly.
shortVoteF :: Format r (UpdateVote -> r)

-- | Vote for update proposal
data UpdateVote
UpdateVote :: !PublicKey -> !UpId -> !Bool -> !(Signature (UpId, Bool)) -> UpdateVote

-- | Public key of stakeholder, who votes
[uvKey] :: UpdateVote -> !PublicKey

-- | Proposal to which this vote applies
[uvProposalId] :: UpdateVote -> !UpId

-- | Approval/rejection bit
[uvDecision] :: UpdateVote -> !Bool

-- | Signature of (Update proposal, Approval/rejection bit) by stakeholder
[uvSignature] :: UpdateVote -> !(Signature (UpId, Bool))
type VoteId = (UpId, PublicKey, Bool)

-- | Type alias for set of votes from stakeholders
type StakeholderVotes = HashMap PublicKey VoteState
type UpdateProposals = HashMap UpId UpdateProposal
type LocalVotes = HashMap UpId (HashMap PublicKey UpdateVote)
mkVoteId :: UpdateVote -> VoteId

-- | Update System payload. <a>BodyProof</a> contains <a>UpdateProof</a> =
--   <tt>Hash UpdatePayload</tt>.
data UpdatePayload
UpdatePayload :: !(Maybe UpdateProposal) -> ![UpdateVote] -> UpdatePayload
[upProposal] :: UpdatePayload -> !(Maybe UpdateProposal)
[upVotes] :: UpdatePayload -> ![UpdateVote]

-- | Proof that body of update message contains <a>UpdatePayload</a>.
type UpdateProof = Hash UpdatePayload
mkUpdateProof :: Bi UpdatePayload => UpdatePayload -> UpdateProof

-- | This type represents summary of votes issued by stakeholder.
data VoteState

-- | Stakeholder voted once positively.
PositiveVote :: VoteState

-- | Stakeholder voted once positively.
NegativeVote :: VoteState

-- | Stakeholder voted negatively, then positively.
PositiveRevote :: VoteState

-- | Stakeholder voted positively, then negatively.
NegativeRevote :: VoteState

-- | Check whether given decision is a valid vote if applied to existing
--   vote (which may not exist).
canCombineVotes :: Bool -> Maybe VoteState -> Bool

-- | Apply decision to given vote (or Nothing). This function returns
--   <a>Nothing</a> if decision can't be applied. <a>canCombineVotes</a>
--   can be used to check whether it will be successful.
combineVotes :: Bool -> Maybe VoteState -> Maybe VoteState
isPositiveVote :: VoteState -> Bool

-- | Create new VoteState from bool, which is simple vote, not revote.
newVoteState :: Bool -> VoteState


-- | Secret key file storage and management functions based on file
--   locking.
module Pos.Util.UserSecret

-- | User secret data. Includes secret keys only for now (not including
--   auxiliary <tt>_usPath</tt>).
data UserSecret
usKeys :: Lens' UserSecret [SecretKey]
usVss :: Lens' UserSecret (Maybe VssKeyPair)
getUSPath :: UserSecret -> FilePath

-- | Create a simple UserSecret from secret key and file path
simpleUserSecret :: SecretKey -> FilePath -> UserSecret

-- | Create user secret file at the given path, but only when one doesn't
--   already exist.
initializeUserSecret :: (MonadIO m) => FilePath -> m ()

-- | Reads user secret from the given file. If the file does not exist/is
--   empty, returns empty user secret
peekUserSecret :: (MonadIO m) => FilePath -> m UserSecret

-- | Read user secret putting an exclusive lock on it. To unlock, use
--   <a>writeUserSecretRelease</a>.
takeUserSecret :: (MonadIO m) => FilePath -> m UserSecret

-- | Writes user secret .
writeUserSecret :: (MonadIO m) => UserSecret -> m ()

-- | Writes user secret and releases the lock. UserSecret can't be used
--   after this function call anymore.
writeUserSecretRelease :: (MonadFail m, MonadIO m) => UserSecret -> m ()
instance GHC.Show.Show Pos.Util.UserSecret.UserSecret
instance Data.Default.Class.Default Pos.Util.UserSecret.UserSecret
instance Pos.Binary.Class.Bi Pos.Util.UserSecret.UserSecret


-- | Module for command-line utilites, parsers and convenient handlers.
module Pos.CLI

-- | Parsed for network address in format <tt>host:port</tt>.
addrParser :: Parser NetworkAddress
attackTypeParser :: Parser AttackType
attackTargetParser :: Parser AttackTarget

-- | Default logger config. Will be used if `--log-config` argument is not
--   passed. Corresponds to next logger config:
--   
--   <pre>
--   node:
--     severity: Info
--     comm:
--       severity: Warning
--   </pre>
defaultLoggerConfig :: LoggerConfig

-- | Parser for DHT key.
dhtKeyParser :: Parser DHTKey

-- | Parser for <a>DHTNode</a>.
dhtNodeParser :: Parser DHTNode

-- | Reads logger config from given path. By default return
--   <a>defaultLoggerConfig</a>.
readLoggerConfig :: MonadIO m => Maybe FilePath -> m LoggerConfig

-- | Decides which secret-sharing algorithm to use.
sscAlgoParser :: Parser SscAlgo
data CommonArgs
CommonArgs :: !Bool -> ![DHTNode] -> !(Maybe FilePath) -> !(Maybe FilePath) -> !(Maybe FilePath) -> !SscAlgo -> !Bool -> ![Text] -> ![Text] -> !(Maybe (Int, Int)) -> !(Maybe (Int, Int)) -> !Bool -> CommonArgs
[dhtExplicitInitial] :: CommonArgs -> !Bool
[dhtPeers] :: CommonArgs -> ![DHTNode]
[dhtPeersFile] :: CommonArgs -> !(Maybe FilePath)
[logConfig] :: CommonArgs -> !(Maybe FilePath)
[logPrefix] :: CommonArgs -> !(Maybe FilePath)
[sscAlgo] :: CommonArgs -> !SscAlgo
[disablePropagation] :: CommonArgs -> !Bool
[reportServers] :: CommonArgs -> ![Text]
[updateServers] :: CommonArgs -> ![Text]
[flatDistr] :: CommonArgs -> !(Maybe (Int, Int))
[bitcoinDistr] :: CommonArgs -> !(Maybe (Int, Int))
[expDistr] :: CommonArgs -> !Bool
commonArgsParser :: String -> Parser CommonArgs
optionalJSONPath :: Parser (Maybe FilePath)
optionalLogPrefix :: Parser (Maybe String)
portOption :: Word16 -> Parser Word16
timeLordOption :: Parser Bool
webPortOption :: Word16 -> String -> Parser Word16
ipPortOption :: NetworkAddress -> Parser NetworkAddress

-- | Parse <a>DHTNode</a>s from a file (nodes should be separated by
--   newlines).
readPeersFile :: FilePath -> IO [DHTNode]
instance GHC.Show.Show Pos.CLI.CommonArgs


-- | Definitions of the most fundamental types.
module Pos.Types.Types

-- | Represents transaction attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending transaction with new
--   fields via softfork.
type TxAttributes = Attributes ()

-- | A witness for a single input.
data TxInWitness
PkWitness :: !PublicKey -> !TxSig -> TxInWitness
[twKey] :: TxInWitness -> !PublicKey
[twSig] :: TxInWitness -> !TxSig
ScriptWitness :: !Script -> !Script -> TxInWitness
[twValidator] :: TxInWitness -> !Script
[twRedeemer] :: TxInWitness -> !Script
UnknownWitnessType :: !Word8 -> !ByteString -> TxInWitness

-- | A witness is a proof that a transaction is allowed to spend the funds
--   it spends (by providing signatures, redeeming scripts, etc). A
--   separate proof is provided for each input.
type TxWitness = Vector TxInWitness

-- | Distribution of “fake” stake that follow-the-satoshi would use for a
--   particular transaction.
newtype TxDistribution
TxDistribution :: [[(StakeholderId, Coin)]] -> TxDistribution
[getTxDistribution] :: TxDistribution -> [[(StakeholderId, Coin)]]

-- | Data that is being signed when creating a TxSig.
type TxSigData = (TxId, Word32, Hash [TxOut], Hash TxDistribution)

-- | <a>Signature</a> of addrId.
type TxSig = Signature TxSigData

-- | Represents transaction identifier as <a>Hash</a> of <a>Tx</a>.
type TxId = Hash Tx

-- | Transaction input.
data TxIn
TxIn :: !TxId -> !Word32 -> TxIn

-- | Which transaction's output is used
[txInHash] :: TxIn -> !TxId

-- | Index of the output in transaction's outputs
[txInIndex] :: TxIn -> !Word32

-- | Make pair from TxIn
toPair :: TxIn -> (TxId, Word32)

-- | Transaction output.
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[txOutAddress] :: TxOut -> !Address
[txOutValue] :: TxOut -> !Coin

-- | Use this function if you need to know how a <a>TxOut</a> distributes
--   stake (e.g. for the purpose of running follow-the-satoshi).
txOutStake :: TxOutAux -> [(StakeholderId, Coin)]

-- | Transaction.
--   
--   NB: transaction witnesses are stored separately.
data Tx
Tx :: ![TxIn] -> ![TxOut] -> !TxAttributes -> Tx

-- | Inputs of transaction.
[txInputs] :: Tx -> ![TxIn]

-- | Outputs of transaction.
[txOutputs] :: Tx -> ![TxOut]

-- | Attributes of transaction
[txAttributes] :: Tx -> !TxAttributes
_txInputs :: Lens' Tx [TxIn]
_txOutputs :: Lens' Tx [TxOut]
_txAttributes :: Lens' Tx TxAttributes

-- | Specialized formatter for <a>Tx</a>.
txF :: Format r (Tx -> r)

-- | Specialized formatter for <a>Tx</a> with auxiliary data
txaF :: Bi Script => Format r (TxAux -> r)

-- | Transaction + auxiliary data
type TxAux = (Tx, TxWitness, TxDistribution)
type TxOutAux = (TxOut, [(StakeholderId, Coin)])

-- | Unspent transaction outputs.
--   
--   Transaction inputs are identified by (transaction ID, index in list of
--   output) pairs.
type Utxo = Map (TxId, Word32) TxOutAux

-- | Format <a>Utxo</a> map as json.
formatUtxo :: Utxo -> Builder

-- | Specialized formatter for <a>Utxo</a>.
utxoF :: Format r (Utxo -> r)

-- | Particular undo needed for transactions
type TxUndo = [[TxOutAux]]

-- | This is a shared seed used for follow-the-satoshi. This seed is
--   randomly generated by each party and eventually they agree on the same
--   value.
newtype SharedSeed
SharedSeed :: ByteString -> SharedSeed
[getSharedSeed] :: SharedSeed -> ByteString

-- | <a>NonEmpty</a> list of slot leaders.
type SlotLeaders = NonEmpty StakeholderId

-- | Proxy signature used in csl -- holds a pair of epoch indices. Block is
--   valid if it's epoch index is inside this range.
type ProxySigLight a = ProxySignature (EpochIndex, EpochIndex) a

-- | Same alias for the proxy secret key (see <a>ProxySigLight</a>).
type ProxySKLight = ProxySecretKey (EpochIndex, EpochIndex)

-- | Simple proxy signature without ttl/epoch index constraints.
--   <a>EpochIndex</a> inside is needed for replay attack prevention.
type ProxySigHeavy a = ProxySignature EpochIndex a

-- | Correspondent SK for no-ttl proxy signature scheme.
type ProxySKHeavy = ProxySecretKey EpochIndex

-- | Some proxy secret key.
type ProxySKEither = Either ProxySKLight ProxySKHeavy
instance Control.DeepSeq.NFData Pos.Types.Types.Tx
instance Control.DeepSeq.NFData Pos.Types.Types.TxDistribution
instance Control.DeepSeq.NFData Pos.Types.Types.TxOut
instance Control.DeepSeq.NFData Pos.Types.Types.TxInWitness
instance Control.DeepSeq.NFData Pos.Types.Types.TxIn
instance Control.DeepSeq.NFData Pos.Types.Types.SharedSeed
instance GHC.Generics.Generic Pos.Types.Types.SharedSeed
instance GHC.Classes.Ord Pos.Types.Types.SharedSeed
instance GHC.Classes.Eq Pos.Types.Types.SharedSeed
instance GHC.Show.Show Pos.Types.Types.SharedSeed
instance Data.Hashable.Class.Hashable Pos.Types.Types.Tx
instance Data.Text.Buildable.Buildable Pos.Types.Types.Tx
instance Data.Text.Buildable.Buildable Pos.Types.Types.SharedSeed
instance GHC.Generics.Generic Pos.Types.Types.TxInWitness
instance GHC.Show.Show Pos.Types.Types.TxInWitness
instance GHC.Classes.Eq Pos.Types.Types.TxInWitness
instance GHC.Generics.Generic Pos.Types.Types.TxIn
instance GHC.Show.Show Pos.Types.Types.TxIn
instance GHC.Classes.Ord Pos.Types.Types.TxIn
instance GHC.Classes.Eq Pos.Types.Types.TxIn
instance GHC.Show.Show Pos.Types.Types.Tx
instance GHC.Generics.Generic Pos.Types.Types.Tx
instance GHC.Classes.Ord Pos.Types.Types.Tx
instance GHC.Classes.Eq Pos.Types.Types.Tx
instance GHC.Show.Show Pos.Types.Types.TxOut
instance GHC.Generics.Generic Pos.Types.Types.TxOut
instance GHC.Classes.Ord Pos.Types.Types.TxOut
instance GHC.Classes.Eq Pos.Types.Types.TxOut
instance GHC.Generics.Generic Pos.Types.Types.TxDistribution
instance GHC.Show.Show Pos.Types.Types.TxDistribution
instance GHC.Classes.Eq Pos.Types.Types.TxDistribution
instance Data.Hashable.Class.Hashable Pos.Types.Types.TxInWitness
instance Pos.Binary.Class.Bi Pos.Script.Type.Script => Data.Text.Buildable.Buildable Pos.Types.Types.TxInWitness
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxDistribution
instance Data.Hashable.Class.Hashable Pos.Types.Types.TxIn
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxIn
instance Data.Hashable.Class.Hashable Pos.Types.Types.TxOut
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxOut
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxOutAux


-- | A wrapper over Plutus (the scripting language used in transactions).
module Pos.Script

-- | A script for inclusion into a transaction.
data Script

-- | Serialized script
Script :: ScriptVersion -> LByteString -> Script

-- | Version
[scrVersion] :: Script -> ScriptVersion
[scrScript] :: Script -> LByteString
type TxScriptError = String

-- | Validate a transaction, given a validator and a redeemer.
txScriptCheck :: Bi Script_v0 => TxSigData -> Script -> Script -> Either TxScriptError ()

-- | Parse a script intended to serve as a validator (or “lock”) in a
--   transaction output.
parseValidator :: Bi Script_v0 => Text -> Either String Script

-- | Parse a script intended to serve as a redeemer (or “proof”) in a
--   transaction input.
--   
--   Can be given an optional validator (e.g. if the redeemer uses
--   functions or types defined by the validator).
parseRedeemer :: Bi Script_v0 => Maybe Script -> Text -> Either String Script
stdlib :: Program
isKnownScriptVersion :: ScriptVersion -> Bool


-- | Some example scripts used in tests.
module Pos.Script.Examples
alwaysSuccessValidator :: Script
alwaysFailureValidator :: Script
idValidator :: Script
intValidator :: Script
goodIntRedeemer :: Script
badIntRedeemer :: Script
stdlibValidator :: Script
goodStdlibRedeemer :: Script
multisigValidator :: Int -> [PublicKey] -> Script
multisigRedeemer :: TxSigData -> [Maybe SecretKey] -> Script
intValidatorWithBlah :: Script
goodIntRedeemerWithBlah :: Script

-- | Does N rounds of SHA3-256. Should be used with <a>idValidator</a>.
--   
--   Actually it does (N div 10) * 10 rounds. Unrolling the loop is done so
--   that more petrol would be spent on hashing and less – on substraction
--   and function calls.
shaStressRedeemer :: Int -> Script

-- | Checks a signature N times. Should be used with <a>idValidator</a>.
sigStressRedeemer :: Int -> Script


-- | <tt>Arbitrary</tt> unsafe instances for some types from <a>Types</a>.
module Pos.Types.Arbitrary.Unsafe
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Types.SharedSeed
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.EpochIndex
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.LocalSlotIndex
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.Coin
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.Address
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.SlotId
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Types.TxOut

module Pos.Types.Block.Types

-- | Represents blockchain consisting of main blocks, i. e. blocks with
--   transactions and MPC messages.
data MainBlockchain ssc

-- | Header of generic main block.
type MainBlockHeader ssc = GenericBlockHeader (MainBlockchain ssc)

-- | Represents main block extra data
newtype MainExtraBodyData
MainExtraBodyData :: BlockBodyAttributes -> MainExtraBodyData
[_mebAttributes] :: MainExtraBodyData -> BlockBodyAttributes

-- | Represents main block header extra data
data MainExtraHeaderData
MainExtraHeaderData :: !BlockVersion -> !SoftwareVersion -> !BlockHeaderAttributes -> MainExtraHeaderData

-- | Version of block.
[_mehBlockVersion] :: MainExtraHeaderData -> !BlockVersion

-- | Software version.
[_mehSoftwareVersion] :: MainExtraHeaderData -> !SoftwareVersion

-- | Header attributes
[_mehAttributes] :: MainExtraHeaderData -> !BlockHeaderAttributes

-- | Represents main block header attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending header with new fields
--   via softfork.
type BlockHeaderAttributes = Attributes ()

-- | Represents main block body attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending block with new fields
--   via softfork.
type BlockBodyAttributes = Attributes ()

-- | Ssc w/ buildable blockchain
type BiSsc ssc = (Ssc ssc, Bi (GenericBlockHeader (GenesisBlockchain ssc)), Bi (GenericBlockHeader (MainBlockchain ssc)))

-- | Signature of the block. Can be either regular signature from the
--   issuer or delegated signature having a constraint on epoch indices (it
--   means the signature is valid only if block's slot id has epoch inside
--   the constrained interval).
data BlockSignature ssc
BlockSignature :: (Signature (MainToSign ssc)) -> BlockSignature ssc
BlockPSignatureEpoch :: (ProxySigLight (MainToSign ssc)) -> BlockSignature ssc
BlockPSignatureSimple :: (ProxySigHeavy (MainToSign ssc)) -> BlockSignature ssc

-- | Data to be signed in main block.
type MainToSign ssc = (HeaderHash, BodyProof (MainBlockchain ssc), SlotId, ChainDifficulty)

-- | MainBlock is a block with transactions and MPC messages. It's the main
--   part of our consensus algorithm.
type MainBlock ssc = GenericBlock (MainBlockchain ssc)

-- | Represents blockchain consisting of genesis blocks. Genesis block
--   doesn't have any special payload and is not strictly necessary.
--   However, it is good idea to store list of leaders explicitly, because
--   calculating it may be expensive operation. For example, it is useful
--   for SPV-clients.
data GenesisBlockchain ssc

-- | Header of Genesis block.
type GenesisBlockHeader ssc = GenericBlockHeader (GenesisBlockchain ssc)

-- | Genesis block parametrized by <a>GenesisBlockchain</a>.
type GenesisBlock ssc = GenericBlock (GenesisBlockchain ssc)

-- | Either header of ordinary main block or genesis block.
type BlockHeader ssc = Either (GenesisBlockHeader ssc) (MainBlockHeader ssc)

-- | Block.
type Block ssc = Either (GenesisBlock ssc) (MainBlock ssc)
type BiHeader ssc = Bi (BlockHeader ssc)
mehBlockVersion :: Lens' MainExtraHeaderData BlockVersion
mehSoftwareVersion :: Lens' MainExtraHeaderData SoftwareVersion
mehAttributes :: Lens' MainExtraHeaderData BlockHeaderAttributes
mebAttributes :: Iso' MainExtraBodyData BlockBodyAttributes
instance Control.DeepSeq.NFData Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Generics.Generic Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Show.Show Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Classes.Eq Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Generics.Generic Pos.Types.Block.Types.MainExtraHeaderData
instance GHC.Show.Show Pos.Types.Block.Types.MainExtraHeaderData
instance GHC.Classes.Eq Pos.Types.Block.Types.MainExtraHeaderData
instance GHC.Generics.Generic (Pos.Types.Block.Types.BlockSignature ssc)
instance GHC.Classes.Eq (Pos.Types.Block.Types.BlockSignature ssc)
instance GHC.Show.Show (Pos.Types.Block.Types.BlockSignature ssc)
instance Control.DeepSeq.NFData (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc)) => Control.DeepSeq.NFData (Pos.Types.Block.Types.BlockSignature ssc)
instance Data.Text.Buildable.Buildable (Pos.Types.Block.Types.BlockSignature ssc)
instance Control.DeepSeq.NFData Pos.Types.Block.Types.MainExtraHeaderData
instance Data.Text.Buildable.Buildable Pos.Types.Block.Types.MainExtraHeaderData
instance Data.Text.Buildable.Buildable Pos.Types.Block.Types.MainExtraBodyData

module Pos.Types.Block.Instances

-- | Lens from <a>MainBlock</a> to <a>PublicKey</a>.
blockLeaderKey :: Lens' (MainBlock ssc) PublicKey

-- | Lens from <a>GenesisBlock</a> to <a>SlotLeaders</a>.
blockLeaders :: Lens' (GenesisBlock ssc) SlotLeaders

-- | Lens from <a>MainBlock</a> to <a>SscPayload</a>.
blockMpc :: Lens' (MainBlock ssc) (SscPayload ssc)

-- | Lens from <a>MainBlock</a> to <tt>Signature</tt>.
blockSignature :: Lens' (MainBlock ssc) (BlockSignature ssc)

-- | Lens from <a>MainBlock</a> to <a>SlotId</a>.
blockSlot :: Lens' (MainBlock ssc) SlotId

-- | Lens from <a>MainBlock</a> to <a>MerkleTree</a>.
blockTxs :: Lens' (MainBlock ssc) (MerkleTree Tx)

-- | Getter from <a>MainBlock</a> to a list of transactions together with
--   auxiliary data.
blockTxas :: Getter (MainBlock ssc) [TxAux]

-- | Lens from <a>MainBlock</a> to <a>ProxySKHeavy</a> list.
blockProxySKs :: Lens' (MainBlock ssc) [ProxySKHeavy]

-- | Lens for <a>ChainDifficulty</a> of <a>GenesisBlockchain</a> in
--   <a>ConsensusData</a>.
gcdDifficulty :: Lens' (ConsensusData (GenesisBlockchain ssc)) ChainDifficulty

-- | Lens for <a>EpochIndex</a> of <a>GenesisBlockchain</a> in
--   <a>ConsensusData</a>.
gcdEpoch :: Lens' (ConsensusData (GenesisBlockchain ssc)) EpochIndex

-- | Take <a>BlockHeader</a> from either <a>GenesisBlock</a> or
--   <a>MainBlock</a>.
getBlockHeader :: Block ssc -> BlockHeader ssc

-- | Lens from <a>MainBlockHeader</a> to <a>PublicKey</a>.
headerLeaderKey :: Lens' (MainBlockHeader ssc) PublicKey

-- | Lens from <a>MainBlockHeader</a> to <tt>Signature</tt>.
headerSignature :: Lens' (MainBlockHeader ssc) (BlockSignature ssc)

-- | Lens from <a>MainBlockHeader</a> to <a>SlotId</a>.
headerSlot :: Lens' (MainBlockHeader ssc) SlotId

-- | Lens for <a>SscPayload</a> in main block body.
mbMpc :: Lens' (Body (MainBlockchain ssc)) (SscPayload ssc)

-- | Lens for transaction tree in main block body.
mbTxs :: Lens' (Body (MainBlockchain ssc)) (MerkleTree Tx)

-- | Lens for witness list in main block body.
mbWitnesses :: Lens' (Body (MainBlockchain ssc)) [TxWitness]

-- | Lens for ProxySKs in main block body.
mbProxySKs :: Lens' (Body (MainBlockchain ssc)) [ProxySKHeavy]

-- | Lens for <a>UpdatePayload</a> in main block body.
mbUpdatePayload :: Lens' (Body (MainBlockchain ssc)) UpdatePayload

-- | Lens for <a>SlotId</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdSlot :: Lens' (ConsensusData (MainBlockchain ssc)) SlotId

-- | Lens for <a>PublicKey</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdLeaderKey :: Lens' (ConsensusData (MainBlockchain ssc)) PublicKey

-- | Lens for <a>ChainDifficulty</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdDifficulty :: Lens' (ConsensusData (MainBlockchain ssc)) ChainDifficulty

-- | Lens for <tt>Signature</tt> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdSignature :: Lens' (ConsensusData (MainBlockchain ssc)) (BlockSignature ssc)
blockHeader :: Getter (Block ssc) (BlockHeader ssc)

-- | This function is required because type inference fails in attempts to
--   hash only <tt>Right</tt> or <tt>Left</tt>.
blockHeaderHash :: BiHeader ssc => BlockHeader ssc -> HeaderHash
instance GHC.Generics.Generic (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance (GHC.Classes.Eq (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Types.Ssc ssc) => GHC.Classes.Eq (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Pos.Ssc.Class.Helpers.SscHelpersClass ssc, Pos.Binary.Class.Bi Pos.Types.Types.TxWitness, Pos.Binary.Class.Bi Pos.Update.Core.Types.UpdatePayload, Pos.Binary.Class.Bi Pos.Types.Core.EpochIndex) => Pos.Types.Block.Class.Blockchain (Pos.Types.Block.Types.MainBlockchain ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Block.Class.Blockchain (Pos.Types.Block.Types.GenesisBlockchain ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.MainBlockHeader ssc)
instance (Pos.Binary.Class.Bi Pos.Update.Core.Types.UpdateProposal, Pos.Types.Block.Types.BiSsc ssc) => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.BlockHeader ssc)
instance Pos.Types.Core.HasEpochIndex Pos.Types.Core.SlotId
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance (Pos.Types.Core.HasEpochIndex a, Pos.Types.Core.HasEpochIndex b) => Pos.Types.Core.HasEpochIndex (Data.Either.Either a b)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Block.Types.GenesisBlock ssc)
instance (Pos.Types.Core.HasEpochOrSlot a, Pos.Types.Core.HasEpochOrSlot b) => Pos.Types.Core.HasEpochOrSlot (Data.Either.Either a b)
instance Pos.Types.Core.HasHeaderHash Pos.Types.Core.HeaderHash
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Block.Types.BlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Block.Types.Block ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Types.BlockHeader ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Block.Types.Block ssc)
instance Pos.Types.Block.Class.HasPrevBlock s => Pos.Types.Block.Class.HasPrevBlock (s, z)
instance Pos.Types.Block.Class.BHeaderHash b ~ Pos.Types.Core.HeaderHash => Pos.Types.Block.Class.HasPrevBlock (Pos.Types.Block.Class.GenericBlockHeader b)
instance Pos.Types.Block.Class.BHeaderHash b ~ Pos.Types.Core.HeaderHash => Pos.Types.Block.Class.HasPrevBlock (Pos.Types.Block.Class.GenericBlock b)
instance (Pos.Types.Block.Class.HasPrevBlock s, Pos.Types.Block.Class.HasPrevBlock s') => Pos.Types.Block.Class.HasPrevBlock (Data.Either.Either s s')


-- | Compile-time configuration support.
module Pos.CompileConfig

-- | Compile time configuration. See example in <i>constants.yaml</i> file.
data CompileConfig
CompileConfig :: !Int -> !Int -> !Int -> !Byte -> !Byte -> !Double -> !Double -> !Double -> !Double -> !Word -> !Double -> !Int -> !Int -> !Word -> ![String] -> !Int -> !Word -> !Int -> !Int -> !Word64 -> !Word64 -> !Int -> !Int -> !Word -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> CompileConfig

-- | Security parameter from paper
[ccK] :: CompileConfig -> !Int

-- | Number of pre-generated keys
[ccGenesisN] :: CompileConfig -> !Int

-- | Length of slot in seconds
[ccGenesisSlotDurationSec] :: CompileConfig -> !Int

-- | Maximum block size in bytes
[ccGenesisMaxBlockSize] :: CompileConfig -> !Byte

-- | Maximum tx size in bytes
[ccGenesisMaxTxSize] :: CompileConfig -> !Byte

-- | Eligibility threshold for MPC
[ccGenesisMpcThd] :: CompileConfig -> !Double

-- | Threshold for heavyweight delegation
[ccGenesisHeavyDelThd] :: CompileConfig -> !Double

-- | Portion of total stake necessary to vote for or against update.
[ccGenesisUpdateVoteThd] :: CompileConfig -> !Double

-- | Portion of total stake such that block containing UpdateProposal must
--   contain positive votes for this proposal from stakeholders owning at
--   least this amount of stake.
[ccGenesisUpdateProposalThd] :: CompileConfig -> !Double

-- | Number of slots after which update is implicitly approved unless it
--   has more negative votes than positive.
[ccGenesisUpdateImplicit] :: CompileConfig -> !Word

-- | Portion of total stake such that if total stake of issuers of blocks
--   with some block version is bigger than this portion, this block
--   version is adopted.
[ccGenesisUpdateSoftforkThd] :: CompileConfig -> !Double

-- | Estimated time for broadcasting messages
[ccNetworkDiameter] :: CompileConfig -> !Int

-- | Broadcasting threshold
[ccNeighboursSendThreshold] :: CompileConfig -> !Int

-- | Max number of transactions in Storage
[ccMaxLocalTxs] :: CompileConfig -> !Word

-- | List of default peers
[ccDefaultPeers] :: CompileConfig -> ![String]

-- | Number of slots to broadcast system time
[ccSysTimeBroadcastSlots] :: CompileConfig -> !Int

-- | Length of interval for sending MPC message
[ccMpcSendInterval] :: CompileConfig -> !Word

-- | Threshold of slots for malicious activity detection
[ccMdNoBlocksSlotThreshold] :: CompileConfig -> !Int

-- | Threshold of epochs for malicious activity detection
[ccMdNoCommitmentsEpochThreshold] :: CompileConfig -> !Int

-- | VSS certificates max timeout to live (number of epochs)
[ccVssMaxTTL] :: CompileConfig -> !Word64

-- | VSS certificates min timeout to live (number of epochs)
[ccVssMinTTL] :: CompileConfig -> !Word64

-- | Magic constant for separating real/testnet
[ccProtocolMagic] :: CompileConfig -> !Int

-- | Timeout for holding light psks confirmations
[ccLightDlgConfirmationTimeout] :: CompileConfig -> !Int

-- | True if we should enable enhanced bessage broadcast
[ccEnhancedMessageBroadcast] :: CompileConfig -> !Word

-- | Numbers of headers put in message in recovery mode.
[ccRecoveryHeadersMessage] :: CompileConfig -> !Int

-- | Interval we ignore cached messages in components that support caching
[ccMessageCacheTimeout] :: CompileConfig -> !Int

-- | Interval for dumping Kademlia state in slots
[ccKademliaDumpInterval] :: CompileConfig -> !Int

-- | How often request to NTP server and response collection
[ccNtpResponseTimeout] :: CompileConfig -> !Int

-- | How often send request to NTP server
[ccNtpPollDelay] :: CompileConfig -> !Int

-- | Network connection timeout in milliseconds
[ccNetworkConnectionTimeout] :: CompileConfig -> !Int

-- | Block retrieval queue capacity
[ccBlockRetrievalQueueSize] :: CompileConfig -> !Int

-- | InvMsg propagation queue capacity
[ccPropagationQueueSize] :: CompileConfig -> !Int

-- | Network timeout on <tt>recv</tt> in milliseconds
[ccNetworkReceiveTimeout] :: CompileConfig -> !Int

-- | Start time of network (in <tt>Prodution</tt> running mode). If set to
--   zero, then running time is 2 minutes after build.
[ccProductionNetworkStartTime] :: CompileConfig -> !Int

-- | Used in code compile-time configuration from <i>constants-*.yaml</i>
--   file.
compileConfig :: CompileConfig


-- | Constants used by algorithm. See paper for more details. Some
--   constants are parsed at compile-time (see <a>Type</a>). Others are
--   derived from those.
module Pos.Constants

-- | Security parameter which is maximum number of blocks which can be
--   rolled back.
blkSecurityParam :: Integral a => a

-- | Security parameter expressed in number of slots. It uses chain quality
--   property. It's basically 'blkSecurityParam / chain_quality'.
slotSecurityParam :: Integral a => a

-- | Number of slots inside one epoch.
epochSlots :: Integral a => a

-- | Estimated time needed to broadcast message from one node to all other
--   nodes. Also see <a>ccNetworkDiameter</a>.
networkDiameter :: Microsecond

-- | Length of shared seed.
sharedSeedLength :: Integral a => a

-- | Length of interval during which node should send her MPC message.
--   Relevant only for one SSC implementation. Also see
--   <a>ccMpcSendInterval</a>.
mpcSendInterval :: Microsecond

-- | <tt>True</tt> if current mode is <tt>Development</tt>.
isDevelopment :: Bool

-- | System start time embeded into binary.
staticSysStart :: Maybe Timestamp

-- | See <a>ccGenesisN</a>.
genesisN :: Integral i => i

-- | Length of slot.
genesisSlotDuration :: Millisecond

-- | Maximum size of a block (in bytes)
genesisMaxBlockSize :: Byte

-- | See <a>ccGenesisMaxTxSize</a>.
genesisMaxTxSize :: Byte

-- | See <a>ccGenesisMpcThd</a>.
genesisMpcThd :: CoinPortion

-- | See <a>ccGenesisHeavyDelThd</a>.
genesisHeavyDelThd :: CoinPortion

-- | See <a>ccGenesisUpdateVoteThd</a>.
genesisUpdateVoteThd :: CoinPortion

-- | See <a>ccGenesisUpdateProposalThd</a>.
genesisUpdateProposalThd :: CoinPortion

-- | See <a>ccGenesisUpdateImplicit</a>.
genesisUpdateImplicit :: Integral i => i

-- | See <a>ccGenesisUpdateSoftforkThd</a>.
genesisUpdateSoftforkThd :: CoinPortion

-- | Maximum amount of transactions we have in storage (i.e. we can accept
--   without putting them in block). There're next kind of storages in our
--   implementation:
--   
--   <ul>
--   <li>temporary storage of transactions</li>
--   <li>utxo map that corresponds to it</li>
--   <li>utxo of blocks in history</li>
--   </ul>
--   
--   This constant is size of first set. Also see <a>ccMaxLocalTxs</a>.
maxLocalTxs :: Integral i => i

-- | See <a>ccNeighboursSendThreshold</a>.
neighborsSendThreshold :: Integral a => a
networkConnectionTimeout :: Microsecond
networkReceiveTimeout :: Microsecond
blockRetrievalQueueSize :: Integral a => a
propagationQueueSize :: Integral a => a

-- | See <a>ccDefaultPeers</a>.
defaultPeers :: [DHTNode]

-- | <i>Time-lord</i> node announces system start time by broadcast. She
--   does it during first <a>ccSysTimeBroadcastSlots</a> slots.
sysTimeBroadcastSlots :: Integral i => i

-- | Max VSS certificate TTL (Ssc.GodTossing part)
vssMaxTTL :: Integral i => i

-- | Min VSS certificate TTL (Ssc.GodTossing part)
vssMinTTL :: Integral i => i

-- | Protocol magic constant. Is put to block serialized version to
--   distinguish testnet and realnet (for example, possible usages are
--   wider).
protocolMagic :: Int32

-- | Setting this to true enables enhanced message broadcast
enhancedMessageBroadcast :: Integral a => a

-- | Maximum amount of headers node can put into headers message while in
--   "after offline" or "recovery" mode. Should be more than
--   <a>blkSecurityParam</a>.
recoveryHeadersMessage :: (Integral a) => a

-- | Interval for dumping state of Kademlia in slots
kademliaDumpInterval :: (Integral a) => a

-- | Timeout for caching system. Components that use caching on messages
--   can use this timeout to invalidate caches.
messageCacheTimeout :: (Integral a) => a

-- | Amount of time we hold confirmations for light PSKs.
lightDlgConfirmationTimeout :: (Integral a) => a

-- | Number of slots used by malicious actions detection to check if we are
--   not receiving generated blocks.
mdNoBlocksSlotThreshold :: Integral i => i

-- | Number of epochs used by malicious actions detection to check if our
--   commitments are not included in blockchain.
mdNoCommitmentsEpochThreshold :: Integral i => i

-- | Last block version application is aware of.
lastKnownBlockVersion :: BlockVersion

-- | Version of application (code running)
curSoftwareVersion :: SoftwareVersion

-- | Name of our application.
ourAppName :: ApplicationName
appSystemTag :: SystemTag

-- | Inaccuracy in call threadDelay (actually it is error much less than 1
--   sec)
ntpMaxError :: Microsecond

-- | After making request to NTP servers, how long to wait for their
--   response
ntpResponseTimeout :: Microsecond

-- | How often send request to NTP server
ntpPollDelay :: Microsecond


-- | Transaction related functions.
module Pos.Types.Tx

-- | Verify that Tx itself is correct. Most likely you will also want to
--   verify that inputs are legal, signed properly and have enough coins;
--   <a>verifyTxAlone</a> doesn't do that.
verifyTxAlone :: Tx -> VerificationRes

-- | Global context data needed for script execution -- is same for the
--   whole transaction. VT stands for "Verify Tx". Currently empty.
data VTxGlobalContext
VTxGlobalContext :: VTxGlobalContext

-- | Local context data for scripts -- differs per input.
data VTxLocalContext
VTxLocalContext :: TxOutAux -> VTxLocalContext

-- | Transaction output
[vtlTxOut] :: VTxLocalContext -> TxOutAux

-- | CHECK: Verify Tx correctness using magic function which resolves input
--   into Address and Coin. It optionally does checks from
--   <a>verifyTxAlone</a> and also the following checks:
--   
--   <ul>
--   <li>sum of inputs &gt;= sum of outputs;</li>
--   <li>every input has a proper witness verifying that input;</li>
--   <li>script witnesses have matching script versions;</li>
--   <li>every input is a known unspent output.</li>
--   </ul>
--   
--   Note that <a>verifyTx</a> doesn't attempt to verify scripts with
--   versions higher than maximum script version we can handle. That's
--   because we want blocks with such transactions to be accepted (to avoid
--   hard forks). However, we won't include such transactions into blocks
--   when we're creating a block.
verifyTx :: (Monad m) => Bool -> Bool -> VTxGlobalContext -> (TxIn -> m (Maybe VTxLocalContext)) -> TxAux -> m (Either [Text] [TxOutAux])
verifyTxPure :: Bool -> Bool -> VTxGlobalContext -> (TxIn -> Maybe VTxLocalContext) -> TxAux -> Either [Text] [TxOutAux]

-- | Does topological sort on things that contain transactions – e.g. can
--   be used both for sorting <tt>[Tx]</tt> and <tt>[(Tx, TxWitness)]</tt>.
--   
--   (Backwards dfs from every node with reverse visiting order recording.
--   Returns nothing on loop encountered. Return order is head-first.)
topsortTxs :: forall a. (a -> WithHash Tx) -> [a] -> Maybe [a]
instance GHC.Show.Show Pos.Types.Tx.VTxLocalContext
instance GHC.Show.Show Pos.Types.Tx.VTxGlobalContext


-- | Utxo related operations.
module Pos.Types.Utxo
class Monad m => MonadUtxoRead m where utxoGet = lift . utxoGet
utxoGet :: MonadUtxoRead m => TxIn -> m (Maybe TxOutAux)
utxoGet :: (MonadUtxoRead m, MonadTrans t, MonadUtxoRead m', t m' ~ m) => TxIn -> m (Maybe TxOutAux)
class MonadUtxoRead m => MonadUtxo m where utxoPut a = lift . utxoPut a utxoDel = lift . utxoDel
utxoPut :: MonadUtxo m => TxIn -> TxOutAux -> m ()
utxoPut :: (MonadUtxo m, MonadTrans t, MonadUtxo m', t m' ~ m) => TxIn -> TxOutAux -> m ()
utxoDel :: MonadUtxo m => TxIn -> m ()
utxoDel :: (MonadUtxo m, MonadTrans t, MonadUtxo m', t m' ~ m) => TxIn -> m ()

-- | Remove unspent outputs used in given transaction, add new unspent
--   outputs.
applyTxToUtxo :: MonadUtxo m => WithHash Tx -> TxDistribution -> m ()

-- | Delete given TxIn from Utxo if any.
deleteTxIn :: TxIn -> Utxo -> Utxo

-- | Find transaction input in Utxo assuming it is valid.
findTxIn :: TxIn -> Utxo -> Maybe TxOutAux

-- | Verify single Tx using MonadUtxoRead as TxIn resolver.
verifyTxUtxo :: MonadUtxoRead m => Bool -> Bool -> TxAux -> m (Either [Text] [TxOutAux])

-- | Verify transactions correctness with respect to Utxo applying them
--   one-by-one. Note: transactions must be topsorted to pass check.
--   Warning: this function may apply some transactions and fail
--   eventually. Use it only on temporary data.
verifyAndApplyTxs :: forall m. MonadUtxo m => Bool -> Bool -> [(WithHash Tx, TxWitness, TxDistribution)] -> m (Either [Text] TxUndo)
applyTxToUtxo' :: MonadUtxo m => (TxId, TxAux) -> m ()

-- | A predicate for <a>TxOut</a> which selects outputs for given address
belongsTo :: TxOutAux -> Address -> Bool

-- | Select only TxOuts for given addresses
filterUtxoByAddr :: Address -> Utxo -> Utxo
utxoToStakes :: Utxo -> HashMap StakeholderId Coin
newtype UtxoReaderT m a
UtxoReaderT :: ReaderT Utxo m a -> UtxoReaderT m a
[getUtxoReaderT] :: UtxoReaderT m a -> ReaderT Utxo m a
runUtxoReaderT :: UtxoReaderT m a -> Utxo -> m a
type UtxoReader = UtxoReaderT Identity
runUtxoReader :: UtxoReader a -> Utxo -> a
newtype UtxoStateT m a
UtxoStateT :: StateT Utxo m a -> UtxoStateT m a
[getUtxoStateT] :: UtxoStateT m a -> StateT Utxo m a
runUtxoStateT :: UtxoStateT m a -> Utxo -> m (a, Utxo)
evalUtxoStateT :: Monad m => UtxoStateT m a -> Utxo -> m a
execUtxoStateT :: Monad m => UtxoStateT m a -> Utxo -> m Utxo
type UtxoState = UtxoStateT Identity
runUtxoState :: UtxoState a -> Utxo -> (a, Utxo)
evalUtxoState :: UtxoState a -> Utxo -> a
execUtxoState :: UtxoState a -> Utxo -> Utxo

-- | Pure version of applyTxToUtxo.
applyTxToUtxoPure :: WithHash Tx -> TxDistribution -> Utxo -> Utxo

-- | Pure version of applyTxToUtxo'.
applyTxToUtxoPure' :: (TxId, TxAux) -> Utxo -> Utxo

-- | Pure version of verifyTxUtxo.
verifyTxUtxoPure :: Bool -> Bool -> Utxo -> TxAux -> VerificationRes

module Pos.DHT.Real.Real

-- | Run KademliaDHT
runKademliaDHT :: (MonadMockable m, Eq (Promise m (Maybe ())), MonadIO m, WithLogger m) => KademliaDHTInstance -> KademliaDHT m a -> m a

-- | Start <a>KademliaDHTInstance</a> with
--   <a>KademliaDHTInstanceConfig</a>.
startDHTInstance :: (MonadIO m, Mockable Catch m, Mockable Throw m, WithLogger m, Bi DHTData, Bi DHTKey) => KademliaDHTInstanceConfig -> m KademliaDHTInstance

-- | Stop chosen <a>KademliaDHTInstance</a>.
stopDHTInstance :: MonadIO m => KademliaDHTInstance -> m ()
instance (Control.Monad.IO.Class.MonadIO m, Mockable.Class.Mockable Mockable.Concurrent.Async m, Mockable.Class.Mockable Mockable.Exception.Catch m, Mockable.Class.Mockable Mockable.Exception.Throw m, GHC.Classes.Eq (Mockable.Concurrent.Promise m (GHC.Base.Maybe ())), System.Wlog.CanLog.WithLogger m, Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTData, Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTKey) => Pos.DHT.Model.Class.MonadDHT (Pos.DHT.Real.Types.KademliaDHT m)


-- | Implementation of peer discovery using using Kademlia Distributed Hash
--   Table. For more details regarding DHT see this package on hackage:
--   <a>https://hackage.haskell.org/package/kademlia</a>
module Pos.DHT.Real


-- | <a>Arbitrary</a> instances for core types for using in tests and
--   benchmarks
module Pos.Types.Arbitrary

-- | Ill-formed <a>Tx</a> with bad signatures.
newtype BadSigsTx
BadSigsTx :: [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)] -> BadSigsTx
[getBadSigsTx] :: BadSigsTx -> [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)]

-- | Well-formed transaction <a>Tx</a>.
newtype GoodTx
GoodTx :: [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)] -> GoodTx
[getGoodTx] :: GoodTx -> [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)]
newtype SmallBadSigsTx
SmallBadSigsTx :: BadSigsTx -> SmallBadSigsTx
newtype SmallHashMap
SmallHashMap :: (HashMap PublicKey (HashMap PublicKey (AsBinary Share))) -> SmallHashMap
newtype SmallGoodTx
SmallGoodTx :: GoodTx -> SmallGoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679161769 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.FixedSizeInt a_6989586621679161769)
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679162221 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.SignedVarInt a_6989586621679162221)
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679162222 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.UnsignedVarInt a_6989586621679162222)
instance GHC.Show.Show Pos.Types.Arbitrary.SmallHashMap
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.Timestamp
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.SoftwareVersion
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Units.Millisecond
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Units.Microsecond
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallHashMap
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.BlockVersion
instance GHC.Show.Show Pos.Types.Arbitrary.SmallBadSigsTx
instance GHC.Show.Show Pos.Types.Arbitrary.BadSigsTx
instance GHC.Show.Show Pos.Types.Arbitrary.SmallGoodTx
instance GHC.Show.Show Pos.Types.Arbitrary.GoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.GoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallGoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.BadSigsTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallBadSigsTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.SharedSeed
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.ApplicationName
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxDistribution
instance System.Random.Random Pos.Types.Core.EpochIndex
instance System.Random.Random Pos.Types.Core.LocalSlotIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxOut
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.Coin
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.CoinPortion
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.EpochIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.LocalSlotIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.SlotId
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.EpochOrSlot
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxInWitness
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.ChainDifficulty
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Script.Type.Script
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.Address


-- | Functions related to blocks and headers.
module Pos.Types.Block.Functions

-- | Difficulty of the Block, which is determined from header.
blockDifficulty :: Block ssc -> ChainDifficulty

-- | Difficulty of the BlockHeader. 0 for genesis block, 1 for main block.
headerDifficulty :: BlockHeader ssc -> ChainDifficulty

-- | Smart constructor for <a>GenericBlock</a>. Uses
--   <tt>mkGenericBlockHeader</tt>.
mkGenericBlock :: forall b. (HasHeaderHash (BBlockHeader b), Blockchain b, BHeaderHash b ~ HeaderHash) => Maybe (BBlockHeader b) -> Body b -> (BHeaderHash b -> BodyProof b -> ConsensusData b) -> ExtraHeaderData b -> ExtraBodyData b -> GenericBlock b

-- | Smart constructor for <a>GenericBlockHeader</a>.
mkGenericHeader :: forall b. (HasHeaderHash (BBlockHeader b), Blockchain b, BHeaderHash b ~ HeaderHash) => Maybe (BBlockHeader b) -> Body b -> (BHeaderHash b -> BodyProof b -> ConsensusData b) -> ExtraHeaderData b -> GenericBlockHeader b

-- | Smart constructor for <a>MainBlock</a>. Uses <a>mkMainHeader</a>.
mkMainBlock :: (BiSsc ssc, SscHelpersClass ssc, MonadFail m) => Maybe (BlockHeader ssc) -> SlotId -> SecretKey -> Maybe ProxySKEither -> Body (MainBlockchain ssc) -> MainExtraHeaderData -> MainExtraBodyData -> m (MainBlock ssc)
recreateMainBlock :: (BiSsc ssc, SscHelpersClass ssc, MonadFail m) => MainBlockHeader ssc -> Body (MainBlockchain ssc) -> MainExtraBodyData -> m (MainBlock ssc)

-- | Smart constructor for <a>Body</a> of <a>MainBlockchain</a>.
mkMainBody :: [(Tx, TxWitness, TxDistribution)] -> SscPayload ssc -> [ProxySKHeavy] -> UpdatePayload -> Body (MainBlockchain ssc)

-- | Smart constructor for <a>MainBlockHeader</a>.
mkMainHeader :: (BiSsc ssc, SscHelpersClass ssc) => Maybe (BlockHeader ssc) -> SlotId -> SecretKey -> Maybe ProxySKEither -> Body (MainBlockchain ssc) -> MainExtraHeaderData -> MainBlockHeader ssc

-- | Smart constructor for <a>GenesisBlockHeader</a>. Uses
--   <a>mkGenericHeader</a>.
mkGenesisHeader :: BiSsc ssc => Maybe (BlockHeader ssc) -> EpochIndex -> Body (GenesisBlockchain ssc) -> GenesisBlockHeader ssc

-- | Smart constructor for <a>GenesisBlock</a>. Uses
--   <a>mkGenesisHeader</a>.
mkGenesisBlock :: BiSsc ssc => Maybe (BlockHeader ssc) -> EpochIndex -> SlotLeaders -> GenesisBlock ssc

-- | Predefined <a>Hash</a> of <a>GenesisBlock</a>.
genesisHash :: Hash a

-- | Parameters of Block static verification. Note: to check that block
--   references previous block and/or is referenced by next block, use
--   header verification (via vbpVerifyHeader).
data VerifyBlockParams ssc
VerifyBlockParams :: !(Maybe (VerifyHeaderParams ssc)) -> !Bool -> !Bool -> !Bool -> !Bool -> !(Maybe BlockVersion) -> VerifyBlockParams ssc

-- | Verifies header accordingly to params (<a>verifyHeader</a>)
[vbpVerifyHeader] :: VerifyBlockParams ssc -> !(Maybe (VerifyHeaderParams ssc))

-- | Checks <tt>verifyGenesisBlock</tt> property.
[vbpVerifyGeneric] :: VerifyBlockParams ssc -> !Bool

-- | Checks that each transaction passes <a>verifyTxAlone</a> check.
[vbpVerifyTxs] :: VerifyBlockParams ssc -> !Bool

-- | Verifies ssc payload with <a>sscVerifyPayload</a>.
[vbpVerifySsc] :: VerifyBlockParams ssc -> !Bool

-- | Check that's number of sks is limited (1000 for now).
[vbpVerifyProxySKs] :: VerifyBlockParams ssc -> !Bool

-- | Verify that there are no unknown script, address or witness versions
--   anywhere in the block. The check is only done if
--   <a>vbpVerifyVersions</a> is <a>Just</a> and the current adopted
--   BlockVersion (passed in the <a>Just</a>) is higher (or equal) than the
--   version of the block we're checking, because in this case there really
--   shouldn't be anything unparseable in the block.
[vbpVerifyVersions] :: VerifyBlockParams ssc -> !(Maybe BlockVersion)

-- | Extra data which may be used by verifyHeader function to do more
--   checks.
data VerifyHeaderParams ssc
VerifyHeaderParams :: !Bool -> !(Maybe (BlockHeader ssc)) -> !(Maybe (BlockHeader ssc)) -> !(Maybe SlotId) -> !(Maybe SlotLeaders) -> VerifyHeaderParams ssc
[vhpVerifyConsensus] :: VerifyHeaderParams ssc -> !Bool

-- | Nothing means that block is unknown, not genesis.
[vhpPrevHeader] :: VerifyHeaderParams ssc -> !(Maybe (BlockHeader ssc))
[vhpNextHeader] :: VerifyHeaderParams ssc -> !(Maybe (BlockHeader ssc))
[vhpCurrentSlot] :: VerifyHeaderParams ssc -> !(Maybe SlotId)
[vhpLeaders] :: VerifyHeaderParams ssc -> !(Maybe SlotLeaders)

-- | Check predicates defined by VerifyBlockParams. #verifyHeader
--   #verifyGenericBlock
verifyBlock :: (SscHelpersClass ssc, BiSsc ssc) => VerifyBlockParams ssc -> Block ssc -> VerificationRes

-- | Verify a sequence of blocks.
--   
--   foldl' is used here which eliminates laziness of triple. It doesn't
--   affect laziness of <a>VerificationRes</a> which is good because
--   laziness for this data type is crucial.
verifyBlocks :: forall ssc f t. (SscHelpersClass ssc, BiSsc ssc, t ~ OldestFirst f (Block ssc), NontrivialContainer t) => Maybe SlotId -> Maybe SlotLeaders -> Maybe BlockVersion -> OldestFirst f (Block ssc) -> VerificationRes

-- | Perform cheap checks of GenericBlock, which can be done using only
--   block itself. Checks which can be done using only header are ignored
--   here. It is assumed that they will be done separately.
verifyGenericBlock :: forall b. Blockchain b => GenericBlock b -> VerificationRes

-- | Check some predicates (determined by VerifyHeaderParams) about
--   BlockHeader. #verifyConsensusLocal
verifyHeader :: forall ssc. BiSsc ssc => VerifyHeaderParams ssc -> BlockHeader ssc -> VerificationRes

-- | Verifies a set of block headers.
verifyHeaders :: BiSsc ssc => Bool -> NewestFirst [] (BlockHeader ssc) -> VerificationRes

-- | Compute size of <a>MainBlock</a> in bytes.
blockSize :: SscHelpersClass ssc => MainBlock ssc -> Byte
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Types.Block.Functions.VerifyHeaderParams ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Types.Block.Functions.VerifyHeaderParams ssc)
instance Data.Default.Class.Default (Pos.Types.Block.Functions.VerifyHeaderParams ssc)
instance Data.Default.Class.Default (Pos.Types.Block.Functions.VerifyBlockParams ssc)


-- | Functions related to blocks and headers.
module Pos.Types.Block


-- | Slotting types.
module Pos.Types.Slotting

-- | Flatten <a>SlotId</a> (which is basically pair of integers) into a
--   single number.
flattenSlotId :: SlotId -> FlatSlotId

-- | Flattens <a>EpochIndex</a> into a single number.
flattenEpochIndex :: EpochIndex -> FlatSlotId

-- | Transforms some <a>HasEpochOrSlot</a> to a single number.
flattenEpochOrSlot :: (HasEpochOrSlot a) => a -> FlatSlotId

-- | Construct <a>SlotId</a> from a flattened variant.
unflattenSlotId :: FlatSlotId -> SlotId

-- | Slot such that at the beginning of epoch blocks with SlotId ≤- this
--   slot are stable.
crucialSlot :: EpochIndex -> SlotId
instance GHC.Enum.Enum Pos.Types.Core.SlotId
instance GHC.Enum.Enum Pos.Types.Core.EpochOrSlot


-- | Re-export of Pos.Types.* + binary instances
module Pos.Types

-- | Coin is the least possible unit of currency.
data Coin

-- | CoinPortion is some portion of Coin, it must be in [0 ..
--   coinPortionDenominator]. Main usage of it is multiplication with Coin.
--   Usually it's needed to determine some threshold expressed as portion
--   of total stake.
data CoinPortion

-- | Coin formatter which restricts type.
coinF :: Format r (Coin -> r)

-- | Unwraps <a>Coin</a>. It's called “unsafe” so that people wouldn't use
--   it willy-nilly if they want to sum coins or something. It's actually
--   safe.
unsafeGetCoin :: Coin -> Word64
getCoinPortion :: CoinPortion -> Word64

-- | Make Coin from Word64.
mkCoin :: Word64 -> Coin

-- | Denominator used by <a>CoinPortion</a>.
coinPortionDenominator :: Word64

-- | Make <a>CoinPortion</a> from <a>Word64</a> checking whether it is not
--   greater than <a>coinPortionDenominator</a>.
mkCoinPortion :: MonadFail m => Word64 -> m CoinPortion

-- | Make CoinPortion from Double. Caller must ensure that value is in [0
--   .. 1]. Internally <a>CoinPortion</a> stores <a>Word64</a> which is
--   divided by <a>coinPortionDenominator</a> to get actual value. So some
--   rounding may take place.
unsafeCoinPortionFromDouble :: Double -> CoinPortion

-- | Index of epoch.
newtype EpochIndex
EpochIndex :: Word64 -> EpochIndex
[getEpochIndex] :: EpochIndex -> Word64

-- | Class for something that has <a>EpochIndex</a>.
class HasEpochIndex a
epochIndexL :: HasEpochIndex a => Lens' a EpochIndex

-- | FlatSlotId is a flat version of SlotId
type FlatSlotId = Word64

-- | Index of slot inside a concrete epoch.
newtype LocalSlotIndex
LocalSlotIndex :: Word16 -> LocalSlotIndex
[getSlotIndex] :: LocalSlotIndex -> Word16

-- | Slot is identified by index of epoch and local index of slot in this
--   epoch. This is a global index
data SlotId
SlotId :: !EpochIndex -> !LocalSlotIndex -> SlotId
[siEpoch] :: SlotId -> !EpochIndex
[siSlot] :: SlotId -> !LocalSlotIndex

-- | Represents SlotId or EpochIndex. Useful because genesis blocks have
--   only EpochIndex, while main blocks have SlotId.
newtype EpochOrSlot
EpochOrSlot :: Either EpochIndex SlotId -> EpochOrSlot
[unEpochOrSlot] :: EpochOrSlot -> Either EpochIndex SlotId
class HasEpochOrSlot a where getEpochOrSlot = EpochOrSlot . _getEpochOrSlot epochOrSlotG = to getEpochOrSlot
_getEpochOrSlot :: HasEpochOrSlot a => a -> Either EpochIndex SlotId
getEpochOrSlot :: HasEpochOrSlot a => a -> EpochOrSlot
epochOrSlotG :: HasEpochOrSlot a => Getter a EpochOrSlot

-- | Timestamp is a number which represents some point in time. It is used
--   in MonadSlots and its meaning is up to implementation of this type
--   class. The only necessary knowledge is that difference between
--   timestamps is microsecond. Hence underlying type is Microsecond.
newtype Timestamp
Timestamp :: Microsecond -> Timestamp
[getTimestamp] :: Timestamp -> Microsecond

-- | Specialized formatter for <a>SlotId</a>.
slotIdF :: Format r (SlotId -> r)

-- | Apply one of the function depending on content of EpochOrSlot.
epochOrSlot :: (EpochIndex -> a) -> (SlotId -> a) -> EpochOrSlot -> a

-- | Address is where you can send coins.
data Address
PubKeyAddress :: !(AddressHash PublicKey) -> !(Attributes AddrPkAttrs) -> Address
[addrKeyHash] :: Address -> !(AddressHash PublicKey)
[addrPkAttributes] :: Address -> !(Attributes AddrPkAttrs)
ScriptAddress :: !(AddressHash Script) -> Address
[addrScriptHash] :: Address -> !(AddressHash Script)
UnknownAddressType :: !Word8 -> !ByteString -> Address
newtype AddrPkAttrs
AddrPkAttrs :: Maybe [Word32] -> AddrPkAttrs
[addrPkDerivationPath] :: AddrPkAttrs -> Maybe [Word32]
type AddressHash = AbstractHash Blake2s_224

-- | Stakeholder identifier (stakeholders are identified by their public
--   keys)
type StakeholderId = AddressHash PublicKey

-- | Chain difficulty represents necessary effort to generate a chain. In
--   the simplest case it can be number of blocks in chain.
newtype ChainDifficulty
ChainDifficulty :: Word64 -> ChainDifficulty
[getChainDifficulty] :: ChainDifficulty -> Word64

-- | Type class for something that has <a>ChainDifficulty</a>.
class HasDifficulty a
difficultyL :: HasDifficulty a => Lens' a ChainDifficulty
newtype ApplicationName
ApplicationName :: Text -> ApplicationName
[getApplicationName] :: ApplicationName -> Text

-- | Communication protocol version.
data BlockVersion
BlockVersion :: !Word16 -> !Word16 -> !Word8 -> BlockVersion
[bvMajor] :: BlockVersion -> !Word16
[bvMinor] :: BlockVersion -> !Word16
[bvAlt] :: BlockVersion -> !Word8

-- | Numeric software version associated with ApplicationName.
type NumSoftwareVersion = Word32

-- | Software version.
data SoftwareVersion
SoftwareVersion :: !ApplicationName -> !NumSoftwareVersion -> SoftwareVersion
[svAppName] :: SoftwareVersion -> !ApplicationName
[svNumber] :: SoftwareVersion -> !NumSoftwareVersion
data BlockHeaderStub

-- | <a>Hash</a> of block header. This should be <tt>Hash (BlockHeader
--   ssc)</tt> but we don't want to have <tt>ssc</tt> in <a>HeaderHash</a>
--   type.
type HeaderHash = Hash BlockHeaderStub

-- | Class for something that has <a>HeaderHash</a>.
class HasHeaderHash a where headerHashG = to headerHash
headerHash :: HasHeaderHash a => a -> HeaderHash
headerHashG :: HasHeaderHash a => Getter a HeaderHash

-- | Specialized formatter for <a>HeaderHash</a>.
headerHashF :: Format r (HeaderHash -> r)


-- | Everything related to <i>follow-the-satoshi</i> procedure.
module Pos.Lrc.FollowTheSatoshi

-- | Choose several random stakeholders (specifically, their amount is
--   currently hardcoded in <a>epochSlots</a>).
--   
--   The probability that a stakeholder will be chosen is proportional to
--   the number of coins this stakeholder holds. The same stakeholder can
--   be picked more than once.
--   
--   How the algorithm works: we sort all unspent outputs in a
--   deterministic way (lexicographically) and have an ordered sequence of
--   pairs <tt>(StakeholderId, Coin)</tt>. Then we choose several random
--   <tt>i</tt>s between 1 and amount of satoshi in the system; to find
--   owner of <tt>i</tt>th coin we find the lowest x such that sum of all
--   coins in this list up to <tt>i</tt>th is not less than <tt>i</tt> (and
--   then <tt>x</tt>th address is the owner).
--   
--   With P2SH addresses, we don't know who is going to end up with funds
--   sent to them. Therefore, P2SH addresses can contain
--   <tt>addrDestination</tt> which specifies which addresses should count
--   as “owning” funds for the purposes of follow-the-satoshi.
followTheSatoshi :: SharedSeed -> Utxo -> NonEmpty StakeholderId

-- | A version of <a>followTheSatoshi</a> that uses an iterator over
--   <tt>TxOut</tt>s instead of <a>Utxo</a>.
followTheSatoshiM :: forall m. MonadIterator (StakeholderId, Coin) m => SharedSeed -> Coin -> m (NonEmpty StakeholderId)


-- | Blockchain genesis. Not to be confused with genesis block in epoch.
--   Blockchain genesis means genesis values which are hardcoded in advance
--   (before system starts doing anything). Genesis block in epoch exists
--   in every epoch and it's not known in advance.
module Pos.Genesis

-- | Stake distribution in genesis block. FlatStakes is a flat
--   distribution, i. e. each node has the same amount of coins.
--   BitcoinStakes is a Bitcoin mining pool-style ditribution.
data StakeDistribution
FlatStakes :: !Word -> !Coin -> StakeDistribution
BitcoinStakes :: !Word -> !Coin -> StakeDistribution
TestnetStakes :: !Coin -> !Word -> !Word -> StakeDistribution
[sdTotalStake] :: StakeDistribution -> !Coin
[sdRichmen] :: StakeDistribution -> !Word
[sdPoor] :: StakeDistribution -> !Word
ExponentialStakes :: StakeDistribution
ExplicitStakes :: !(HashMap Address Coin) -> StakeDistribution

-- | Hardcoded genesis data
data GenesisData
GenesisData :: [Address] -> StakeDistribution -> VssCertificatesMap -> GenesisData
[gdAddresses] :: GenesisData -> [Address]
[gdDistribution] :: GenesisData -> StakeDistribution
[gdVssCertificates] :: GenesisData -> VssCertificatesMap

-- | Fetch pre-generated genesis data from <i>genesis.bin</i> in compile
--   time Doesn't use TH with lift because it's difficult to provide
--   <tt>Lift</tt> instance to <a>GenesisData</a>
compileGenData :: GenesisData

-- | List of <tt>Address'</tt>es in genesis. See <a>genesisPublicKeys</a>.
genesisAddresses :: [Address]

-- | List of pairs from <a>SecretKey</a> with corresponding
--   <a>PublicKey</a>.
genesisKeyPairs :: [(PublicKey, SecretKey)]

-- | List of <tt>PublicKey'</tt>s in genesis.
genesisPublicKeys :: [PublicKey]

-- | List of <tt>SecrekKey'</tt>s in genesis.
genesisSecretKeys :: [SecretKey]
genesisStakeDistribution :: StakeDistribution

-- | Genesis <a>Utxo</a>.
genesisUtxo :: StakeDistribution -> Utxo
genesisDelegation :: HashMap StakeholderId [StakeholderId]

-- | Leaders of genesis. See <a>followTheSatoshi</a>.
genesisLeaders :: Utxo -> SlotLeaders

-- | BlockVersion used at the very beginning.
genesisBlockVersion :: BlockVersion

-- | <a>BlockVersionData</a> for genesis <a>BlockVersion</a>.
genesisBlockVersionData :: BlockVersionData

-- | Software Versions
genesisSoftwareVersions :: [SoftwareVersion]

-- | ScriptVersion used at the very beginning
genesisScriptVersion :: ScriptVersion

-- | Initial slot duration
genesisSlotDuration :: Millisecond

-- | Initial block size limit
genesisMaxBlockSize :: Byte
instance Data.Default.Class.Default Pos.Genesis.Types.StakeDistribution


-- | Utility functions for graceful shutdown of workers
module Pos.Util.Shutdown
ifNotShutdown :: (MonadIO m, WithNodeContext ssc m, WithLogger m) => m () -> m ()
triggerShutdown :: (MonadIO m, WithLogger m, WithNodeContext ssc m) => m ()
waitForWorkers :: (MonadIO m, WithNodeContext ssc m) => Int -> m ()


-- | GState DB stores whole global state, i. e. result of application of
--   all blocks up to <i>tip</i>.
module Pos.DB.GState

-- | Get total amount of stake to be used for follow-the-satoshi. It's
--   different from total amount of coins in the system.
getTotalFtsStake :: MonadDB ssc m => m Coin

-- | Get stake owne by given stakeholder (according to rules used for FTS).
getFtsStake :: MonadDB ssc m => StakeholderId -> m (Maybe Coin)
getFtsStakeFromDB :: (MonadIO m, MonadThrow m) => StakeholderId -> DB ssc -> m (Maybe Coin)
data BalancesOp
PutFtsSum :: !Coin -> BalancesOp
PutFtsStake :: !StakeholderId -> !Coin -> BalancesOp
prepareGStateBalances :: forall ssc m. MonadDB ssc m => Utxo -> m ()
data BalIter
runBalanceIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc BalIter a -> m a
runBalanceMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc BalIter v a -> (IterType BalIter -> v) -> m a
sanityCheckBalances :: (MonadMask m, MonadDB ssc m, WithLogger m) => m ()

-- | Tries to retrieve next block using current one (given a block/header).
resolveForwardLink :: (HasHeaderHash a, MonadDB ssc m) => a -> m (Maybe HeaderHash)

-- | Check if given hash representing block is in main chain.
isBlockInMainChain :: (HasHeaderHash a, MonadDB ssc m) => a -> m Bool
data BlockExtraOp

-- | Adds or overwrites forward link
AddForwardLink :: HeaderHash -> HeaderHash -> BlockExtraOp

-- | Removes forward link
RemoveForwardLink :: HeaderHash -> BlockExtraOp

-- | Enables or disables "in main chain" status of the block
SetInMainChain :: Bool -> HeaderHash -> BlockExtraOp

-- | Returns headers loaded up.
loadHeadersUpWhile :: (SscHelpersClass ssc, MonadDB ssc m, HasHeaderHash a) => a -> (BlockHeader ssc -> Int -> Bool) -> m (OldestFirst [] (BlockHeader ssc))

-- | Returns blocks loaded up.
loadBlocksUpWhile :: (SscHelpersClass ssc, MonadDB ssc m, HasHeaderHash a) => a -> (Block ssc -> Int -> Bool) -> m (OldestFirst [] (Block ssc))
prepareGStateBlockExtra :: MonadDB ssc m => HeaderHash -> m ()

-- | Get current tip from GState DB.
getTip :: (MonadDB ssc m) => m HeaderHash

-- | Get the hash of the first genesis block from GState DB.
getBot :: (MonadDB ssc m) => m HeaderHash

-- | Put missing initial common data into GState DB.
prepareGStateCommon :: forall ssc m. MonadDB ssc m => HeaderHash -> m ()
getBi :: (MonadDB ssc m, Bi v) => ByteString -> m (Maybe v)
putBi :: (MonadDB ssc m, Bi v) => ByteString -> v -> m ()
delete :: (MonadDB ssc m) => ByteString -> m ()
writeBatchGState :: (RocksBatchOp a, MonadDB ssc m) => [a] -> m ()
data CommonOp
PutTip :: HeaderHash -> CommonOp

-- | Retrieves certificate by issuer address (hash of public key) if
--   present.
getPSKByIssuerAddressHash :: MonadDB ssc m => StakeholderId -> m (Maybe ProxySKHeavy)

-- | Retrieves certificate by issuer public key if present.
getPSKByIssuer :: MonadDB ssc m => PublicKey -> m (Maybe ProxySKHeavy)
isIssuerByAddressHash :: MonadDB ssc m => StakeholderId -> m Bool
data DelegationOp

-- | Adds PSK. Overwrites if present.
AddPSK :: !ProxySKHeavy -> DelegationOp

-- | Removes PSK by issuer PK.
DelPSK :: !PublicKey -> DelegationOp
runPskIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc PskIter a -> m a
runPskMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc PskIter v a -> (IterType PskIter -> v) -> m a

-- | Put missing initial data into GState DB.
prepareGStateDB :: forall ssc m. (WithNodeContext ssc m, MonadDB ssc m) => HeaderHash -> m ()

-- | Check that GState DB is consistent.
sanityCheckGStateDB :: forall ssc m. (MonadDB ssc m, MonadMask m, WithLogger m) => m ()
usingGStateSnapshot :: (MonadDB ssc m, MonadMask m) => m a -> m a

-- | Get last adopted block version.
getAdoptedBV :: MonadDB ssc m => m BlockVersion

-- | Get state of last adopted BlockVersion.
getAdoptedBVData :: MonadDB ssc m => m BlockVersionData

-- | Get last adopted BlockVersion and data associated with it.
getAdoptedBVFull :: MonadDB ssc m => m (BlockVersion, BlockVersionData)

-- | Get <a>BlockVersionState</a> associated with given BlockVersion.
getBVState :: MonadDB ssc m => BlockVersion -> m (Maybe BlockVersionState)

-- | Get state of UpdateProposal for given UpId
getProposalState :: MonadDB ssc m => UpId -> m (Maybe ProposalState)

-- | Get UpId of current proposal for given appName
getAppProposal :: MonadDB ssc m => ApplicationName -> m (Maybe UpId)

-- | Get state of Update Proposal for given AppName
getProposalStateByApp :: MonadDB ssc m => ApplicationName -> m (Maybe ProposalState)

-- | Get last confirmed SoftwareVersion of given application.
getConfirmedSV :: MonadDB ssc m => ApplicationName -> m (Maybe NumSoftwareVersion)

-- | Get maximum block size (in bytes).
getMaxBlockSize :: MonadDB ssc m => m Byte

-- | Get most recent <a>SlottingData</a>.
getSlottingData :: MonadDB ssc m => m SlottingData
data UpdateOp
PutProposal :: !ProposalState -> UpdateOp
DeleteProposal :: !UpId -> !ApplicationName -> UpdateOp
ConfirmVersion :: !SoftwareVersion -> UpdateOp
DelConfirmedVersion :: !ApplicationName -> UpdateOp
AddConfirmedProposal :: !ConfirmedProposalState -> UpdateOp
DelConfirmedProposal :: !SoftwareVersion -> UpdateOp
SetAdopted :: !BlockVersion -> BlockVersionData -> UpdateOp
SetBVState :: !BlockVersion -> !BlockVersionState -> UpdateOp
DelBV :: !BlockVersion -> UpdateOp
PutSlottingData :: !SlottingData -> UpdateOp
prepareGStateUS :: forall ssc m. MonadDB ssc m => Timestamp -> m ()
data PropIter
runProposalMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc PropIter v a -> (IterType PropIter -> v) -> m a
runProposalIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc PropIter a -> m a

-- | Get all proposals which were issued no later than given slot.
getOldProposals :: forall ssc m. MonadDB ssc m => SlotId -> m [UndecidedProposalState]

-- | Get all decided proposals which were accepted deeper than given
--   difficulty.
getDeepProposals :: forall ssc m. MonadDB ssc m => ChainDifficulty -> m [DecidedProposalState]
data ConfPropIter

-- | Get confirmed proposals which update our application and have version
--   bigger than argument (or all proposals if <a>Nothing</a> is passed).
--   For instance, current software version can be passed to this function
--   to get all proposals with bigger version.
getConfirmedProposals :: MonadDB ssc m => Maybe NumSoftwareVersion -> m [ConfirmedProposalState]
data BVIter

-- | Get all proposed <a>BlockVersion</a>s.
getProposedBVs :: MonadDB ssc m => m [BlockVersion]

-- | Get all confirmed <a>BlockVersion</a>s and their states.
getConfirmedBVStates :: MonadDB ssc m => m [(BlockVersion, BlockVersionState)]
getProposedBVStates :: MonadDB ssc m => m [BlockVersionState]
getTxOutFromDB :: (MonadIO m, MonadThrow m) => TxIn -> DB ssc -> m (Maybe TxOutAux)
getTxOut :: MonadDB ssc m => TxIn -> m (Maybe TxOutAux)
data UtxoOp
DelTxIn :: !TxIn -> UtxoOp
AddTxOut :: !TxIn -> !TxOutAux -> UtxoOp
AddGenTxOut :: !TxIn -> !TxOutAux -> UtxoOp
prepareGStateUtxo :: forall ssc m. MonadDB ssc m => Utxo -> m ()
data UtxoIter
runUtxoIterator :: forall i m ssc a. (MonadDB ssc m, DBIteratorClass i, IterKey i ~ TxIn, IterValue i ~ TxOutAux) => DBnIterator ssc i a -> m a
runUtxoMapIterator :: forall i v m ssc a. (MonadDB ssc m, DBIteratorClass i, IterKey i ~ TxIn, IterValue i ~ TxOutAux) => DBnMapIterator ssc i v a -> (IterType i -> v) -> m a
getFilteredUtxo :: MonadDB ssc m => Address -> m Utxo
getFilteredGenUtxo :: MonadDB ssc m => Address -> m Utxo
sanityCheckUtxo :: (MonadDB ssc m, WithLogger m) => Coin -> m ()


-- | Re-exports of Pos.DB functionality.
module Pos.DB

-- | Get block with given hash from Block DB.
getBlock :: (SscHelpersClass ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (Block ssc))

-- | Returns header of block that was requested from Block DB.
getBlockHeader :: (SscHelpersClass ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (BlockHeader ssc))

-- | Get StoredBlock by hash from Block DB.
getStoredBlock :: (SscHelpersClass ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (StoredBlock ssc))

-- | Get undo data for block with given hash from Block DB.
getUndo :: MonadDB ssc m => HeaderHash -> m (Maybe Undo)

-- | Retrieves block and undo together.
getBlockWithUndo :: (SscHelpersClass ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (Block ssc, Undo))
deleteBlock :: (MonadDB ssc m) => HeaderHash -> m ()

-- | Put given block, its metadata and Undo data into Block DB.
putBlock :: (SscHelpersClass ssc, MonadDB ssc m) => Undo -> Block ssc -> m ()
prepareBlockDB :: forall ssc m. (SscHelpersClass ssc, MonadDB ssc m) => GenesisBlock ssc -> m ()

-- | Load blunds starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadBlundsWhile :: (SscHelpersClass ssc, MonadDB ssc m) => (Block ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (Blund ssc))

-- | Load blunds which have depth less than given.
loadBlundsByDepth :: (SscHelpersClass ssc, MonadDB ssc m) => Word -> HeaderHash -> m (NewestFirst [] (Blund ssc))

-- | Load blocks starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadBlocksWhile :: (SscHelpersClass ssc, MonadDB ssc m) => (Block ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (Block ssc))

-- | Load headers starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadHeadersWhile :: (SscHelpersClass ssc, MonadDB ssc m) => (BlockHeader ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))

-- | Load headers which have depth less than given.
loadHeadersByDepth :: (SscHelpersClass ssc, MonadDB ssc m) => Word -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))

-- | Load headers which have depth less than given and match some
--   criterion.
loadHeadersByDepthWhile :: (SscHelpersClass ssc, MonadDB ssc m) => (BlockHeader ssc -> Bool) -> Word -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))
class (MonadIO m, MonadThrow m) => MonadDB ssc m | m -> ssc
getNodeDBs :: MonadDB ssc m => m (NodeDBs ssc)
usingReadOptions :: MonadDB ssc m => ReadOptions -> ASetter' (NodeDBs ssc) (DB ssc) -> m a -> m a
usingWriteOptions :: MonadDB ssc m => WriteOptions -> ASetter' (NodeDBs ssc) (DB ssc) -> m a -> m a
getBlockDB :: MonadDB ssc m => m (DB ssc)
getUtxoDB :: MonadDB ssc m => m (DB ssc)
getLrcDB :: MonadDB ssc m => m (DB ssc)
getMiscDB :: MonadDB ssc m => m (DB ssc)

-- | Open all DBs stored on disk.
openNodeDBs :: (MonadIO m) => Bool -> FilePath -> m (NodeDBs ssc)

-- | Initialize DBs if necessary.
initNodeDBs :: forall ssc m. (SscHelpersClass ssc, WithNodeContext ssc m, MonadDB ssc m) => m ()

-- | Get current tip from GState DB.
getTip :: (MonadDB ssc m) => m HeaderHash

-- | Get block corresponding to tip.
getTipBlock :: (SscHelpersClass ssc, MonadDB ssc m) => m (Block ssc)

-- | Get BlockHeader corresponding to tip.
getTipBlockHeader :: (SscHelpersClass ssc, MonadDB ssc m) => m (BlockHeader ssc)

-- | Load blunds from BlockDB starting from tip and while the
--   <tt>condition</tt> is true.
loadBlundsFromTipWhile :: (SscHelpersClass ssc, MonadDB ssc m) => (Block ssc -> Bool) -> m (NewestFirst [] (Blund ssc))

-- | Load blunds from BlockDB starting from tip which have depth less than
--   given.
loadBlundsFromTipByDepth :: (SscHelpersClass ssc, MonadDB ssc m) => Word -> m (NewestFirst [] (Blund ssc))
sanityCheckDB :: (MonadMask m, MonadDB ssc m, WithLogger m) => m ()
class DBIteratorClass i where type IterKey i :: * type IterValue i :: * where {
    type family IterKey i :: *;
    type family IterValue i :: *;
}
iterKeyPrefix :: DBIteratorClass i => Proxy i -> ByteString
type IterType i = (IterKey i, IterValue i)
newtype DBIterator i m a
DBIterator :: ReaderT Iterator m a -> DBIterator i m a
[getDBIterator] :: DBIterator i m a -> ReaderT Iterator m a

-- | Encapsulate `map f elements`, where <tt>elements</tt> - collection
--   elements of type <tt>a</tt>. Holds `DBIterator m a` and apply f for
--   every <a>nextItem</a> and <a>curItem</a> call. If f :: a -&gt; b then
--   we iterate by collection elements of type b.
newtype DBMapIterator i v m a
DBMapIterator :: ReaderT (IterType i -> v) (DBIterator i m) a -> DBMapIterator i v m a
[getDBMapIterator] :: DBMapIterator i v m a -> ReaderT (IterType i -> v) (DBIterator i m) a
type DBKeyIterator i = DBMapIterator i (IterKey i)
type DBValueIterator i = DBMapIterator i (IterValue i)
type DBnIterator ssc i = DBHolder ssc (DBIterator i IO)
type DBnMapIterator ssc i v = DBHolder ssc (DBMapIterator i v IO)
runDBnIterator :: forall i m ssc a. (MonadDB ssc m, DBIteratorClass i) => (NodeDBs ssc -> DB ssc) -> DBnIterator ssc i a -> m a
runDBnMapIterator :: forall i v m ssc a. (MonadDB ssc m, DBIteratorClass i) => (NodeDBs ssc -> DB ssc) -> DBnMapIterator ssc i v a -> (IterType i -> v) -> m a

-- | Run DBIterator by `DB ssc`.
runIterator :: forall i a m ssc. (MonadIO m, MonadMask m, DBIteratorClass i) => DBIterator i m a -> DB ssc -> m a

-- | Run DBMapIterator by `DB ssc`.
runMapIterator :: forall i v m ssc a. (MonadIO m, MonadMask m, DBIteratorClass i) => DBMapIterator i v m a -> (IterType i -> v) -> DB ssc -> m a
data DBError

-- | Structure of DB is malformed (e. g. data is inconsistent, something is
--   missing, etc.)
DBMalformed :: !Text -> DBError
openDB :: MonadIO m => FilePath -> m (DB ssc)
encodeWithKeyPrefix :: forall i. (DBIteratorClass i, Bi (IterKey i)) => IterKey i -> ByteString
rocksDelete :: (MonadIO m) => ByteString -> DB ssc -> m ()

-- | Read serialized value from RocksDB using given key.
rocksGetBi :: forall v m ssc. (Bi v, MonadIO m, MonadThrow m) => ByteString -> DB ssc -> m (Maybe v)

-- | Read ByteString from RocksDb using given key.
rocksGetBytes :: (MonadIO m) => ByteString -> DB ssc -> m (Maybe ByteString)

-- | Write serializable value to RocksDb for given key.
rocksPutBi :: (Bi v, MonadIO m) => ByteString -> v -> DB ssc -> m ()

-- | Write ByteString to RocksDB for given key.
rocksPutBytes :: (MonadIO m) => ByteString -> ByteString -> DB ssc -> m ()
rocksDecodeWP :: forall i m. (MonadThrow m, DBIteratorClass i, Bi (IterKey i)) => ByteString -> m (IterKey i)
rocksDecodeMaybe :: (Bi v) => ByteString -> Maybe v
rocksDecodeMaybeWP :: forall i. (DBIteratorClass i, Bi (IterKey i)) => ByteString -> Maybe (IterKey i)
rocksDecodeKeyValMaybe :: (Bi k, Bi v) => (ByteString, ByteString) -> Maybe (k, v)
class RocksBatchOp a
toBatchOp :: RocksBatchOp a => a -> [BatchOp]
data SomeBatchOp
SomeBatchOp :: a -> SomeBatchOp
data SomePrettyBatchOp
SomePrettyBatchOp :: a -> SomePrettyBatchOp

-- | Write Batch encapsulation
rocksWriteBatch :: (RocksBatchOp a, MonadIO m) => [a] -> DB ssc -> m ()
newtype DBHolder ssc m a
DBHolder :: ReaderT (NodeDBs ssc) m a -> DBHolder ssc m a
[getDBHolder] :: DBHolder ssc m a -> ReaderT (NodeDBs ssc) m a

-- | Execute <a>DBHolder</a> action with given <tt>NodeState</tt>.
runDBHolder :: NodeDBs ssc -> DBHolder ssc m a -> m a
prepareMiscDB :: forall ssc m. (MonadDB ssc m) => m ()

-- | Gets proxy secret keys stored by node
getProxySecretKeys :: MonadDB ssc m => m [ProxySKLight]

-- | Adds proxy secret key if not present. Nothing if present.
addProxySecretKey :: MonadDB ssc m => ProxySKLight -> m ()

-- | Removes proxy secret key if present by issuer pk.
removeProxySecretKey :: MonadDB ssc m => PublicKey -> m ()

-- | Given epochindex, throws away all outdated PSKs. Remark: it doesn't
--   remove keys that can be used in future.
dropOldProxySecretKeys :: MonadDB ssc m => EpochIndex -> m ()
getSecretStorage :: MonadDB SscGodTossing m => m (Maybe GtSecretStorage)
putSecretStorage :: MonadDB SscGodTossing m => GtSecretStorage -> m ()

-- | Puts or overwrites secret key of the node. Returns if it was
--   overwritten.
putSecretKeyHash :: MonadDB ssc m => Hash SecretKey -> m Bool

-- | Checks if given secret key hash matches the hash in the database. Puts
--   it into the database and return True if nothing was stored there.
checkSecretKeyHash :: MonadDB ssc m => Hash SecretKey -> m Bool
data DB ssc
DB :: !ReadOptions -> !WriteOptions -> !Options -> !DB -> DB ssc
[rocksReadOpts] :: DB ssc -> !ReadOptions
[rocksWriteOpts] :: DB ssc -> !WriteOptions
[rocksOptions] :: DB ssc -> !Options
[rocksDB] :: DB ssc -> !DB
data NodeDBs ssc
NodeDBs :: !(DB ssc) -> !(DB ssc) -> !(DB ssc) -> !(DB ssc) -> !RWLock -> NodeDBs ssc

-- | Blocks, block index, undo data.
[_blockDB] :: NodeDBs ssc -> !(DB ssc)

-- | Global state corresponding to some tip.
[_gStateDB] :: NodeDBs ssc -> !(DB ssc)

-- | Data computed by LRC.
[_lrcDB] :: NodeDBs ssc -> !(DB ssc)

-- | Everything small and insignificant
[_miscDB] :: NodeDBs ssc -> !(DB ssc)

-- | Lock on misc db
[_miscLock] :: NodeDBs ssc -> !RWLock
blockDB :: forall ssc_a7qTj. Lens' (NodeDBs ssc_a7qTj) (DB ssc_a7qTj)
gStateDB :: forall ssc_a7qTj. Lens' (NodeDBs ssc_a7qTj) (DB ssc_a7qTj)
lrcDB :: forall ssc_a7qTj. Lens' (NodeDBs ssc_a7qTj) (DB ssc_a7qTj)
miscDB :: forall ssc_a7qTj. Lens' (NodeDBs ssc_a7qTj) (DB ssc_a7qTj)
miscLock :: forall ssc_a7qTj. Lens' (NodeDBs ssc_a7qTj) RWLock
newtype Snapshot
Snapshot :: Snapshot -> Snapshot
usingSnapshot :: (MonadIO m, MonadMask m) => DB ssc -> (Snapshot -> m a) -> m a
data StoredBlock ssc
StoredBlock :: !(Block ssc) -> StoredBlock ssc

-- | Block itself.
[sbBlock] :: StoredBlock ssc -> !(Block ssc)
data LeadersStorage ssc
LeadersStorage :: !EpochIndex -> !SlotLeaders -> LeadersStorage ssc
[lrcEpoch] :: LeadersStorage ssc -> !EpochIndex
[lrcLeaders] :: LeadersStorage ssc -> !SlotLeaders
data GtRichmenStorage ssc
GtRichmenStorage :: !EpochIndex -> !RichmenStake -> GtRichmenStorage ssc
[gtRichmenEpoch] :: GtRichmenStorage ssc -> !EpochIndex
[gtRichmen] :: GtRichmenStorage ssc -> !RichmenStake


-- | Reexports of Pos.Binary.* classes
module Pos.Binary

-- | Simplified definition of serializable object, Data.Binary.Class-alike.
--   
--   Write <tt>instance Bi SomeType where</tt> without any method
--   definitions if you want to use the <tt>Binary</tt> instance for your
--   type.
class Bi t where put = put get = get
put :: Bi t => t -> Put
put :: (Bi t, Binary t) => t -> Put
get :: Bi t => Get t
get :: (Bi t, Binary t) => Get t

-- | Encode a value to a lazy bytestring
encode :: Bi a => a -> LByteString

-- | Encode a value to a strict bytestring. Use with caution, because
--   converting to strict ByteString is expensive.
encodeStrict :: Bi a => a -> ByteString

-- | Decode a value from a lazy ByteString, reconstructing the original
--   structure.
decode :: Bi a => LByteString -> a
decodeOrFail :: Bi a => LByteString -> Either (LByteString, ByteOffset, String) (LByteString, ByteOffset, a)

-- | Like <a>decode</a>, but ensures that the whole input has been
--   consumed.
decodeFull :: Bi a => LByteString -> Either String a

-- | A newtype wrapper for non-negative varints. During serialization its
--   contents will be encoded as a variable-sized integer.
--   
--   Despite its name, e.g. <tt>UnsignedVarInt (-50 :: Int)</tt> will be
--   serialized and deserialized correctly; however, <a>UnsignedVarInt</a>
--   is optimized for non-negative numbers, and will always take maximum
--   space (e.g. 10 bytes in case of <a>Int64</a>). Specifically,
--   <tt>Int</tt> is simply coerced into its <tt>Word</tt> representation
--   before being serialized.
newtype UnsignedVarInt a
UnsignedVarInt :: a -> UnsignedVarInt a
[getUnsignedVarInt] :: UnsignedVarInt a -> a

-- | A newtype wrapper for varints. Uses zig-zag encoding to serialize
--   negative integers – e.g. <tt>-3</tt> is turned into 5, <tt>-4</tt> is
--   turned into 7, etc; thus it's fair but less optimal for positive
--   integers.
newtype SignedVarInt a
SignedVarInt :: a -> SignedVarInt a
[getSignedVarInt] :: SignedVarInt a -> a

-- | A newtype wrapper for non-negative integers less than <tt>2^14</tt>.
--   Use it if you want to be extra careful. Compared to
--   <a>SignedVarInt</a> and <a>UnsignedVarInt</a>, it provides two
--   benefits:
--   
--   <ul>
--   <li>It is guaranteed to take either 1 or 2 bytes (the standard decoder
--   for varints can consume an unlimited amount of bytes).</li>
--   <li>It is unambiguous (e.g. <tt>0</tt> can be encoded in only one way
--   instead of two).</li>
--   </ul>
newtype TinyVarInt
TinyVarInt :: Word16 -> TinyVarInt
[getTinyVarInt] :: TinyVarInt -> Word16

-- | A newtype wrapper for signifying that an integer should be serialized
--   using a fixed amount of bytes.
newtype FixedSizeInt a
FixedSizeInt :: a -> FixedSizeInt a
[getFixedSizeInt] :: FixedSizeInt a -> a

-- | Like <tt>isolate</tt>, but allows consuming less bytes than expected
--   (just not more).
limitGet :: Int64 -> Get a -> Get a

-- | Like <tt>isolate</tt>, but works with Int64 only.
isolate64 :: Int64 -> Get a -> Get a


-- | Module providing restoring from backup phrase functionality
module Pos.Util.BackupPhrase

-- | Datatype to contain a valid backup phrase
data BackupPhrase

-- | Make backup phrase from list
mkBackupPhrase :: [Text] -> BackupPhrase

-- | Number of words in backup phrase
backupPhraseWordsNum :: Int
bpToList :: BackupPhrase -> [Text]
toSeed :: BackupPhrase -> ByteString
keysFromPhrase :: BackupPhrase -> (SecretKey, VssKeyPair)
instance GHC.Generics.Generic Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Classes.Eq Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Show.Show Pos.Util.BackupPhrase.BackupPhrase
instance Data.Text.Buildable.Buildable Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Read.Read Pos.Util.BackupPhrase.BackupPhrase


-- | Monadic represantion of something that has <tt>json</tt> journaled log
--   of operations.
module Pos.Util.JsonLog

-- | Json log event.
data JLEvent
JLCreatedBlock :: JLBlock -> JLEvent
JLAdoptedBlock :: BlockId -> JLEvent
JLTpsStat :: Int -> JLEvent

-- | Json log of one block with corresponding <a>BlockId</a>.
data JLBlock
JLBlock :: BlockId -> BlockId -> [TxId] -> JLSlotId -> JLBlock
[jlHash] :: JLBlock -> BlockId
[jlPrevBlock] :: JLBlock -> BlockId
[jlTxs] :: JLBlock -> [TxId]
[jlSlot] :: JLBlock -> JLSlotId

-- | <a>JLEvent</a> with <tt>Timestamp</tt> -- corresponding time of this
--   event.
data JLTimedEvent
JLTimedEvent :: Integer -> JLEvent -> JLTimedEvent
[jlTimestamp] :: JLTimedEvent -> Integer
[jlEvent] :: JLTimedEvent -> JLEvent

-- | Return event of created block.
jlCreatedBlock :: BiSsc ssc => Block ssc -> JLEvent

-- | Returns event of created <a>Block</a>.
jlAdoptedBlock :: Ssc ssc => Block ssc -> JLEvent

-- | Monad for things that can log Json log events.
class Monad m => MonadJL m
jlLog :: MonadJL m => JLEvent -> m ()

-- | Append event into log by given <a>FilePath</a>.
appendJL :: (MonadIO m) => FilePath -> JLEvent -> m ()

-- | Get <a>SlotId</a> from <a>JLSlotId</a>.
fromJLSlotId :: JLSlotId -> SlotId
instance Data.Aeson.Types.Class.ToJSON Pos.Util.JsonLog.JLTimedEvent
instance Data.Aeson.Types.Class.FromJSON Pos.Util.JsonLog.JLTimedEvent
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Control.Monad.Trans.Reader.ReaderT s m)
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Aeson.Types.Class.ToJSON Pos.Util.JsonLog.JLEvent
instance Data.Aeson.Types.Class.FromJSON Pos.Util.JsonLog.JLEvent
instance Data.Aeson.Types.Class.ToJSON Pos.Util.JsonLog.JLBlock
instance Data.Aeson.Types.Class.FromJSON Pos.Util.JsonLog.JLBlock
instance GHC.Show.Show Pos.Util.JsonLog.JLTimedEvent
instance GHC.Show.Show Pos.Util.JsonLog.JLEvent
instance GHC.Show.Show Pos.Util.JsonLog.JLBlock


-- | Re-exports of Pos.Context.* functionality.
module Pos.Context

-- | Class for something that has <a>NodeContext</a> inside.
class WithNodeContext ssc m | m -> ssc
getNodeContext :: WithNodeContext ssc m => m (NodeContext ssc)

-- | Data used for LRC syncronization. First value is <b>False</b> iff LRC
--   is running now. Second value is last epoch for which we have already
--   computed LRC.
type LrcSyncData = (Bool, EpochIndex)

-- | NodeContext contains runtime context of node.
data NodeContext ssc
NodeContext :: !(Maybe (MVar FilePath)) -> !(SscNodeContext ssc) -> !(MVar HeaderHash) -> !(TVar LrcSyncData) -> !(TVar UserSecret) -> !(TBQueue (NodeId, NewestFirst NE (BlockHeader ssc))) -> !(TMVar (NodeId, BlockHeader ssc)) -> !(MVar ConfirmedProposalState) -> !RelayInvQueue -> !LoggerConfig -> !NodeParams -> !(TVar Bool) -> !(TBQueue ()) -> !(Maybe (MVar ())) -> !UTCTime -> NodeContext ssc
[ncJLFile] :: NodeContext ssc -> !(Maybe (MVar FilePath))
[ncSscContext] :: NodeContext ssc -> !(SscNodeContext ssc)

-- | Semaphore which manages access to block application. Stored hash is a
--   hash of last applied block.
[ncBlkSemaphore] :: NodeContext ssc -> !(MVar HeaderHash)

-- | Primitive for synchronization with LRC.
[ncLrcSync] :: NodeContext ssc -> !(TVar LrcSyncData)

-- | Secret keys (and path to file) which are used to send transactions
[ncUserSecret] :: NodeContext ssc -> !(TVar UserSecret)

-- | Concurrent queue that holds block headers that are to be downloaded.
[ncBlockRetrievalQueue] :: NodeContext ssc -> !(TBQueue (NodeId, NewestFirst NE (BlockHeader ssc)))

-- | In case of recovery mode this variable holds the latest header hash we
--   know about so we can do chained block requests. Invariant: this mvar
--   is full iff we're more than <tt>recoveryHeadersMessage</tt> blocks
--   deep relatively to some valid header and we're downloading blocks.
--   Every time we get block that's more difficult than this one, we
--   overwrite. Every time we process some blocks and fail or see that
--   we've downloaded this header, we clean mvar.
[ncRecoveryHeader] :: NodeContext ssc -> !(TMVar (NodeId, BlockHeader ssc))

-- | A semaphore which is unlocked when update data is downloaded and ready
--   to apply
[ncUpdateSemaphore] :: NodeContext ssc -> !(MVar ConfirmedProposalState)
[ncInvPropagationQueue] :: NodeContext ssc -> !RelayInvQueue

-- | Logger config, as taken/read from CLI
[ncLoggerConfig] :: NodeContext ssc -> !LoggerConfig

-- | Params node is launched with
[ncNodeParams] :: NodeContext ssc -> !NodeParams

-- | If this flag is <a>True</a>, then workers should stop.
[ncShutdownFlag] :: NodeContext ssc -> !(TVar Bool)

-- | A queue which is used to count how many workers have successfully
--   terminated
[ncShutdownNotifyQueue] :: NodeContext ssc -> !(TBQueue ())

-- | Exclusive lock for sending messages to other nodes (if Nothing, no
--   lock used)
[ncSendLock] :: NodeContext ssc -> !(Maybe (MVar ()))

-- | Time when node was started (<a>NodeContext</a> initialized).
[ncStartTime] :: NodeContext ssc -> !UTCTime

-- | Generate <a>PublicKey</a> from <tt>SecretKey</tt> of
--   <a>NodeContext</a>.
ncPublicKey :: NodeContext ssc -> PublicKey

-- | Generate <a>Address</a> from <tt>SecretKey</tt> of <a>NodeContext</a>
ncPubKeyAddress :: NodeContext ssc -> Address
ncGenesisLeaders :: NodeContext ssc -> SlotLeaders
ncGenesisUtxo :: NodeContext ssc -> Utxo
ncSystemStart :: NodeContext __ -> Timestamp

-- | Contains algorithm specific &amp; storage parameters for Node.
data NodeParams
NodeParams :: !FilePath -> !Bool -> !Timestamp -> !SecretKey -> !UserSecret -> !BaseParams -> !Utxo -> !Bool -> !(Maybe FilePath) -> ![AttackType] -> ![AttackTarget] -> !Bool -> !FilePath -> !Bool -> ![Text] -> ![Text] -> NodeParams

-- | Path to node's database.
[npDbPathM] :: NodeParams -> !FilePath

-- | <tt>True</tt> if data-base should be rebuilt
[npRebuildDb] :: NodeParams -> !Bool

-- | System start
[npSystemStart] :: NodeParams -> !Timestamp

-- | Primary secret key of node
[npSecretKey] :: NodeParams -> !SecretKey

-- | All node secret keys
[npUserSecret] :: NodeParams -> !UserSecret

-- | See <a>BaseParams</a>
[npBaseParams] :: NodeParams -> !BaseParams

-- | predefined custom utxo
[npCustomUtxo] :: NodeParams -> !Utxo

-- | <tt>True</tt> if node started as time-lord
[npTimeLord] :: NodeParams -> !Bool
[npJLFile] :: NodeParams -> !(Maybe FilePath)

-- | List of attack types used by malicious emulation
[npAttackTypes] :: NodeParams -> ![AttackType]

-- | List of targets to attack by malicious emulation
[npAttackTargets] :: NodeParams -> ![AttackTarget]

-- | Whether to propagate txs, ssc data, blocks to neighbors
[npPropagation] :: NodeParams -> !Bool

-- | Path to update installer executable, downloaded by update system
[npUpdatePath] :: NodeParams -> !FilePath

-- | If <a>True</a> then use installer update mechanism
[npUpdateWithPkg] :: NodeParams -> !Bool

-- | List of update server URLs
[npUpdateServers] :: NodeParams -> ![Text]

-- | List of report server URLs
[npReportServers] :: NodeParams -> ![Text]

-- | Contains basic &amp; networking parameters for running node.
data BaseParams
BaseParams :: !NetworkAddress -> ![DHTNode] -> !(Maybe DHTKey) -> !Bool -> !LoggingParams -> !FilePath -> BaseParams

-- | Port to run on
[bpIpPort] :: BaseParams -> !NetworkAddress

-- | Peers passed from CLI
[bpDHTPeers] :: BaseParams -> ![DHTNode]
[bpDHTKey] :: BaseParams -> !(Maybe DHTKey)
[bpDHTExplicitInitial] :: BaseParams -> !Bool

-- | Logger parameters
[bpLoggingParams] :: BaseParams -> !LoggingParams

-- | Path to kademlia dump file
[bpKademliaDump] :: BaseParams -> !FilePath

-- | Queue of InvMsges which should be propagated.
type RelayInvQueue = TBQueue SomeInvMsg
data SomeInvMsg
SomeInvMsg :: !(InvOrData tag key contents) -> SomeInvMsg
genesisUtxoM :: (Functor m, WithNodeContext ssc m) => m Utxo
genesisLeadersM :: (Functor m, WithNodeContext ssc m) => m SlotLeaders
putBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => HeaderHash -> m ()
readBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => m HeaderHash
takeBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => m HeaderHash

-- | Block until LRC data is available for given epoch.
waitLrc :: (MonadIO m, WithNodeContext ssc m) => EpochIndex -> m ()
lrcActionOnEpoch :: (MonadIO m, WithNodeContext ssc m, MonadThrow m) => EpochIndex -> (EpochIndex -> m (Maybe a)) -> m a
lrcActionOnEpochReason :: (MonadIO m, WithNodeContext ssc m, MonadThrow m) => EpochIndex -> Text -> (EpochIndex -> m (Maybe a)) -> m a

-- | Returns node uptime based on current time and <a>ncStartTime</a>.
getUptime :: (MonadIO m, WithNodeContext ssc m) => m Microsecond

-- | Returns if <a>ncRecoveryHeader</a> is <a>Just</a> which is equivalent
--   to "we're in recovery mode".
isRecoveryMode :: (MonadIO m, WithNodeContext ssc m) => m Bool

-- | Wrapper for monadic action which brings <a>NodeContext</a>.
newtype ContextHolder ssc m a
ContextHolder :: ReaderT (NodeContext ssc) m a -> ContextHolder ssc m a
[getContextHolder] :: ContextHolder ssc m a -> ReaderT (NodeContext ssc) m a

-- | Run <a>ContextHolder</a> action.
runContextHolder :: NodeContext ssc -> ContextHolder ssc m a -> m a

module Pos.Security.Util
shouldIgnoreAddress :: NodeContext ssc -> NetworkAddress -> Bool
shouldIgnorePkAddress :: NodeContext ssc -> StakeholderId -> Bool


-- | This module re-exports functionality from Pos.Ssc.Extra.* modules.
--   Pos.Ssc.Extra provides SSC functionality independent of particular
--   SSC.
module Pos.Ssc.Extra
class Monad m => MonadSscMem ssc m | m -> ssc where askSscMem = lift askSscMem
askSscMem :: MonadSscMem ssc m => m (SscState ssc)
askSscMem :: (MonadSscMem ssc m, MonadTrans t, MonadSscMem ssc m', t m' ~ m) => m (SscState ssc)

-- | Run something that reads <a>SscLocalData</a> in <a>MonadSscMem</a>.
--   <a>MonadIO</a> is also needed to use stm.
sscRunLocalQuery :: forall ssc m a. (MonadSscMem ssc m, MonadIO m) => ReaderT (SscLocalData ssc) m a -> m a

-- | Run STM transaction which modifies <a>SscLocalData</a> and also can
--   log.
sscRunLocalSTM :: forall ssc m a. (MonadSscMem ssc m, MonadIO m, WithLogger m) => (LoggerNameBox (PureLogger (StateT (SscLocalData ssc) STM)) a) -> m a

-- | Run something that reads <a>SscGlobalState</a> in <a>MonadSscMem</a>.
--   <a>MonadIO</a> is also needed to use stm.
sscRunGlobalQuery :: forall ssc m a. (MonadSscMem ssc m, MonadIO m) => ReaderT (SscGlobalState ssc) m a -> m a

-- | Calculate <a>SharedSeed</a> for given epoch.
sscCalculateSeed :: forall ssc m. (MonadSscMem ssc m, SscGStateClass ssc, MonadIO m, WithLogger m) => EpochIndex -> m (Either (SscSeedError ssc) SharedSeed)

-- | Get <a>SscPayload</a> for inclusion into main block with given
--   <a>SlotId</a>.
sscGetLocalPayload :: forall ssc m. (MonadIO m, MonadSscMem ssc m, SscLocalDataClass ssc, WithLogger m) => SlotId -> m (SscPayload ssc)

-- | Update local data to be valid for current global state. This function
--   is assumed to be called after applying block and before releasing lock
--   on block application.
sscNormalize :: forall ssc m. (MonadDB ssc m, MonadSscMem ssc m, SscLocalDataClass ssc, WithNodeContext ssc m, SscHelpersClass ssc, WithLogger m) => m ()

-- | Reset local data to empty state. This function can be used when we
--   detect that something is really bad. In this case it makes sense to
--   remove all local data to be sure it's valid.
sscResetLocal :: forall ssc m. (MonadDB ssc m, MonadSscMem ssc m, SscLocalDataClass ssc, MonadSlots m) => m ()

-- | Apply sequence of definitely valid blocks. Global state which is
--   result of application of these blocks can be optionally passed as
--   argument (it can be calculated in advance using
--   <a>sscVerifyBlocks</a>).
sscApplyBlocks :: forall ssc m. SscGlobalApplyMode ssc m => OldestFirst NE (Block ssc) -> Maybe (SscGlobalState ssc) -> m ()

-- | Rollback application of given sequence of blocks. Bad things can
--   happen if these blocks haven't been applied before.
sscRollbackBlocks :: forall ssc m. SscGlobalApplyMode ssc m => NewestFirst NE (Block ssc) -> m ()

-- | Verify sequence of blocks and return global state which corresponds to
--   application of given blocks. If blocks are invalid, this function will
--   return it using <a>MonadError</a> type class. All blocks must be from
--   the same epoch.
sscVerifyBlocks :: forall ssc m. SscGlobalVerifyMode ssc m => OldestFirst NE (Block ssc) -> m (SscGlobalState ssc)
newtype SscHolder ssc m a
SscHolder :: ReaderT (SscState ssc) m a -> SscHolder ssc m a
[getSscHolder] :: SscHolder ssc m a -> ReaderT (SscState ssc) m a
mkSscHolderState :: forall ssc m. (WithLogger m, WithNodeContext ssc m, SscGStateClass ssc, SscLocalDataClass ssc, MonadDB ssc m, MonadSlots m) => m (SscState ssc)
mkStateAndRunSscHolder :: forall ssc m a. (WithLogger m, WithNodeContext ssc m, SscGStateClass ssc, SscLocalDataClass ssc, MonadDB ssc m, MonadSlots m) => SscHolder ssc m a -> m a

-- | Run <a>SscHolder</a> reading GState from DB (restoring from blocks)
--   and using default (uninitialized) local state.
runSscHolder :: forall ssc m a. SscState ssc -> SscHolder ssc m a -> m a
ignoreSscHolder :: SscHolder ssc m a -> m a

-- | Whole state of SSC. Stored only in-memory by design.
data SscState ssc
SscState :: !(TVar (SscGlobalState ssc)) -> !(TVar (SscLocalData ssc)) -> SscState ssc
[sscGlobal] :: SscState ssc -> !(TVar (SscGlobalState ssc))
[sscLocal] :: SscState ssc -> !(TVar (SscLocalData ssc))


-- | Txp system reexports.
module Pos.Txp

-- | Real data inside TxpLDHolder
data TxpLDWrap ssc
TxpLDWrap :: !(TVar (UtxoView ssc)) -> !(TVar MemPool) -> !(TVar (HashMap TxId [TxOutAux])) -> !(TVar HeaderHash) -> TxpLDWrap ssc
[utxoView] :: TxpLDWrap ssc -> !(TVar (UtxoView ssc))
[memPool] :: TxpLDWrap ssc -> !(TVar MemPool)
[undos] :: TxpLDWrap ssc -> !(TVar (HashMap TxId [TxOutAux]))
[ldTip] :: TxpLDWrap ssc -> !(TVar HeaderHash)
class Monad m => MonadTxpLD ssc m | m -> ssc where modifyTxpLD_ = modifyTxpLD . (((),) .) setTxpLD txpLD = modifyTxpLD_ $ const txpLD getTxpLDWrap = lift getTxpLDWrap setUtxoView = lift . setUtxoView setMemPool = lift . setMemPool modifyTxpLD = lift . modifyTxpLD getTxpLD = lift getTxpLD
getTxpLDWrap :: MonadTxpLD ssc m => m (TxpLDWrap ssc)
setUtxoView :: MonadTxpLD ssc m => UtxoView ssc -> m ()
setMemPool :: MonadTxpLD ssc m => MemPool -> m ()
modifyTxpLD :: MonadTxpLD ssc m => (TxpLD ssc -> (a, TxpLD ssc)) -> m a
modifyTxpLD_ :: MonadTxpLD ssc m => (TxpLD ssc -> TxpLD ssc) -> m ()
getTxpLD :: MonadTxpLD ssc m => m (TxpLD ssc)
setTxpLD :: MonadTxpLD ssc m => TxpLD ssc -> m ()
getTxpLDWrap :: (MonadTxpLD ssc m, MonadTrans t, MonadTxpLD ssc m', t m' ~ m) => m (TxpLDWrap ssc)
setUtxoView :: (MonadTxpLD ssc m, MonadTrans t, MonadTxpLD ssc m', t m' ~ m) => UtxoView ssc -> m ()
setMemPool :: (MonadTxpLD ssc m, MonadTrans t, MonadTxpLD ssc m', t m' ~ m) => MemPool -> m ()
modifyTxpLD :: (MonadTxpLD ssc m, MonadTrans t, MonadTxpLD ssc m', t m' ~ m) => (TxpLD ssc -> (a, TxpLD ssc)) -> m a
getTxpLD :: (MonadTxpLD ssc m, MonadTrans t, MonadTxpLD ssc m', t m' ~ m) => m (TxpLD ssc)

-- | LocalData of transactions processing. There are two invariants which
--   must hold for local data (where uv is UtxoView, memPool is MemPool and
--   tip is HeaderHash): 1. Suppose <tt>blks</tt> is sequence of blocks
--   from the very beggining up to <tt>tip</tt>. If one applies
--   <tt>blks</tt> to genesis Utxo, resulting Utxo (let's call it
--   <tt>utxo1</tt>) will be such that all transactions from <a>memPool</a>
--   are valid with respect to it. 2. If one applies all transactions from
--   <a>memPool</a> to <tt>utxo1</tt>, resulting Utxo will be equivalent to
--   <tt>uv</tt> with respect to MonadUtxo.
type TxpLD ssc = (UtxoView ssc, MemPool, HashMap TxId [TxOutAux], HeaderHash)
getLocalTxs :: MonadTxpLD ssc m => m [(TxId, TxAux)]
getLocalUndo :: MonadTxpLD ssc m => m (HashMap TxId [TxOutAux])
getLocalTxsNUndo :: MonadTxpLD ssc m => m ([(TxId, TxAux)], HashMap TxId [TxOutAux])
getUtxoView :: MonadTxpLD ssc m => m (UtxoView ssc)
getMemPool :: MonadTxpLD ssc m => m MemPool
data TxpError

-- | Can't apply blocks to state of transactions processing.
TxpCantApplyBlocks :: Text -> TxpError
newtype TxpLDHolder ssc m a
TxpLDHolder :: ReaderT (TxpLDWrap ssc) m a -> TxpLDHolder ssc m a
[getTxpLDHolder] :: TxpLDHolder ssc m a -> ReaderT (TxpLDWrap ssc) m a
runTxpLDHolder :: MonadIO m => UtxoView ssc -> HeaderHash -> TxpLDHolder ssc m a -> m a

-- | Local run needed for validation txs. For validation need only
--   UtxoView.
runLocalTxpLDHolder :: MonadIO m => TxpLDHolder ssc m a -> UtxoView ssc -> m a

-- | Real data inside TxpLDHolder
data TxpLDWrap ssc
TxpLDWrap :: !(TVar (UtxoView ssc)) -> !(TVar MemPool) -> !(TVar (HashMap TxId [TxOutAux])) -> !(TVar HeaderHash) -> TxpLDWrap ssc
[utxoView] :: TxpLDWrap ssc -> !(TVar (UtxoView ssc))
[memPool] :: TxpLDWrap ssc -> !(TVar MemPool)
[undos] :: TxpLDWrap ssc -> !(TVar (HashMap TxId [TxOutAux]))
[ldTip] :: TxpLDWrap ssc -> !(TVar HeaderHash)
runTxpLDHolderReader :: TxpLDWrap ssc -> TxpLDHolder ssc m a -> m a

-- | Verify whether sequence of blocks can be applied to current Tx state.
--   This function doesn't make pure checks for transactions, they are
--   assumed to be done earlier.
txVerifyBlocks :: forall ssc m. MonadDB ssc m => OldestFirst NE (Block ssc) -> m (Either Text (OldestFirst NE TxUndo))

-- | Apply chain of <i>definitely</i> valid blocks to state on transactions
--   processing.
txApplyBlocks :: TxpWorkMode ssc m => OldestFirst NE (Blund ssc) -> m (OldestFirst NE SomePrettyBatchOp)
processTx :: MinTxpWorkMode ssc m => (TxId, TxAux) -> m ProcessTxRes
txRollbackBlocks :: (WithLogger m, MonadDB ssc m) => NewestFirst NE (Blund ssc) -> m (NonEmpty SomePrettyBatchOp)

-- | <ol>
--   <li>Recompute UtxoView by current MemPool | 2. Remove invalid
--   transactions from MemPool</li>
--   </ol>
normalizeTxpLD :: (MonadDB ssc m, MonadTxpLD ssc m) => m ()
data TxMsgTag
TxMsgTag :: TxMsgTag

-- | Data message. Can be used to send one transaction per message.
data TxMsgContents
TxMsgContents :: !Tx -> !TxWitness -> !TxDistribution -> TxMsgContents
[dmTx] :: TxMsgContents -> !Tx
[dmWitness] :: TxMsgContents -> !TxWitness
[dmDistribution] :: TxMsgContents -> !TxDistribution
data UtxoView ssc
UtxoView :: !(HashMap TxIn TxOutAux) -> !(HashSet TxIn) -> !(DB ssc) -> UtxoView ssc
[addUtxo] :: UtxoView ssc -> !(HashMap TxIn TxOutAux)
[delUtxo] :: UtxoView ssc -> !(HashSet TxIn)
[utxoDB] :: UtxoView ssc -> !(DB ssc)
data MemPool
MemPool :: !TxMap -> !Int -> MemPool
[localTxs] :: MemPool -> !TxMap

-- | <tt>length</tt> is <tt>O(n)</tt> for <a>HashMap</a> so we store it
--   explicitly.
[localTxsSize] :: MemPool -> !Int
type TxMap = HashMap TxId TxAux

-- | Result of transaction processing
data ProcessTxRes

-- | Transaction has ben successfully added to the storage
PTRadded :: ProcessTxRes

-- | Transaction is already in the storage (cache)
PTRknown :: ProcessTxRes

-- | Can't add transaction
PTRinvalid :: !Text -> ProcessTxRes

-- | Local transaction storage is full -- can't accept more txs
PTRoverwhelmed :: ProcessTxRes

-- | Make <a>ProcessTxRes</a> from list of error messages using
--   <a>PTRinvalid</a> constructor. Intended to be used with
--   <tt>VerificationRes</tt>. Note: this version forces computation of all
--   error messages. It can be made more efficient but less informative by
--   using head, for example.
mkPTRinvalid :: [Text] -> ProcessTxRes
getTxOut :: (MonadIO m, MonadThrow m) => TxIn -> UtxoView ssc -> m (Maybe TxOutAux)
putTxOut :: TxIn -> TxOutAux -> UtxoView ssc -> UtxoView ssc
delTxIn :: TxIn -> UtxoView ssc -> UtxoView ssc
createFromDB :: DB ssc -> UtxoView ssc
class Monad m => MonadBalances ssc m | m -> ssc
setStake :: MonadBalances ssc m => StakeholderId -> Coin -> m ()
setTotalStake :: MonadBalances ssc m => Coin -> m ()
getStake :: MonadBalances ssc m => StakeholderId -> m (Maybe Coin)
getTotalStake :: MonadBalances ssc m => m Coin
type BalancesHolder ssc = StateT (BalancesView ssc)
data BalancesView ssc
BalancesView :: !(HashMap StakeholderId Coin) -> !Coin -> !(DB ssc) -> BalancesView ssc
[_stakes] :: BalancesView ssc -> !(HashMap StakeholderId Coin)
[_total] :: BalancesView ssc -> !Coin
[_balDB] :: BalancesView ssc -> !(DB ssc)


-- | Methods of reporting different unhealthy behaviour to server.
module Pos.Reporting.Methods

-- | Sends node's logs, taking <a>LoggerConfig</a> from
--   <tt>NodeContext</tt>, retrieving all logger files from it. List of
--   servers is also taken from node's configuration.
sendReportNode :: (MonadIO m, MonadMask m, WithNodeContext її m) => ReportType -> m ()

-- | Retrieves node info that we would like to know when analyzing
--   malicious behavior of node.
getNodeInfo :: (MonadDHT m, MonadIO m) => m Text

-- | Reports misbehaviour given reason string. Effectively designed for
--   <tt>WorkMode</tt> context.
reportMisbehaviour :: forall m її. ReportingContext її m => Text -> m ()

-- | Report misbehaveour, but catch all errors inside
reportMisbehaviourMasked :: forall m її. ReportingContext її m => Text -> m ()

-- | Execute action, report <a>CardanoFatalError</a> and <a>FatalError</a>
--   if it happens and rethrow. Errors related to reporting itself are
--   caught, logged and ignored.
reportingFatal :: forall m a ё. ReportingContext ё m => m a -> m a

-- | Given logs files list and report type, sends reports to URI asked. All
--   files _must_ exist. Report server URI should be in form like
--   "http(s):/<i>host:port</i>" without specified endpoint.
--   
--   <b>Important notice</b>: if given paths are logs that we're currently
--   writing to using this executable (or forked thread), you'll get an
--   error, because there's no possibility to have two handles on the same
--   file, see <a>IO</a> documentation on handles. Use second parameter for
--   that.
sendReport :: (MonadIO m, MonadMask m) => [FilePath] -> [Text] -> ReportType -> Text -> Version -> String -> m ()

-- | Given logger config, retrieves all (logger name, filepath) for every
--   logger that has file handle.
retrieveLogFiles :: LoggerConfig -> [([Text], FilePath)]

-- | Retrieves real filepathes of logs given filepathes from log
--   description. Example: there's <tt>component.log</tt> in config, but
--   this function will return <tt>[component.log.122,
--   component.log.123]</tt>.
chooseLogFiles :: (MonadIO m) => FilePath -> m [FilePath]


-- | Reexports of error reporting functionality
module Pos.Reporting

module Pos.DHT.Model.Neighbors

-- | Send default message to neighbours in parallel. It's a broadcasting to
--   the neighbours without sessions (i.e. we don't have to wait for reply
--   from the listeners).
sendToNeighbors :: (MonadDHT m, MonadMockable m, Bi body, WithLogger m, Message body) => SendActions m -> body -> m ()
sendToNode :: (MonadMockable m, Bi body, Message body) => SendActions m -> DHTNode -> body -> m ()
converseToNeighbors :: (MonadDHT m, MonadMockable m, WithLogger m, Bi rcv, Bi snd, Message snd, Message rcv) => SendActions m -> (NodeId -> ConversationActions snd rcv m -> m ()) -> m ()
converseToNode :: (MonadMockable m, Bi rcv, Bi snd, Message snd, Message rcv) => SendActions m -> DHTNode -> (NodeId -> ConversationActions snd rcv m -> m t) -> m t


-- | Distributed Hash Table for peer discovery.
module Pos.DHT.Model


-- | Implementation of statistics gathering and processing utilities.
module Pos.Statistics

-- | Log count statistic event.
statlogCountEvent :: (MonadStats m, StatLabel l, EntryType l ~ CountStat) => l -> Word64 -> m ()

-- | Log value statistic event.
statlogValueEvent :: (MonadStats m, StatLabel l, EntryType l ~ ValueStat) => l -> Double -> m ()

-- | <a>MonadStats</a> is a monad which has methods for stats collecting
class Monad m => MonadStats m where statLog label = lift . statLog label resetStat = lift . resetStat logStatM label action = action >>= statLog label
statLog :: (MonadStats m, StatLabel l) => l -> EntryType l -> m ()
resetStat :: (MonadStats m, StatLabel l) => l -> m ()
statLog :: (MonadStats m, MonadTrans t, MonadStats m', t m' ~ m, StatLabel l) => l -> EntryType l -> m ()
resetStat :: (MonadStats m, MonadTrans t, MonadStats m', t m' ~ m, StatLabel l) => l -> m ()

-- | Default convenience method, which we can override (to truly do nothing
--   in <a>NoStatsT</a>, for example)
logStatM :: (MonadStats m, StatLabel l) => l -> m (EntryType l) -> m ()

-- | Stats wrapper for collecting statistics without collecting it.
newtype NoStatsT m a
NoStatsT :: m a -> NoStatsT m a

-- | action inside wrapper without collecting statistics
[getNoStatsT] :: NoStatsT m a -> m a

-- | Statistics wrapper around some monadic action to collect statistics
--   during execution of this action. Used in benchmarks.
newtype StatsT m a
StatsT :: ReaderT StatsMap m a -> StatsT m a

-- | action inside wrapper with collected statistics
[getStatsT] :: StatsT m a -> ReaderT StatsMap m a
runStatsT :: MonadIO m => StatsT m a -> m a
runStatsT' :: StatsMap -> StatsT m a -> m a
getStatsMap :: Monad m => StatsT m StatsMap

-- | Stat entry is a simple counter or a structure for aggregating
--   statistical data about real value
type StatEntry e = (Monoid e, FullySerializable e)

-- | <a>StatLabel</a> is some datatype which determines a single stat
class (FullySerializable l, Buildable l, Hashable l, StatEntry (EntryType l)) => StatLabel l where type EntryType l :: * where {
    type family EntryType l :: *;
}
labelName :: StatLabel l => Proxy l -> Text
toJLEvent :: StatLabel l => l -> EntryType l -> JLEvent

-- | Counter for specified statistics.
newtype CountStat
CountStat :: Word64 -> CountStat
[getCounter] :: CountStat -> Word64

-- | Value for specified collected statistic.
data ValueStat
ValueStat :: !Word64 -> !Double -> !Double -> !Double -> ValueStat
[valueCount] :: ValueStat -> !Word64
[valueMin] :: ValueStat -> !Double
[valueMax] :: ValueStat -> !Double
[valueSum] :: ValueStat -> !Double

-- | Singleton data type to represent collected statistics about processes
--   <tt>Tx'</tt>s.
data StatProcessTx
StatProcessTx :: StatProcessTx


-- | <a>WorkMode</a> constraint. It is widely used in almost every our
--   code. Simple alias for bunch of useful constraints. This module also
--   contains new monads to extend functional capabilities inside do-block.
module Pos.WorkMode

-- | Bunch of constraints to perform work for real world distributed
--   system.
type WorkMode ssc m = (MinWorkMode m, MonadMask m, MonadSlots m, MonadDB ssc m, MonadTxpLD ssc m, MonadDelegation m, MonadUtxo m, MonadSscMem ssc m, SscGStateClass ssc, SscLocalDataClass ssc, SscHelpersClass ssc, WithNodeContext ssc m, MonadStats m, MonadJL m, WithKademliaDHTInstance m, WithPeerState m, MonadUSMem m)

-- | More relaxed version of <a>WorkMode</a>.
type MinWorkMode m = (WithLogger m, MonadMockable m, MonadDHT m, MonadIO m, WithPeerState m)

-- | ProductionMode is an instance of WorkMode which is used
--   (unsurprisingly) in production.
type ProductionMode ssc = NoStatsT (RawRealMode ssc)

-- | RawRealMode is a basis for <a>WorkMode</a>s used to really run system.
type RawRealMode ssc = PeerStateHolder (KademliaDHT (USHolder (DelegationT (TxpLDHolder ssc (SscHolder ssc (NtpSlotting (SlottingHolder (ContextHolder ssc (DBHolder ssc (LoggerNameBox Production))))))))))

-- | ServiceMode is the mode in which support nodes work.
type ServiceMode = PeerStateHolder (KademliaDHT (LoggerNameBox Production))

-- | StatsMode is used for remote benchmarking.
type StatsMode ssc = StatsT (RawRealMode ssc)
instance Pos.Types.Utxo.Class.MonadUtxoRead m => Pos.Types.Utxo.Class.MonadUtxoRead (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Types.Utxo.Class.MonadUtxo m => Pos.Types.Utxo.Class.MonadUtxo (Pos.DHT.Real.Types.KademliaDHT m)
instance (GHC.Base.Monad m, Pos.Context.Class.WithNodeContext ssc m) => Pos.Context.Class.WithNodeContext ssc (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.DB.Class.MonadDB ssc m => Pos.DB.Class.MonadDB ssc (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Delegation.Class.MonadDelegation m => Pos.Delegation.Class.MonadDelegation (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Update.MemState.Class.MonadUSMem m => Pos.Update.MemState.Class.MonadUSMem (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Types.Utxo.Class.MonadUtxoRead m => Pos.Types.Utxo.Class.MonadUtxoRead (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Types.Utxo.Class.MonadUtxo m => Pos.Types.Utxo.Class.MonadUtxo (Pos.Communication.PeerState.PeerStateHolder m)
instance (GHC.Base.Monad m, Pos.Context.Class.WithNodeContext ssc m) => Pos.Context.Class.WithNodeContext ssc (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.DB.Class.MonadDB ssc m => Pos.DB.Class.MonadDB ssc (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.DHT.Model.Class.MonadDHT m => Pos.DHT.Model.Class.MonadDHT (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Ssc.Extra.Class.MonadSscMem ssc m => Pos.Ssc.Extra.Class.MonadSscMem ssc (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Delegation.Class.MonadDelegation m => Pos.Delegation.Class.MonadDelegation (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Txp.Class.MonadTxpLD ssc m => Pos.Txp.Class.MonadTxpLD ssc (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Update.MemState.Class.MonadUSMem m => Pos.Update.MemState.Class.MonadUSMem (Pos.Communication.PeerState.PeerStateHolder m)
instance (GHC.Base.Monad m, Pos.DHT.Real.Types.WithKademliaDHTInstance m) => Pos.DHT.Real.Types.WithKademliaDHTInstance (Pos.Communication.PeerState.PeerStateHolder m)
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Pos.DHT.Real.Types.KademliaDHT m)


-- | Framework for Inv<i>Req</i>Dat message handling
module Pos.Communication.Relay

-- | Typeclass for general Inv<i>Req</i>Dat framework. It describes monads,
--   that store data described by tag, where "key" stands for node
--   identifier.
class (Buildable tag, Buildable contents, Buildable key, Typeable tag, Typeable contents, Typeable key, Message (InvOrData tag key contents), Message (ReqMsg key tag)) => Relay m tag key contents | tag -> contents, contents -> tag, contents -> key, tag -> key

-- | Converts data to tag. Tag returned in monad <tt>m</tt> for only type
--   matching reason (multiparam type classes are tricky)
contentsToTag :: Relay m tag key contents => contents -> m tag

-- | Same for key. Sometime contents has key inside already, so it's
--   redundant to double-pass it everywhere.
contentsToKey :: Relay m tag key contents => contents -> m key
verifyInvTag :: Relay m tag key contents => tag -> m VerificationRes
verifyReqTag :: Relay m tag key contents => tag -> m VerificationRes
verifyDataContents :: Relay m tag key contents => contents -> m VerificationRes

-- | Handle inv msg and return whether it's useful or not
handleInv :: Relay m tag key contents => tag -> key -> m Bool

-- | Handle req msg and return (Just data) in case requested data can be
--   provided
handleReq :: Relay m tag key contents => tag -> key -> m (Maybe contents)

-- | Handle data msg and return True if message is to be propagated
handleData :: Relay m tag key contents => contents -> m Bool

-- | Inventory message. Can be used to announce the fact that you have some
--   data.
data InvMsg key tag
InvMsg :: !tag -> !(NonEmpty key) -> InvMsg key tag
[imTag] :: InvMsg key tag -> !tag
[imKeys] :: InvMsg key tag -> !(NonEmpty key)

-- | Request message. Can be used to request data (ideally data which was
--   previously announced by inventory message).
data ReqMsg key tag
ReqMsg :: !tag -> !(NonEmpty key) -> ReqMsg key tag
[rmTag] :: ReqMsg key tag -> !tag
[rmKeys] :: ReqMsg key tag -> !(NonEmpty key)

-- | Data message. Can be used to send actual data.
data DataMsg contents
DataMsg :: !contents -> DataMsg contents
[dmContents] :: DataMsg contents -> !contents
relayListeners :: (MonadDHT m, Bi (InvMsg key tag), Bi (ReqMsg key tag), Bi (DataMsg contents), Bi (InvOrData tag key contents), MessagePart contents, MessagePart tag, Relay m tag key contents, Mockable Throw m, WithLogger m, WorkMode ssc m) => RelayProxy key tag contents -> ([ListenerSpec m], OutSpecs)
relayStubListeners :: (WithLogger m, Bi (InvMsg key tag), Bi (ReqMsg key tag), Bi (DataMsg contents), Message (InvOrData tag key contents), Message (ReqMsg key tag)) => RelayProxy key tag contents -> ([ListenerSpec m], OutSpecs)
relayWorkers :: forall ssc m. (Mockable Throw m, WorkMode ssc m, Bi NOP, Message NOP) => ([WorkerSpec m], OutSpecs)
data RelayProxy key tag contents
RelayProxy :: RelayProxy key tag contents
type InvOrData tag key contents = Either (InvMsg key tag) (DataMsg contents)
invReqDataFlow :: (Message (InvOrData tag id contents), Message (ReqMsg id tag), Buildable id, MinWorkMode m, Bi tag, Bi id, Bi (InvOrData tag id contents), Bi (ReqMsg id tag)) => Text -> SendActions m -> DHTNode -> tag -> id -> contents -> m ()
invReqDataFlowNeighbors :: (Message (InvOrData tag id contents), Message (ReqMsg id tag), Buildable id, MinWorkMode m, Bi tag, Bi id, Bi (InvOrData tag id contents), Bi (ReqMsg id tag)) => Text -> SendActions m -> tag -> id -> contents -> m ()
instance GHC.Show.Show Pos.Communication.Relay.RelayError
instance GHC.Generics.Generic Pos.Communication.Relay.RelayError
instance GHC.Exception.Exception Pos.Communication.Relay.RelayError


-- | Arbitrary instances for Update System types.
module Pos.Update.Arbitrary

module Pos.DHT.Workers
dhtWorkers :: (WorkMode ssc m) => ([WorkerSpec m], OutSpecs)


-- | Reexport module
module Pos.Delegation

-- | In-memory storage needed for delegation logic Maybe ncProxyCache
--   should be LRU instead of hashmap, but that's not urgent optimization
--   idea.
data DelegationWrap
DelegationWrap :: HashMap SendProxySK UTCTime -> HashMap ProxySKLight UTCTime -> HashMap PublicKey ProxySKHeavy -> EpochIndex -> HashSet PublicKey -> DelegationWrap

-- | Message cache to prevent infinite propagation of useless certs.
[_dwMessageCache] :: DelegationWrap -> HashMap SendProxySK UTCTime

-- | Confirmation cache for lightweight PSKs.
[_dwConfirmationCache] :: DelegationWrap -> HashMap ProxySKLight UTCTime

-- | Memory pool of hardweight proxy secret keys. Keys of this map are
--   issuer public keys.
[_dwProxySKPool] :: DelegationWrap -> HashMap PublicKey ProxySKHeavy

-- | Epoch index <a>DelegationWrap</a> is correct in relation to.
[_dwEpochId] :: DelegationWrap -> EpochIndex

-- | Set of stakeholders that have already posted their PSKs this epoch.
[_dwThisEpochPosted] :: DelegationWrap -> HashSet PublicKey
dwMessageCache :: Lens' DelegationWrap (HashMap SendProxySK UTCTime)
dwConfirmationCache :: Lens' DelegationWrap (HashMap ProxySKLight UTCTime)
dwProxySKPool :: Lens' DelegationWrap (HashMap PublicKey ProxySKHeavy)
dwEpochId :: Lens' DelegationWrap EpochIndex
dwThisEpochPosted :: Lens' DelegationWrap (HashSet PublicKey)

-- | Equivalent of <tt>MonadReader (TVar DelegationWrap) m</tt>. Currently
--   we're locking on the whole delegation wrap at once. Locking on
--   independent components is better in performance, so there's a place
--   for optimization here.
class (Monad m) => MonadDelegation m where askDelegationState = lift askDelegationState

-- | Retrieves <a>TVar</a> on <a>DelegationWrap</a>
askDelegationState :: MonadDelegation m => m (TVar DelegationWrap)

-- | Retrieves <a>TVar</a> on <a>DelegationWrap</a>
askDelegationState :: (MonadDelegation m, MonadTrans t, MonadDelegation m', t m' ~ m) => m (TVar DelegationWrap)

-- | Wrapper of <tt>ReaderT (TVar DelegationWrap)</tt>, nothing smart.
newtype DelegationT m a
DelegationT :: ReaderT ReaderTCtx m a -> DelegationT m a
[getDelegationT] :: DelegationT m a -> ReaderT ReaderTCtx m a

-- | Executes delegationT transformer creating tvar from given wrap.
runDelegationT :: MonadIO m => DelegationWrap -> DelegationT m a -> m a

-- | Executes delegation wrap using existing delegation wrap tvar.
runDelegationTFromTVar :: TVar DelegationWrap -> DelegationT m a -> m a

-- | Listeners for requests related to delegation processing.
delegationListeners :: WorkMode ssc m => ([ListenerSpec m], OutSpecs)
delegationStubListeners :: WithLogger m => ([ListenerSpec m], OutSpecs)

-- | Handler <a>SendProxySK</a> event.
handleSendProxySK :: forall ssc m. (WorkMode ssc m) => (ListenerSpec m, OutSpecs)
handleConfirmProxySK :: forall ssc m. (WorkMode ssc m) => (ListenerSpec m, OutSpecs)

-- | Convenient monad to work in <a>DelegationWrap</a> context while being
--   in STM.
newtype DelegationStateAction a
DelegationStateAction :: StateT DelegationWrap STM a -> DelegationStateAction a
[getDelegationStateM] :: DelegationStateAction a -> StateT DelegationWrap STM a

-- | Effectively takes a lock on ProxyCaches mvar in NodeContext and allows
--   you to run some computation producing updated ProxyCaches and return
--   value. Will put MVar back on exception.
runDelegationStateAction :: (MonadIO m, MonadDelegation m) => DelegationStateAction a -> m a

-- | Invalidates proxy caches using built-in constants.
invalidateProxyCaches :: UTCTime -> DelegationStateAction ()

-- | Initializes delegation in-memory storage.
--   
--   <ul>
--   <li>Sets <tt>_dwEpochId</tt> to epoch of tip.</li>
--   <li>Loads <tt>_dwThisEpochPosted</tt> from database</li>
--   </ul>
initDelegation :: (SscHelpersClass ssc, MonadDB ssc m, MonadDelegation m) => m ()

-- | Retrieves current mempool of heavyweight psks plus undo part.
getProxyMempool :: (MonadDB ssc m, MonadDelegation m) => m ([ProxySKHeavy], [ProxySKHeavy])

-- | Datatypes representing a verdict of heavy PSK processing.
data PskHeavyVerdict

-- | If we have exactly the same cert in psk mempool
PHExists :: PskHeavyVerdict

-- | Can't accept PSK though it's most probably user's error
PHInvalid :: Text -> PskHeavyVerdict

-- | Broken (signature, most probably attack, we can ban for this)
PHBroken :: PskHeavyVerdict

-- | Message is cached
PHCached :: PskHeavyVerdict

-- | Verdict can't be made at the moment (we're updating)
PHIncoherent :: PskHeavyVerdict

-- | Successfully processed/added to psk mempool
PHAdded :: PskHeavyVerdict

-- | Processes heavyweight psk. Puts it into the mempool depending on
--   issuer's stake, overrides if exists, checks validity and cachemsg
--   state.
processProxySKHeavy :: (SscHelpersClass ssc, MonadDB ssc m, MonadDelegation m, WithNodeContext ssc m) => ProxySKHeavy -> m PskHeavyVerdict

-- | Applies a sequence of definitely valid blocks to memory state and
--   returns batchops. It works correctly only in case blocks don't cross
--   over epoch. So genesis block is either absent or the head.
delegationApplyBlocks :: forall ssc m. (DelegationWorkMode ssc m) => OldestFirst NE (Block ssc) -> m (NonEmpty SomeBatchOp)

-- | Verifies if blocks are correct relatively to the delegation logic and
--   returns a non-empty list of proxySKs needed for undoing them.
--   Predicate for correctness here is:
--   
--   <ul>
--   <li>Issuer can post only one cert per epoch</li>
--   <li>For every new certificate issuer had enough stake at the end of
--   prev. epoch</li>
--   </ul>
--   
--   It's assumed blocks are correct from 'Pos.Types.Block#verifyBlocks'
--   point of view.
delegationVerifyBlocks :: forall ssc m. (SscHelpersClass ssc, MonadDB ssc m, WithNodeContext ssc m) => OldestFirst NE (Block ssc) -> m (Either Text (OldestFirst NE [ProxySKHeavy]))

-- | Rollbacks block list. Erases mempool of certificates. Better to
--   restore them after the rollback (see Txp#normalizeTxpLD). You can
--   rollback arbitrary number of blocks.
delegationRollbackBlocks :: (SscHelpersClass ssc, MonadDelegation m, MonadDB ssc m, WithNodeContext ssc m) => NewestFirst NE (Blund ssc) -> m (NonEmpty SomeBatchOp)

-- | PSK check verdict. It can be unrelated (other key or spoiled, no way
--   to differ), exist in storage already or be cached.
data PskLightVerdict
PLUnrelated :: PskLightVerdict
PLInvalid :: PskLightVerdict
PLExists :: PskLightVerdict
PLCached :: PskLightVerdict
PLRemoved :: PskLightVerdict
PLAdded :: PskLightVerdict

-- | Processes proxy secret key (understands do we need it, adds/caches on
--   decision, returns this decision).
processProxySKLight :: (MonadDelegation m, WithNodeContext ssc m, MonadDB ssc m, MonadMask m) => ProxySKLight -> m PskLightVerdict

-- | Verdict of <a>processConfirmProxySk</a> function
data ConfirmPskLightVerdict

-- | Valid, saved
CPValid :: ConfirmPskLightVerdict

-- | Invalid, throw away
CPInvalid :: ConfirmPskLightVerdict

-- | Already saved
CPCached :: ConfirmPskLightVerdict

-- | Takes a lightweight psk, delegate proof of delivery. Checks if it's
--   valid or not. Caches message in any case.
processConfirmProxySk :: (MonadDelegation m, MonadIO m) => ProxySKLight -> ProxySigLight ProxySKLight -> m ConfirmPskLightVerdict

-- | Checks if we hold a confirmation for given PSK.
isProxySKConfirmed :: ProxySKLight -> DelegationStateAction Bool

-- | Consumer will be called on every Richmen computation.
delegationLrcConsumer :: MonadDB ssc m => LrcConsumer m

-- | Sends epoch psk to neighbours
sendProxySKLight :: (MinWorkMode m) => ProxySKLight -> Action' m ()

-- | Sends simple psk to neighbours
sendProxySKHeavy :: (MinWorkMode m) => ProxySKHeavy -> Action' m ()

-- | Generates a proof of being a delegate for psk and sends it to
--   neighbors.
sendProxyConfirmSK :: (WorkMode ssc m) => ProxySKLight -> Action' m ()
sendProxySKLightOuts :: OutSpecs
sendProxySKHeavyOuts :: OutSpecs
sendProxyConfirmSKOuts :: OutSpecs

-- | Message with delegated proxy secret key. Is used to propagate both
--   epoch-oriented psks (lightweight) and simple (heavyweight).
data SendProxySK
SendProxySKLight :: !ProxySKLight -> SendProxySK
SendProxySKHeavy :: !ProxySKHeavy -> SendProxySK

-- | Confirmation of proxy signature delivery. Delegate should take the
--   proxy signing key he has and sign this key with itself. If the
--   signature is correct, then it was done by delegate (guaranteed by PSK
--   scheme). Checking <tt>w</tt> can be done with <tt>(const True)</tt>
--   predicate, because certificate may be sent in epoch id that's before
--   lower cert's <tt>EpochIndex</tt>.
data ConfirmProxySK
ConfirmProxySK :: !ProxySKLight -> !(ProxySigLight ProxySKLight) -> ConfirmProxySK

module Pos.Security.Class
class Ssc ssc => SecurityWorkersClass ssc
securityWorkers :: (SecurityWorkersClass ssc, WorkMode ssc m) => Tagged ssc ([WorkerSpec m], OutSpecs)

module Pos.Security


-- | Leaders and richmen computation.
module Pos.Lrc

-- | Datatype for LRC computation client. If you want to compute richmen,
--   you should add such client to LRC framework
data LrcConsumer m
LrcConsumer :: (Coin -> Coin) -> (EpochIndex -> m Bool) -> (EpochIndex -> Coin -> RichmenStake -> m ()) -> Bool -> LrcConsumer m

-- | Function which defines threshold depends on total stake
[lcThreshold] :: LrcConsumer m -> Coin -> Coin

-- | Function which defines necessity of richmen computation
[lcIfNeedCompute] :: LrcConsumer m -> EpochIndex -> m Bool

-- | Callback which will be called when richmen computed
[lcComputedCallback] :: LrcConsumer m -> EpochIndex -> Coin -> RichmenStake -> m ()

-- | Whether delegated stake should be considered
[lcConsiderDelegated] :: LrcConsumer m -> Bool

-- | Create LrcConsumer using constants from RichmenComponent and given
--   actions.
lrcConsumerFromComponent :: forall c m. RichmenComponent c => (EpochIndex -> m Bool) -> (EpochIndex -> Coin -> RichmenStake -> m ()) -> LrcConsumer m

-- | Create simple LrcConsumer using constants from RichmenComponent which
--   uses only LRC DB.
lrcConsumerFromComponentSimple :: forall c ssc m. (RichmenComponent c, MonadDB ssc m) => LrcConsumer m
allLrcConsumers :: (SscWorkersClass ssc, WorkMode ssc m) => [LrcConsumer m]

-- | Find nodes which have at least 'eligibility threshold' coins.
findRichmenStake :: forall m. MonadIterator (StakeholderId, Coin) m => Coin -> m RichmenStake

-- | Pure version of findRichmen which uses in-memory Utxo.
findRichmenPure :: [(StakeholderId, Coin)] -> (Coin -> Coin) -> RichmenType -> FullRichmenData

-- | Function considers all variants of computation and compute using one
--   pass by stake DB and one pass by delegation DB.
findAllRichmenMaybe :: forall ssc m. (MonadDB ssc m, MonadIterator (StakeholderId, Coin) m) => Maybe Coin -> Maybe Coin -> m (RichmenStake, RichmenStake)

-- | Find delegated richmen.
findDelegatedRichmen :: (MonadDB ssc m, MonadIterator (StakeholderId, Coin) m) => Coin -> m RichmenStake
data RichmenType
RTUsual :: RichmenType
RTDelegation :: (HashMap StakeholderId [StakeholderId]) -> RichmenType

-- | Addresses which have enough stake for participation in SSC.
type Richmen = NonEmpty StakeholderId

-- | Hashset of richmen.
type RichmenSet = HashSet StakeholderId

-- | Richmen with Stake
type RichmenStake = HashMap StakeholderId Coin
toRichmen :: RichmenStake -> Richmen

-- | Full richmen data consists of total stake at some point and stake
--   distribution among richmen.
type FullRichmenData = (Coin, RichmenStake)


-- | Re-exports of Pos.Ssc.Class.* modules.
module Pos.Ssc.Class
class Ssc ssc => SscHelpersClass ssc
sscVerifyPayload :: SscHelpersClass ssc => Tagged ssc (Either EpochIndex (MainBlockHeader ssc) -> SscPayload ssc -> Either (SscVerifyError ssc) ())

-- | Class for defining listeners in DHT <tt>SSC</tt> implementation.
class Ssc ssc => SscListenersClass ssc
sscListeners :: (SscListenersClass ssc, WorkMode ssc m) => Tagged ssc ([ListenerSpec m], OutSpecs)
sscStubListeners :: (SscListenersClass ssc, WithLogger m) => Tagged ssc ([ListenerSpec m], OutSpecs)
type LocalQuery ssc a = forall m. (MonadReader (SscLocalData ssc) m, WithLogger m) => m a
type LocalUpdate ssc a = forall m. (MonadState (SscLocalData ssc) m, WithLogger m) => m a

-- | This type class abstracts local data used for SSC. Local means that it
--   is not stored in blocks.
class Ssc ssc => SscLocalDataClass ssc

-- | Get local payload to be put into main block and for given
--   <a>SlotId</a>. If payload for given <a>SlotId</a> can't be
--   constructed, empty payload can be returned.
sscGetLocalPayloadQ :: SscLocalDataClass ssc => SlotId -> LocalQuery ssc (SscPayload ssc)

-- | Make <a>SscLocalData</a> valid for given epoch, richmen and global
--   state. of best known chain).
sscNormalizeU :: SscLocalDataClass ssc => EpochIndex -> RichmenStake -> SscGlobalState ssc -> LocalUpdate ssc ()

-- | Create new (empty) local data. We are using this function instead of
--   <tt>Default</tt> class, because it gives more flexibility. For
--   instance, one can read something from DB or get current slot.
sscNewLocalData :: (SscLocalDataClass ssc, MonadSlots m, MonadDB ssc m) => m (SscLocalData ssc)
class Ssc ssc => SscGStateClass ssc

-- | Load global state from DB by recreating it from recent blocks.
sscLoadGlobalState :: (SscGStateClass ssc, WithNodeContext ssc m, MonadDB ssc m, WithLogger m) => m (SscGlobalState ssc)

-- | Rollback application of blocks.
sscRollbackU :: SscGStateClass ssc => NewestFirst NE (Block ssc) -> SscGlobalUpdate ssc ()

-- | Verify SSC-related part of given blocks with respect to current GState
--   and apply them on success. Blocks must be from the same epoch.
sscVerifyAndApplyBlocks :: SscGStateClass ssc => RichmenStake -> OldestFirst NE (Block ssc) -> SscVerifier ssc ()

-- | Calculate <a>SharedSeed</a> for given epoch using
--   <a>SscGlobalState</a>.
sscCalculateSeedQ :: SscGStateClass ssc => EpochIndex -> SscGlobalQuery ssc (Either (SscSeedError ssc) SharedSeed)
type SscGlobalQuery ssc a = forall m. (MonadReader (SscGlobalState ssc) m, WithLogger m) => m a
type SscGlobalUpdate ssc a = forall m. (MonadState (SscGlobalState ssc) m, WithLogger m) => m a
type SscVerifier ssc a = forall m. SscVerifyMode ssc m => m a

-- | Main Shared Seed Calculation type class. Stores all needed type
--   parameters for general implementation of SSC.
class (Typeable ssc, Typeable (SscPayload ssc), Typeable (SscProof ssc), Typeable (SscSeedError ssc), Eq (SscProof ssc), Eq (SscGlobalState ssc), Show (SscProof ssc), Show (SscPayload ssc), Buildable (SscPayload ssc), Buildable (SscSeedError ssc), Buildable (SscVerifyError ssc), Buildable (SscGlobalState ssc), Bi (SscProof ssc), Bi (SscPayload ssc), NFData (SscPayload ssc), NFData (SscProof ssc)) => Ssc ssc where type SscLocalData ssc type SscPayload ssc type SscGlobalState ssc type SscProof ssc type SscSeedError ssc type SscNodeContext ssc type SscParams ssc type SscVerifyError ssc where {
    type family SscLocalData ssc;
    type family SscPayload ssc;
    type family SscGlobalState ssc;
    type family SscProof ssc;
    type family SscSeedError ssc;
    type family SscNodeContext ssc;
    type family SscParams ssc;
    type family SscVerifyError ssc;
}

-- | Create proof (for inclusion into block header) from payload
mkSscProof :: Ssc ssc => Tagged ssc (SscPayload ssc -> SscProof ssc)

-- | Create SscNodeContext
sscCreateNodeContext :: (Ssc ssc, MonadIO m) => SscParams ssc -> m (SscNodeContext ssc)

-- | Class for <tt>SSC</tt> workers.
class Ssc ssc => SscWorkersClass ssc

-- | All workers specific to SSC.
sscWorkers :: (SscWorkersClass ssc, WorkMode ssc m) => Tagged ssc ([WorkerSpec m], OutSpecs)
sscLrcConsumers :: (SscWorkersClass ssc, WorkMode ssc m) => Tagged ssc [LrcConsumer m]
type SscConstraint ssc = (Ssc ssc, SscListenersClass ssc, SscLocalDataClass ssc, SscHelpersClass ssc, SscGStateClass ssc, SscWorkersClass ssc, SecurityWorkersClass ssc)
type WorkModeSsc ssc = (SscLocalDataClass ssc, SscHelpersClass ssc)


-- | Simplified NIST beacon implementation of SSC.
module Pos.Ssc.NistBeacon

-- | Data type tag for Nist Beacon implementation of Shared Seed
--   Calculation.
data SscNistBeacon
instance GHC.Generics.Generic Pos.Ssc.NistBeacon.SscNistBeacon
instance GHC.Show.Show Pos.Ssc.NistBeacon.SscNistBeacon
instance GHC.Classes.Eq Pos.Ssc.NistBeacon.SscNistBeacon
instance Data.Text.Buildable.Buildable ()
instance Pos.Ssc.Class.Types.Ssc Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Helpers.SscHelpersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Workers.SscWorkersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Listeners.SscListenersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.LocalData.SscLocalDataClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Storage.SscGStateClass Pos.Ssc.NistBeacon.SscNistBeacon

module Pos.Ssc.Arbitrary
newtype SscPayloadDependsOnSlot ssc
SscPayloadDependsOnSlot :: (SlotId -> Gen (SscPayload ssc)) -> SscPayloadDependsOnSlot ssc
[genPayloadDependsOnSlot] :: SscPayloadDependsOnSlot ssc -> SlotId -> Gen (SscPayload ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot Pos.Ssc.NistBeacon.SscNistBeacon)

module Pos.Genesis.Arbitrary
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Genesis.Types.GenesisData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Genesis.Types.StakeDistribution


-- | Server which handles transactions.
module Pos.Txp.Listeners
txListeners :: WorkMode ssc m => ([ListenerSpec m], OutSpecs)
txStubListeners :: WithLogger m => ([ListenerSpec m], OutSpecs)
processTx :: MinTxpWorkMode ssc m => (TxId, TxAux) -> m ProcessTxRes
instance Pos.WorkMode.WorkMode ssc m => Pos.Communication.Relay.Relay m Pos.Txp.Types.Communication.TxMsgTag Pos.Types.Types.TxId Pos.Txp.Types.Communication.TxMsgContents


-- | Slotting functionality.
module Pos.Slotting

-- | <a>MonadSlotsData</a> provides access to data necessary for slotting
--   to work.
class Monad m => MonadSlotsData m where getSlottingData = lift getSlottingData waitPenultEpochEquals = lift . waitPenultEpochEquals putSlottingData = lift . putSlottingData
getSlottingData :: MonadSlotsData m => m SlottingData
waitPenultEpochEquals :: MonadSlotsData m => EpochIndex -> m ()
putSlottingData :: MonadSlotsData m => SlottingData -> m ()
getSlottingData :: (MonadSlotsData m, MonadTrans t, MonadSlotsData m', t m' ~ m) => m SlottingData
waitPenultEpochEquals :: (MonadSlotsData m, MonadTrans t, MonadSlotsData m', t m' ~ m) => EpochIndex -> m ()
putSlottingData :: (MonadSlotsData m, MonadTrans t, MonadSlotsData m', t m' ~ m) => SlottingData -> m ()

-- | Type class providing information about current slot.
class MonadSlotsData m => MonadSlots m where getCurrentSlot = lift getCurrentSlot getCurrentSlotBlocking = lift getCurrentSlotBlocking currentTimeSlotting = lift currentTimeSlotting slottingWorkers = map lift slottingWorkers getCurrentSlotInaccurate = lift getCurrentSlotInaccurate
getCurrentSlot :: MonadSlots m => m (Maybe SlotId)

-- | Blocking version of <a>getCurrentSlot</a>. This function doesn't
--   return until current slot is known.
getCurrentSlotBlocking :: MonadSlots m => m SlotId

-- | This function tries to predict current slot as accurately as it can.
--   If <tt>getCurrentTime</tt> returns unreliable time, then function
--   returns last known slot If our slotting data into DB is outdated, then
--   function tries to extrapolate slot using last know slotting data
getCurrentSlotInaccurate :: MonadSlots m => m SlotId
currentTimeSlotting :: MonadSlots m => m Timestamp
slottingWorkers :: MonadSlots m => [m ()]
getCurrentSlot :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m (Maybe SlotId)

-- | Blocking version of <a>getCurrentSlot</a>. This function doesn't
--   return until current slot is known.
getCurrentSlotBlocking :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m SlotId
currentTimeSlotting :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m Timestamp
slottingWorkers :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => [m ()]

-- | This function tries to predict current slot as accurately as it can.
--   If <tt>getCurrentTime</tt> returns unreliable time, then function
--   returns last known slot If our slotting data into DB is outdated, then
--   function tries to extrapolate slot using last know slotting data
getCurrentSlotInaccurate :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m SlotId

-- | Type aggregating run-time errors related to Slotting.
data SlottingError
SEUnknownSlotStart :: !SlotId -> SlottingError

-- | Monad transformer which provides <a>SlottingData</a> using DB.
newtype SlottingHolder m a
SlottingHolder :: ReaderT SlottingVar m a -> SlottingHolder m a
[getSlottingHolder] :: SlottingHolder m a -> ReaderT SlottingVar m a
type SlottingVar = TVar SlottingData

-- | Run USHolder using existing <a>SlottingVar</a>.
runSlottingHolder :: SlottingVar -> SlottingHolder m a -> m a

-- | Create new <a>SlottingVar</a> using data from DB.
mkSlottingVar :: MonadDB ε m => m SlottingVar

-- | Data needed for the slotting algorithm to work.
data NtpSlottingState
type NtpSlottingVar = TVar NtpSlottingState

-- | Monad transformer which implements NTP-based solution for slotting.
newtype NtpSlotting m a
NtpSlotting :: ReaderT NtpSlottingVar m a -> NtpSlotting m a
[getNtpSlotting] :: NtpSlotting m a -> ReaderT NtpSlottingVar m a
mkNtpSlottingVar :: (MonadIO m, Mockable CurrentTime m, WithLogger m, Mockable Delay m, Mockable Fork m, Mockable Throw m, Mockable Catch m) => m NtpSlottingVar
runNtpSlotting :: NtpSlottingVar -> NtpSlotting m a -> m a

-- | Data which is necessary for slotting and corresponds to a particular
--   epoch.
data EpochSlottingData
EpochSlottingData :: !Millisecond -> !Timestamp -> EpochSlottingData

-- | Slot duration actual for given epoch.
[esdSlotDuration] :: EpochSlottingData -> !Millisecond

-- | Time when epoch starts.
[esdStart] :: EpochSlottingData -> !Timestamp

-- | Data necessary for slotting to work which is basically part of GState.
data SlottingData
SlottingData :: !EpochSlottingData -> !EpochSlottingData -> !EpochIndex -> SlottingData

-- | <a>EpochSlottingData</a> for penult (i. e. <a>sdPenultEpoch</a>)
--   epoch.
[sdPenult] :: SlottingData -> !EpochSlottingData

-- | <a>EpochSlottingData</a> for last epoch. Last means 'sdPenultEpoch +
--   1'.
[sdLast] :: SlottingData -> !EpochSlottingData

-- | Penult epoch for which <a>EpochSlottingData</a> is known.
[sdPenultEpoch] :: SlottingData -> !EpochIndex

-- | Get flat id of current slot based on MonadSlots.
getCurrentSlotFlat :: MonadSlots m => m (Maybe FlatSlotId)

-- | Get timestamp when given slot starts.
getSlotStart :: MonadSlotsData m => SlotId -> m (Maybe Timestamp)

-- | Get timestamp when given slot starts empatically, which means that
--   function throws exception when slot start is unknown.
getSlotStartEmpatically :: (MonadSlotsData m, MonadThrow m) => SlotId -> m Timestamp

-- | Get last known slot duration.
getLastKnownSlotDuration :: MonadSlotsData m => m Millisecond

-- | Run given action as soon as new slot starts, passing SlotId to it.
--   This function uses Mockable and assumes consistency between MonadSlots
--   and Mockable implementations.
onNewSlot :: OnNewSlot ssc m => Bool -> (SlotId -> m ()) -> m ()
onNewSlotImpl :: forall ssc m. OnNewSlot ssc m => Bool -> Bool -> (SlotId -> m ()) -> m ()
logNewSlotWorker :: OnNewSlot ssc m => m ()

-- | Wait until system starts. This function is useful if node is launched
--   before 0-th epoch starts.
waitSystemStart :: (WithNodeContext ssc m, Mockable Delay m, WithLogger m, MonadSlots m) => m ()


-- | Re-exports of GodTossing modules.
--   
--   GodTossing is a coin tossing with guaranteed output delivery. Nodes
--   exchange commitments, openings, and shares, and in the end arrive at a
--   shared seed.
--   
--   See <a>https://eprint.iacr.org/2015/889.pdf</a> (“A Provably Secure
--   Proof-of-Stake Blockchain Protocol”), section 4 for more details.
module Pos.Ssc.GodTossing

-- | Pair of <a>Commitment</a> and <a>Opening</a>.
data CommitmentOpening
CommitmentOpening :: !Commitment -> !Opening -> CommitmentOpening
[coCommitment] :: CommitmentOpening -> !Commitment
[coOpening] :: CommitmentOpening -> !Opening

-- | Generate securely random SharedSeed.
genCommitmentAndOpening :: (MonadFail m, MonadIO m) => Threshold -> NonEmpty (AsBinary VssPublicKey) -> m (Commitment, Opening)
isCommitmentId :: SlotId -> Bool
isCommitmentIdx :: LocalSlotIndex -> Bool
isOpeningId :: SlotId -> Bool
isOpeningIdx :: LocalSlotIndex -> Bool
isSharesId :: SlotId -> Bool
isSharesIdx :: LocalSlotIndex -> Bool

-- | Make signed commitment from commitment and epoch index using secret
--   key.
mkSignedCommitment :: Bi Commitment => SecretKey -> EpochIndex -> Commitment -> SignedCommitment

-- | Convert Secret to SharedSeed.
secretToSharedSeed :: Secret -> SharedSeed

-- | Safely insert <a>SignedCommitment</a> into <a>CommitmentsMap</a>.
insertSignedCommitment :: SignedCommitment -> CommitmentsMap -> CommitmentsMap

-- | Safely delete <a>SignedCommitment</a> from <a>CommitmentsMap</a>.
deleteSignedCommitment :: StakeholderId -> CommitmentsMap -> CommitmentsMap

-- | Compute difference of two <a>CommitmentsMap</a>s.
diffCommMap :: CommitmentsMap -> CommitmentsMap -> CommitmentsMap

-- | Compute intersection of two <a>CommitmentsMap</a>s.
intersectCommMap :: CommitmentsMap -> CommitmentsMap -> CommitmentsMap

-- | Generalized version of <a>intersectCommMap</a> which makes it possible
--   to intersect with different maps.
intersectCommMapWith :: (map -> HashMap StakeholderId x) -> CommitmentsMap -> map -> CommitmentsMap

-- | Check that the VSS certificate has valid TTL: i. e. it is in
--   '[vssMinTTL, vssMaxTTL]'.
checkCertTTL :: EpochIndex -> VssCertificate -> Bool

-- | Verify signature in SignedCommitment using epoch index.
--   
--   #checkSig
verifyCommitmentSignature :: Bi Commitment => EpochIndex -> SignedCommitment -> Bool

-- | Verify SignedCommitment using public key and epoch index.
--   
--   #verifyCommitmentSignature #verifyCommitment
verifySignedCommitment :: Bi Commitment => EpochIndex -> SignedCommitment -> VerificationRes

-- | Verify that Commitment is correct.
--   
--   #verifyEncShare
verifyCommitment :: Commitment -> Bool

-- | Verify that Secret provided with Opening corresponds to given
--   commitment.
--   
--   #verifySecretProof
verifyOpening :: Commitment -> Opening -> Bool
_gpCertificates :: GtPayload -> VssCertificatesMap

-- | Construct <a>GtProof</a> from <a>GtPayload</a>.
mkGtProof :: GtPayload -> GtProof

-- | Commitment is a message generated during the first stage of
--   GodTossing. It contains encrypted shares and proof of secret.
--   Invariant which must be ensured: commShares is not empty.
data Commitment
Commitment :: !(AsBinary SecretSharingExtra) -> !(AsBinary SecretProof) -> !(HashMap (AsBinary VssPublicKey) (NonEmpty (AsBinary EncShare))) -> Commitment
[commExtra] :: Commitment -> !(AsBinary SecretSharingExtra)
[commProof] :: Commitment -> !(AsBinary SecretProof)
[commShares] :: Commitment -> !(HashMap (AsBinary VssPublicKey) (NonEmpty (AsBinary EncShare)))

-- | Signature which ensures that commitment was generated by node with
--   given public key for given epoch.
type CommitmentSignature = Signature (EpochIndex, Commitment)
type SignedCommitment = (PublicKey, Commitment, CommitmentSignature)

-- | <a>CommitmentsMap</a> is a wrapper for 'HashMap StakeholderId
--   SignedCommitment' which ensures that keys are consistent with values,
--   i. e. <a>PublicKey</a> from <a>SignedCommitment</a> corresponds to key
--   which is <a>StakeholderId</a>.
data CommitmentsMap

-- | Safe constructor of <a>CommitmentsMap</a>.
mkCommitmentsMap :: [SignedCommitment] -> CommitmentsMap

-- | Unsafe straightforward constructor of <a>CommitmentsMap</a>.
mkCommitmentsMapUnsafe :: HashMap StakeholderId SignedCommitment -> CommitmentsMap

-- | Opening reveals secret.
newtype Opening
Opening :: (AsBinary Secret) -> Opening
[getOpening] :: Opening -> (AsBinary Secret)
type OpeningsMap = HashMap StakeholderId Opening

-- | Each node generates several <tt>SharedSeed</tt>s, breaks every
--   <tt>SharedSeed</tt> into <a>Share</a>s, and sends those encrypted
--   shares to other nodes (for i-th commitment at i-th element of NonEmpty
--   list) In a <a>SharesMap</a>, for each node we collect shares which
--   said node has received and decrypted.
--   
--   Specifically, if node identified by <tt>Address</tt> X has received
--   NonEmpty list of shares from node identified by key Y, this NonEmpty
--   list will be at <tt>sharesMap ! X ! Y</tt>.
type InnerSharesMap = HashMap StakeholderId (NonEmpty (AsBinary Share))
type SharesMap = HashMap StakeholderId InnerSharesMap
type SharesDistribution = HashMap StakeholderId Word16

-- | VssCertificate allows VssPublicKey to participate in MPC. Each
--   stakeholder should create a Vss keypair, sign VSS public key with
--   signing key and send it into blockchain.
--   
--   A public key of node is included in certificate in order to enable
--   validation of it using only node's P2PKH address. Expiry epoch is last
--   epoch when certificate is valid, expiry epoch is included in
--   certificate and signature.
--   
--   Other nodes accept this certificate if it is valid and if node has
--   enough stake.
--   
--   Invariant: 'checkSig vcSigningKey (vcVssKey, vcExpiryEpoch)
--   vcSignature'.
data VssCertificate

-- | Make VssCertificate valid up to given epoch using <a>SecretKey</a> to
--   sign data.
mkVssCertificate :: SecretKey -> AsBinary VssPublicKey -> EpochIndex -> VssCertificate

-- | Recreate <a>VssCertificate</a> from its contents. This function main
--   <a>fail</a> if data is invalid.
recreateVssCertificate :: MonadFail m => AsBinary VssPublicKey -> EpochIndex -> Signature (AsBinary VssPublicKey, EpochIndex) -> PublicKey -> m VssCertificate
getCertId :: VssCertificate -> StakeholderId

-- | VssCertificatesMap contains all valid certificates collected during
--   some period of time.
type VssCertificatesMap = HashMap StakeholderId VssCertificate

-- | Safe constructor of <a>VssCertificatesMap</a>. TODO: wrap into
--   newtype.
mkVssCertificatesMap :: [VssCertificate] -> VssCertificatesMap

-- | Payload included into blocks.
data GtPayload
CommitmentsPayload :: !CommitmentsMap -> !VssCertificatesMap -> GtPayload
OpeningsPayload :: !OpeningsMap -> !VssCertificatesMap -> GtPayload
SharesPayload :: !SharesMap -> !VssCertificatesMap -> GtPayload
CertificatesPayload :: !VssCertificatesMap -> GtPayload

-- | Proof of GtPayload.
data GtProof
CommitmentsProof :: !(Hash CommitmentsMap) -> !(Hash VssCertificatesMap) -> GtProof
OpeningsProof :: !(Hash OpeningsMap) -> !(Hash VssCertificatesMap) -> GtProof
SharesProof :: !(Hash SharesMap) -> !(Hash VssCertificatesMap) -> GtProof
CertificatesProof :: !(Hash VssCertificatesMap) -> GtProof
type NodeSet = HashSet StakeholderId

-- | Data type for error during seed calculation.
data SeedError

-- | Some nodes in the <tt>OpeningsMap</tt> aren't in the set of
--   participants
ExtraneousOpenings :: !(HashSet StakeholderId) -> SeedError

-- | Some nodes in the <tt>SharesMap</tt> aren't in the set of participants
ExtraneousShares :: !(HashSet StakeholderId) -> SeedError

-- | There were no participants so a random string couldn't be generated
NoParticipants :: SeedError

-- | Commitment can't be deserialized or didn't match secret (either
--   recovered or in openings)
BrokenCommitment :: StakeholderId -> SeedError

-- | Secret couldn't be recovered, or wasn't found in either
--   <tt>OpeningsMap</tt> or <tt>SharesMap</tt>
NoSecretFound :: StakeholderId -> SeedError

-- | Secret can't be deserialized
BrokenSecret :: StakeholderId -> SeedError

-- | Share can't be deserialized
BrokenShare :: StakeholderId -> SeedError

-- | Some errors during computation of commitment distribution
CommitmentDistrError :: !Text -> SeedError
hasCommitment :: StakeholderId -> GtGlobalState -> Bool
hasOpening :: StakeholderId -> GtGlobalState -> Bool
hasShares :: StakeholderId -> GtGlobalState -> Bool
hasVssCertificate :: StakeholderId -> GtGlobalState -> Bool
verifyGtPayload :: MonadError TossVerFailure m => Either EpochIndex (MainBlockHeader ssc) -> GtPayload -> m ()

-- | Figure out the threshold (i.e. how many secret shares would be
--   required to recover each node's secret) using number of participants.
vssThreshold :: Integral a => a -> Threshold
getStableCertsPure :: EpochIndex -> VssCertData -> VssCertificatesMap

-- | Certificates in genesis represented as <a>VssCertificatesMap</a>.
genesisCertificates :: VssCertificatesMap

-- | List of <a>VssKeyPair</a> in genesis.
genesisVssKeyPairs :: [VssKeyPair]

-- | Check whether SSC data with given tag and public key can be added to
--   current local data.
sscIsDataUseful :: (WithLogger m, MonadDB SscGodTossing m, WithNodeContext kek m, MonadSlots m, MonadSscMem SscGodTossing m) => GtTag -> StakeholderId -> m Bool

-- | Process <a>SignedCommitment</a> received from network, checking it
--   against current state (global + local) and adding to local state if
--   it's valid.
sscProcessCommitment :: forall m. GtDataProcessingMode m => SignedCommitment -> m ()

-- | Process <a>Opening</a> received from network, checking it against
--   current state (global + local) and adding to local state if it's
--   valid.
sscProcessOpening :: GtDataProcessingMode m => StakeholderId -> Opening -> m ()

-- | Process <a>InnerSharesMap</a> received from network, checking it
--   against current state (global + local) and adding to local state if
--   it's valid.
sscProcessShares :: GtDataProcessingMode m => StakeholderId -> InnerSharesMap -> m ()

-- | Process <a>VssCertificate</a> received from network, checking it
--   against current state (global + local) and adding to local state if
--   it's valid.
sscProcessCertificate :: GtDataProcessingMode m => VssCertificate -> m ()

-- | Clean-up some data when new slot starts. This function is only needed
--   for garbage collection, it doesn't affect validity of local data.
--   Currently it does nothing, but maybe later we'll decide to do
--   clean-up.
localOnNewSlot :: MonadSscMem SscGodTossing m => SlotId -> m ()
data GtLocalData
GtLocalData :: !TossModifier -> !EpochIndex -> GtLocalData

-- | <a>TossModifier</a> which also serves as mempool of GT data, because
--   for GodTossing modifier and mempool are same.
[_ldModifier] :: GtLocalData -> !TossModifier

-- | Epoch for which this mempool can be used to form payload.
[_ldEpoch] :: GtLocalData -> !EpochIndex
ldModifier :: Lens' GtLocalData TossModifier
ldEpoch :: Lens' GtLocalData EpochIndex

-- | Get our commitment for given epoch if it's known.
getOurCommitment :: MonadDB SscGodTossing m => EpochIndex -> m (Maybe SignedCommitment)

-- | Get our opening corresponding for given epoch if it's known.
getOurOpening :: MonadDB SscGodTossing m => EpochIndex -> m (Maybe Opening)

-- | Put our secret for given epoch.
putOurSecret :: MonadDB SscGodTossing m => SignedCommitment -> Opening -> EpochIndex -> m ()

-- | Calculate SharedSeed. SharedSeed is a random bytestring that all nodes
--   generate together and agree on.
--   
--   TODO: do we need to check secrets' lengths? Probably not.
calculateSeed :: CommitmentsMap -> OpeningsMap -> SharesMap -> Either SeedError SharedSeed
getGlobalCerts :: (MonadSscMem SscGodTossing m, MonadIO m) => SlotId -> m VssCertificatesMap
gtGetGlobalState :: (MonadSscMem SscGodTossing m, MonadIO m) => m GtGlobalState

-- | Get stable VSS certificates for given epoch.
getStableCerts :: (MonadSscMem SscGodTossing m, MonadIO m) => EpochIndex -> m VssCertificatesMap

-- | Data type which represents shared seed calculation tag in
--   -XTypeApplication hacks with type families.
data SscGodTossing

-- | Tag corresponding to GodTossing data.
data GtTag
CommitmentMsg :: GtTag
OpeningMsg :: GtTag
SharesMsg :: GtTag
VssCertificateMsg :: GtTag

-- | Data message. Can be used to send actual data.
data GtMsgContents
MCCommitment :: !SignedCommitment -> GtMsgContents
MCOpening :: !StakeholderId -> !Opening -> GtMsgContents
MCShares :: !StakeholderId -> !InnerSharesMap -> GtMsgContents
MCVssCertificate :: !VssCertificate -> GtMsgContents

-- | GtTag appropriate for given DataMsg.
msgContentsTag :: GtMsgContents -> GtTag

-- | Global state of GodTossing, contains relevant SSC data from blocks.
data GtGlobalState
GtGlobalState :: !CommitmentsMap -> !OpeningsMap -> !SharesMap -> !VssCertData -> GtGlobalState

-- | Commitments are added during the first phase of epoch.
[_gsCommitments] :: GtGlobalState -> !CommitmentsMap

-- | Openings are added during the second phase of epoch.
[_gsOpenings] :: GtGlobalState -> !OpeningsMap

-- | Decrypted shares to be used in the third phase.
[_gsShares] :: GtGlobalState -> !SharesMap

-- | Vss certificates are added at any time if they are valid and received
--   from stakeholders.
[_gsVssCertificates] :: GtGlobalState -> !VssCertData
data GtContext
GtContext :: !VssKeyPair -> !(TVar Bool) -> GtContext

-- | Vss key pair used for MPC.
[gtcVssKeyPair] :: GtContext -> !VssKeyPair

-- | Flag which determines whether we want to participate in SSC.
[gtcParticipateSsc] :: GtContext -> !(TVar Bool)
data GtParams
GtParams :: !Bool -> !VssKeyPair -> GtParams

-- | Whether node should participate in SSC in case SSC requires
--   participation.
[gtpSscEnabled] :: GtParams -> !Bool

-- | Key pair used for secret sharing
[gtpVssKeyPair] :: GtParams -> !VssKeyPair
data GtSecretStorage
GtSecretStorage :: !SignedCommitment -> !Opening -> !EpochIndex -> GtSecretStorage

-- | Our commitment.
[gssCommitment] :: GtSecretStorage -> !SignedCommitment

-- | Corresponding opening
[gssOpening] :: GtSecretStorage -> !Opening

-- | Epoch for which this secret were generated
[gssEpoch] :: GtSecretStorage -> !EpochIndex
gsCommitments :: Lens' GtGlobalState CommitmentsMap
gsOpenings :: Lens' GtGlobalState OpeningsMap
gsShares :: Lens' GtGlobalState SharesMap
gsVssCertificates :: Lens' GtGlobalState VssCertData
createGtContext :: MonadIO m => GtParams -> m GtContext

-- | Wrapper around <a>VssCertificate</a> with TTL. Every
--   <a>VssCertificate</a> has own TTL. Wrapper supports simple
--   <a>HashMap</a> operations. Wrapper holds <a>VssCertificatesMap</a> and
--   <a>Set</a> of certificates sorted by expiry epoch.
data VssCertData
VssCertData :: !EpochOrSlot -> !VssCertificatesMap -> !(HashMap StakeholderId EpochOrSlot) -> !(Set (EpochOrSlot, StakeholderId)) -> !(Set (EpochOrSlot, StakeholderId)) -> !(Set (EpochOrSlot, (StakeholderId, EpochOrSlot, VssCertificate))) -> VssCertData

-- | Last known slot, every element of expirySlotSet &gt; lastKnownEoS
[lastKnownEoS] :: VssCertData -> !EpochOrSlot

-- | Not expired certificates
[certs] :: VssCertData -> !VssCertificatesMap

-- | Slot when certs was inserted. It is needed for deletion from
--   <tt>insSlotSet</tt> (by <a>StakeholderId</a>).
[whenInsMap] :: VssCertData -> !(HashMap StakeholderId EpochOrSlot)

-- | Set of pairs (insertion slot, address hash) Every element of
--   insSlotSet &lt;= lastKnownEoS
[whenInsSet] :: VssCertData -> !(Set (EpochOrSlot, StakeholderId))

-- | Set of pairs (expiry slot, address hash). Expiry slot is first slot
--   when certificate expires. Pairs are sorted by expiry slot (in
--   increasing order, so the oldest certificate is first element).
[whenExpire] :: VssCertData -> !(Set (EpochOrSlot, StakeholderId))

-- | Set of expired certs for current <a>lastKnownEoS</a>. We store only
--   certificates which expried no earlier than in previous epoch. Set
--   (full expired slot, (id, insertion slot, cert))
[expiredCerts] :: VssCertData -> !(Set (EpochOrSlot, (StakeholderId, EpochOrSlot, VssCertificate)))

-- | Create empty <a>VssCertData</a>.
empty :: VssCertData

-- | Remove old certificate corresponding to the specified
--   <a>StakeholderId</a> and insert new certificate.
insert :: VssCertificate -> VssCertData -> VssCertData

-- | Lookup certificate corresponding to the specified
--   <a>StakeholderId</a>.
lookup :: StakeholderId -> VssCertData -> Maybe VssCertificate

-- | Lookup expiry epoch of certificate corresponding to the specified
--   <a>StakeholderId</a>.
lookupExpiryEpoch :: StakeholderId -> VssCertData -> Maybe EpochIndex
setLastKnownSlot :: SlotId -> VssCertData -> VssCertData

-- | Set last known slot (lks). 1. If new lks is bigger than
--   <a>lastKnownEoS</a> then some expired certificates will be removed. 2.
--   If new lks is less than <a>lastKnownEoS</a> then some inserted after
--   <tt>nlks</tt> certificates will be removed (and <a>whenExpire</a>)
--   also will be updated.
setLastKnownEoS :: EpochOrSlot -> VssCertData -> VssCertData

-- | Ids of stakeholders issued certificates.
keys :: VssCertData -> [StakeholderId]

-- | Return True if the specified address hash is present in the map, False
--   otherwise.
member :: StakeholderId -> VssCertData -> Bool

-- | Convert expiry epoch of certificate to <tt>FlatSlotId</tt>.
expiryEpoch :: VssCertificate -> EpochIndex
expiryEoS :: VssCertificate -> EpochOrSlot

-- | Delete certificate corresponding to the specified
--   <a>StakeholderId</a>. This function is dangerous, because after using
--   it you can't rollback deleted certificates. Use carefully.
delete :: StakeholderId -> VssCertData -> VssCertData

-- | This function is dangerous, because after you using it you can't
--   rollback deleted certificates. Use carefully.
difference :: VssCertData -> HashMap StakeholderId a -> VssCertData

-- | Filtering the certificates. This function is dangerous, because after
--   you using it you can't rollback deleted certificates. Use carefully.
filter :: (StakeholderId -> Bool) -> VssCertData -> VssCertData


-- | Web-related part of cardano-sl.
module Pos.Web
baseDocsText :: Text
gtDocsText :: Text
type MyWorkMode ssc m = (WorkMode ssc m, SscConstraint ssc)
type WebHandler ssc = TxpLDHolder ssc (ContextHolder ssc (DBHolder ssc Production))
serveImpl :: MonadIO m => m Application -> Word16 -> m ()
nat :: forall ssc m. (MyWorkMode ssc m) => m (WebHandler ssc :~> Handler)
serveWebBase :: MyWorkMode ssc m => Word16 -> m ()
applicationBase :: MyWorkMode ssc m => m Application
serveWebGT :: MyWorkMode SscGodTossing m => Word16 -> m ()
applicationGT :: MyWorkMode SscGodTossing m => m Application


-- | Re-export of Pos.Block.Network.*
module Pos.Block.Network
announceBlock :: WorkMode ssc m => SendActions m -> MainBlockHeader ssc -> m ()
announceBlockOuts :: OutSpecs
handleHeadersCommunication :: WorkMode ssc m => ConversationActions (MsgHeaders ssc) MsgGetHeaders m -> m ()
blockListeners :: (WorkMode ssc m) => ([ListenerSpec m], OutSpecs)
blockStubListeners :: (SscHelpersClass ssc, WithLogger m) => Tagged ssc ([ListenerSpec m], OutSpecs)
retrievalWorker :: forall ssc m. (SscWorkersClass ssc, WorkMode ssc m) => (WorkerSpec m, OutSpecs)
handleUnsolicitedHeaders :: forall ssc m. (WorkMode ssc m) => NonEmpty (BlockHeader ssc) -> NodeId -> ConversationActions MsgGetHeaders (MsgHeaders ssc) m -> m ()
requestTip :: forall ssc m. (WorkMode ssc m) => NodeId -> ConversationActions MsgGetHeaders (MsgHeaders ssc) m -> m ()
requestHeaders :: forall ssc m. (WorkMode ssc m) => MsgGetHeaders -> Maybe (BlockHeader ssc) -> NodeId -> ConversationActions MsgGetHeaders (MsgHeaders ssc) m -> m ()

-- | Given nonempty list of valid blockheaders and nodeid, this function
--   will put them into download queue and they will be processed later.
--   Second argument is optional recovery mode tip -- after pack of blocks
--   is processed, next pack of headers will be requested until this header
--   hash is received.
addToBlockRequestQueue :: forall ssc m. (WorkMode ssc m) => NewestFirst NE (BlockHeader ssc) -> Maybe (BlockHeader ssc) -> NodeId -> m ()

-- | Make <tt>GetHeaders</tt> message using our main chain. This function
--   chooses appropriate <tt>from</tt> hashes and puts them into
--   <tt>GetHeaders</tt> message.
mkHeadersRequest :: WorkMode ssc m => Maybe HeaderHash -> m (Maybe MsgGetHeaders)
requestTipOuts :: OutSpecs

-- | <tt>GetHeaders</tt> message. Behaviour of the response depends on
--   particular combination of <a>mghFrom</a> and <a>mghTo</a>.
--   
--   <ul>
--   <li><a>mghTo</a> resolves to some header (let's call it <tt>top</tt>
--   for convenience) -- node's tip if it's <tt>Nothing</tt>, header with
--   hash in <tt>Just</tt> if it's <tt>Just</tt>.</li>
--   <li>If <a>mghFrom</a> is empty, then semantics is "request to return
--   header of block <tt>top</tt>".</li>
--   <li>Otherwise (if <a>mghFrom</a> isn't empty) it represents the set of
--   checkpoints. Responding node will try to iterate headers from
--   <tt>top</tt> to older until it reaches any checkpoint. If it finds
--   checkpoint <tt>c</tt>, it returns all headers in range
--   <tt>[c.next..top]</tt>. If it doesn't find any checkpoint or depth of
--   searching exceeds <tt>recoveryHeadersMessage</tt>, it will try to find
--   the newest checkpoint <tt>cc</tt> from <a>mghFrom</a> that's in main
--   chain of responding node and then return at most
--   <tt>recoveryHeadersMessage</tt> headers starting with <tt>cc</tt> as
--   the oldest one, returning headers in range <tt>l2 = [cc.next..x]</tt>
--   where <tt>x</tt> is either <tt>top</tt> (in case <tt>length l2 &lt;
--   recoveryHeadersMessage</tt>) or some arbitrary header (and length is
--   precisely <tt>recoveryHeadersMessage</tt>).</li>
--   </ul>
data MsgGetHeaders
MsgGetHeaders :: ![HeaderHash] -> !(Maybe HeaderHash) -> MsgGetHeaders
[mghFrom] :: MsgGetHeaders -> ![HeaderHash]
[mghTo] :: MsgGetHeaders -> !(Maybe HeaderHash)

-- | <tt>GetHeaders</tt> message (see protocol specification).
data MsgGetBlocks
MsgGetBlocks :: !HeaderHash -> !HeaderHash -> MsgGetBlocks
[mgbFrom] :: MsgGetBlocks -> !HeaderHash
[mgbTo] :: MsgGetBlocks -> !HeaderHash

-- | <tt>Headers</tt> message (see protocol specification).
newtype MsgHeaders ssc
MsgHeaders :: (NewestFirst NE (BlockHeader ssc)) -> MsgHeaders ssc

-- | <a>Block</a> message (see protocol specification).
--   
--   The <tt>s</tt> parameter is used for passing block size limit to
--   deserialization instances (using <a>Data.Reflection</a>). Grep for
--   <tt>reify</tt> and <tt>reflect</tt> to see usage examples.
newtype MsgBlock s ssc
MsgBlock :: (Block ssc) -> MsgBlock s ssc

module Pos.Block.Arbitrary
newtype BlockHeaderList ssc
BHL :: ([BlockHeader ssc], [PublicKey]) -> BlockHeaderList ssc
[getHeaderList] :: BlockHeaderList ssc -> ([BlockHeader ssc], [PublicKey])
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Binary.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.BlockSignature ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BodyDependsOnConsensus (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.GenericBlock (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Binary.Class.Bi Pos.Util.Binary.Raw => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Merkle.MerkleRoot Pos.Types.Types.Tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Merkle.MerkleTree Pos.Types.Types.Tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Binary.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary h => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Data.Attributes.Attributes h)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Block.Types.MainExtraHeaderData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Block.Types.MainExtraBodyData
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Binary.Raw) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Binary.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BodyDependsOnConsensus (Pos.Types.Block.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Class.GenericBlock (Pos.Types.Block.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Network.Types.MsgGetHeaders
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Network.Types.MsgGetBlocks
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Binary.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Network.Types.MsgHeaders ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Network.Types.MsgBlock s ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.BlockHeader ssc, Pos.Crypto.Signing.PublicKey)
instance Pos.Types.Block.Types.BiSsc ssc => GHC.Show.Show (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BlockHeaderList ssc)

module Pos.Security.Workers
class Ssc ssc => SecurityWorkersClass ssc
securityWorkers :: (SecurityWorkersClass ssc, WorkMode ssc m) => Tagged ssc ([WorkerSpec m], OutSpecs)
instance Pos.Security.Class.SecurityWorkersClass Pos.Ssc.GodTossing.Type.SscGodTossing
instance Pos.Security.Class.SecurityWorkersClass Pos.Ssc.NistBeacon.SscNistBeacon


-- | Whole Update System in one module :)
module Pos.Update

-- | Download and save archive update by given
--   <a>ConfirmedProposalState</a>
downloadUpdate :: WorkMode ssc m => ConfirmedProposalState -> m ()

-- | Download a file by its hash.
--   
--   Tries all servers in turn, fails if none of them work.
downloadHash :: [Text] -> Hash LByteString -> IO (Either Text LByteString)

-- | Apply chain of <i>definitely</i> valid blocks to US part of GState DB
--   and to US local data. This function assumes that no other thread
--   applies block in parallel. It also assumes that parent of oldest block
--   is current tip. If verification is done prior to application, one can
--   pass <a>PollModifier</a> obtained from verification to this function.
usApplyBlocks :: (MonadThrow m, USGlobalApplyMode ssc m) => OldestFirst NE (Block ssc) -> Maybe PollModifier -> m [SomeBatchOp]

-- | Checks whether our software can create block according to current
--   global state.
usCanCreateBlock :: (WithLogger m, WithNodeContext ssc m, MonadDB ssc m) => m Bool

-- | Revert application of given blocks to US part of GState DB and US
--   local data. The caller must ensure that the tip stored in DB is
--   <a>headerHash</a> of head.
usRollbackBlocks :: forall ssc m. USGlobalApplyMode ssc m => NewestFirst NE (Block ssc, USUndo) -> m [SomeBatchOp]

-- | Verify whether sequence of blocks can be applied to US part of current
--   GState DB. This function doesn't make pure checks, they are assumed to
--   be done earlier, most likely during objects construction.
usVerifyBlocks :: (USGlobalVerifyMode ssc m) => OldestFirst NE (Block ssc) -> m (PollModifier, OldestFirst NE USUndo)

-- | This function returns true if update proposal with given identifier
--   should be requested.
isProposalNeeded :: (MonadIO m, MonadUSMem m) => UpId -> m Bool

-- | Get update proposal with given id if it is known.
getLocalProposalNVotes :: (MonadIO m, MonadUSMem m) => UpId -> m (Maybe (UpdateProposal, [UpdateVote]))

-- | Process proposal received from network, checking it against current
--   state (global + local) and adding to local state if it's valid with
--   respect to it. If proposal is added to store, 'Right ()' is returned.
--   Otherwise 'Left err' is returned and <tt>err</tt> lets caller decide
--   whether sender could be sure that error would happen.
processProposal :: (USLocalLogicMode ssc m) => UpdateProposal -> m (Either PollVerFailure ())

-- | This function returns true if update vote proposal with given
--   identifier issued by stakeholder with given PublicKey and with given
--   decision should be requested.
isVoteNeeded :: USLocalLogicMode ssc m => UpId -> PublicKey -> Bool -> m Bool

-- | Get update vote for proposal with given id from given issuer and with
--   given decision if it is known.
getLocalVote :: (MonadIO m, MonadUSMem m) => UpId -> PublicKey -> Bool -> m (Maybe UpdateVote)

-- | Process vote received from network, checking it against current state
--   (global + local) and adding to local state if it's valid with respect
--   to it. If vote is added to store, 'Right ()' is returned. Otherwise
--   'Left err' is returned and <tt>err</tt> lets caller decide whether
--   sender could be sure that error would happen.
processVote :: (USLocalLogicMode ssc m) => UpdateVote -> m (Either PollVerFailure ())

-- | Remove local data from memory state to make it consistent with current
--   GState. This function assumes that GState is locked. It tries to leave
--   as much data as possible. It assumes that <tt>blkSemaphore</tt> is
--   taken.
usNormalize :: (USLocalLogicMode ssc m) => m ()

-- | Update memory state to make it correct for given slot.
processNewSlot :: (USLocalLogicMode ssc m) => SlotId -> m ()

-- | Prepare UpdatePayload for inclusion into new block with given SlotId.
--   This function assumes that <tt>blkSemaphore</tt> is taken and nobody
--   can apply/rollback blocks in parallel. Sometimes payload can't be
--   created. It can happen if we are trying to create block for slot which
--   has already passed, for example.
usPreparePayload :: (USLocalLogicMode ssc m) => SlotId -> m (Maybe UpdatePayload)

-- | Consumer will be called on every Richmen computation.
usLrcConsumer :: MonadDB ssc m => LrcConsumer m

-- | Reduced equivalent of <tt>MonadReader MemVar m</tt>.
class Monad m => MonadUSMem m where askUSMemVar = lift askUSMemVar

-- | Retrieve <a>MemVar</a>.
askUSMemVar :: MonadUSMem m => m MemVar

-- | Retrieve <a>MemVar</a>.
askUSMemVar :: (MonadUSMem m, MonadTrans t, MonadUSMem m', t m' ~ m) => m MemVar
askUSMemState :: MonadUSMem m => m (TVar MemState)
withUSLock :: (MonadUSMem m, MonadIO m, MonadMask m) => m a -> m a

-- | Modify MemPool using UpdatePayload and PollModifier.
--   
--   UpdatePayload is used to add new data to MemPool. Data must be
--   verified by caller. It's added directly to MemPool.
--   
--   PollModifier is used to remove or modify some data in MemPool. All
--   deleted proposals and votes for them are removed. TODO [CSL-625]
--   Deleted and modified votes from non-deleted proposals are not handled
--   properly.
modifyMemPool :: UpdatePayload -> PollModifier -> MemPool -> MemPool

-- | Trivial monad transformer based on <tt>ReaderT (MemVar)</tt>.
newtype USHolder m a
USHolder :: ReaderT MemVar m a -> USHolder m a
[getUSHolder] :: USHolder m a -> ReaderT MemVar m a

-- | Run USHolder using default (empty) MemState.
runUSHolder :: MonadIO m => USHolder m a -> m a

-- | Run USHolder using existing MemVar.
runUSHolderFromVar :: MemVar -> USHolder m a -> m a

-- | MemPool is data maintained by node to be included into block and
--   relayed to other nodes.
data MemPool
MemPool :: !UpdateProposals -> !LocalVotes -> MemPool
[mpProposals] :: MemPool -> !UpdateProposals
[mpLocalVotes] :: MemPool -> !LocalVotes
type UpdateProposals = HashMap UpId UpdateProposal
type LocalVotes = HashMap UpId (HashMap PublicKey UpdateVote)

-- | MemState contains all in-memory data necesary for Update System.
data MemState
MemState :: !SlotId -> !HeaderHash -> !MemPool -> !PollModifier -> MemState

-- | Slot for which data is valid. In reality EpochIndex should be enough,
--   but we sometimes overgeneralize things.
[msSlot] :: MemState -> !SlotId

-- | Tip for which data is valid.
[msTip] :: MemState -> !HeaderHash

-- | Pool of data to be included into block.
[msPool] :: MemState -> !MemPool

-- | Modifier of GState corresponding to <a>msPool</a>.
[msModifier] :: MemState -> !PollModifier

-- | MemVar uses concurrency primitives and stores MemState.
data MemVar
MemVar :: !(TVar MemState) -> !Lock -> MemVar

-- | MemState itself.
[mvState] :: MemVar -> !(TVar MemState)

-- | Lock for modifting MemState.
[mvLock] :: MemVar -> !Lock
mkMemState :: MemState
newMemVar :: MonadIO m => m MemVar

-- | Listeners for requests related to update system
usListeners :: (WorkMode ssc m) => ([ListenerSpec m], OutSpecs)
usStubListeners :: (WithLogger m) => ([ListenerSpec m], OutSpecs)

-- | Tag for proposal messages
data ProposalMsgTag
ProposalMsgTag :: ProposalMsgTag

-- | Tag for vote messages
data VoteMsgTag
VoteMsgTag :: VoteMsgTag

-- | Type class which provides function necessary for read-only
--   verification of US data.
class (Monad m, WithLogger m) => MonadPollRead m where getAdoptedBV = fst <$> getAdoptedBVFull getAdoptedBVData = snd <$> getAdoptedBVFull getBVState = lift . getBVState getProposedBVs = lift getProposedBVs getConfirmedBVStates = lift getConfirmedBVStates getAdoptedBVFull = lift getAdoptedBVFull getLastConfirmedSV = lift . getLastConfirmedSV hasActiveProposal = lift . hasActiveProposal getProposal = lift . getProposal getConfirmedProposals = lift getConfirmedProposals getEpochTotalStake = lift . getEpochTotalStake getRichmanStake e = lift . getRichmanStake e getOldProposals = lift . getOldProposals getDeepProposals = lift . getDeepProposals getBlockIssuerStake e = lift . getBlockIssuerStake e getSlottingData = lift getSlottingData

-- | Retrieve state of given block version.
getBVState :: MonadPollRead m => BlockVersion -> m (Maybe BlockVersionState)

-- | Retrieve all proposed block versions.
getProposedBVs :: MonadPollRead m => m [BlockVersion]

-- | Get all confirmed <a>BlockVersion</a>s and their states.
getConfirmedBVStates :: MonadPollRead m => m [(BlockVersion, BlockVersionState)]

-- | Retrieve last adopted block version and its state.
getAdoptedBVFull :: MonadPollRead m => m (BlockVersion, BlockVersionData)

-- | Get numeric component of last confirmed version of application
getLastConfirmedSV :: MonadPollRead m => ApplicationName -> m (Maybe NumSoftwareVersion)

-- | Check if given application has an active (non-confirmed) proposal
hasActiveProposal :: MonadPollRead m => ApplicationName -> m Bool

-- | Get active proposal
getProposal :: MonadPollRead m => UpId -> m (Maybe ProposalState)

-- | Get all known confirmed proposals.
getConfirmedProposals :: MonadPollRead m => m [ConfirmedProposalState]

-- | Get total stake from distribution corresponding to give epoch
getEpochTotalStake :: MonadPollRead m => EpochIndex -> m (Maybe Coin)

-- | Get stake of ricmhan corresponding to given epoch (if she is really
--   rich)
getRichmanStake :: MonadPollRead m => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Get all proposals which are in undecided state and were included into
--   block with slot less than or equal to given.
getOldProposals :: MonadPollRead m => SlotId -> m [UndecidedProposalState]

-- | Get all proposals which are in decided state and become decided deeper
--   than given <a>ChainDifficulty</a>.
getDeepProposals :: MonadPollRead m => ChainDifficulty -> m [DecidedProposalState]

-- | Get stake of issuer of one of the blocks created so far using stake
--   distribution which is stable in given epoch. Only issuer of stable
--   block can be passed to this function, otherwise <a>Nothing</a> will be
--   returned.
getBlockIssuerStake :: MonadPollRead m => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Get most recent <a>SlottingData</a>.
getSlottingData :: MonadPollRead m => m SlottingData
getAdoptedBV :: MonadPollRead m => m BlockVersion
getAdoptedBVData :: MonadPollRead m => m BlockVersionData

-- | Retrieve state of given block version.
getBVState :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => BlockVersion -> m (Maybe BlockVersionState)

-- | Retrieve all proposed block versions.
getProposedBVs :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m [BlockVersion]

-- | Get all confirmed <a>BlockVersion</a>s and their states.
getConfirmedBVStates :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m [(BlockVersion, BlockVersionState)]

-- | Retrieve last adopted block version and its state.
getAdoptedBVFull :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m (BlockVersion, BlockVersionData)

-- | Get numeric component of last confirmed version of application
getLastConfirmedSV :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => ApplicationName -> m (Maybe Word32)

-- | Check if given application has an active (non-confirmed) proposal
hasActiveProposal :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => ApplicationName -> m Bool

-- | Get active proposal
getProposal :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => UpId -> m (Maybe ProposalState)

-- | Get all known confirmed proposals.
getConfirmedProposals :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m [ConfirmedProposalState]

-- | Get total stake from distribution corresponding to give epoch
getEpochTotalStake :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => EpochIndex -> m (Maybe Coin)

-- | Get stake of ricmhan corresponding to given epoch (if she is really
--   rich)
getRichmanStake :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Get all proposals which are in undecided state and were included into
--   block with slot less than or equal to given.
getOldProposals :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => SlotId -> m [UndecidedProposalState]

-- | Get all proposals which are in decided state and become decided deeper
--   than given <a>ChainDifficulty</a>.
getDeepProposals :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => ChainDifficulty -> m [DecidedProposalState]

-- | Get stake of issuer of one of the blocks created so far using stake
--   distribution which is stable in given epoch. Only issuer of stable
--   block can be passed to this function, otherwise <a>Nothing</a> will be
--   returned.
getBlockIssuerStake :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Get most recent <a>SlottingData</a>.
getSlottingData :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m SlottingData

-- | Type class which provides function necessary for verification of US
--   data with ability to modify state.
class MonadPollRead m => MonadPoll m where putBVState pv = lift . putBVState pv delBVState = lift . delBVState setAdoptedBV = lift . setAdoptedBV setLastConfirmedSV = lift . setLastConfirmedSV delConfirmedSV = lift . delConfirmedSV addConfirmedProposal = lift . addConfirmedProposal delConfirmedProposal = lift . delConfirmedProposal addActiveProposal = lift . addActiveProposal deactivateProposal = lift . deactivateProposal setSlottingData = lift . setSlottingData

-- | Put state of BlockVersion overriding if it exists.
putBVState :: MonadPoll m => BlockVersion -> BlockVersionState -> m ()

-- | Delete BlockVersion and associated state.
delBVState :: MonadPoll m => BlockVersion -> m ()

-- | Set last adopted block version. State is taken from competing states.
setAdoptedBV :: MonadPoll m => BlockVersion -> m ()

-- | Set last confirmed version of application.
setLastConfirmedSV :: MonadPoll m => SoftwareVersion -> m ()

-- | Del last confirmed version of application.
delConfirmedSV :: MonadPoll m => ApplicationName -> m ()

-- | Add new confirmed update proposal.
addConfirmedProposal :: MonadPoll m => ConfirmedProposalState -> m ()

-- | Del confirmed update proposal (for rollback only).
delConfirmedProposal :: MonadPoll m => SoftwareVersion -> m ()

-- | Add new active proposal with its state.
addActiveProposal :: MonadPoll m => ProposalState -> m ()

-- | Delete active proposal given its name and identifier.
deactivateProposal :: MonadPoll m => UpId -> m ()

-- | Set most recent <a>SlottingData</a>.
setSlottingData :: MonadPoll m => SlottingData -> m ()

-- | Put state of BlockVersion overriding if it exists.
putBVState :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => BlockVersion -> BlockVersionState -> m ()

-- | Delete BlockVersion and associated state.
delBVState :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => BlockVersion -> m ()

-- | Set last adopted block version. State is taken from competing states.
setAdoptedBV :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => BlockVersion -> m ()

-- | Set last confirmed version of application.
setLastConfirmedSV :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => SoftwareVersion -> m ()

-- | Del last confirmed version of application.
delConfirmedSV :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => ApplicationName -> m ()

-- | Add new confirmed update proposal.
addConfirmedProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => ConfirmedProposalState -> m ()

-- | Del confirmed update proposal (for rollback only).
delConfirmedProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => SoftwareVersion -> m ()

-- | Add new active proposal with its state.
addActiveProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => ProposalState -> m ()

-- | Delete active proposal given its name and identifier.
deactivateProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => UpId -> m ()

-- | Set most recent <a>SlottingData</a>.
setSlottingData :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => SlottingData -> m ()
newtype DBPoll m a
DBPoll :: m a -> DBPoll m a
[runDBPoll] :: DBPoll m a -> m a

-- | PollVerFailure represents all possible errors which can appear in Poll
--   data verification.
data PollVerFailure
PollWrongScriptVersion :: !ScriptVersion -> !ScriptVersion -> !UpId -> PollVerFailure
[pwsvExpected] :: PollVerFailure -> !ScriptVersion
[pwsvFound] :: PollVerFailure -> !ScriptVersion
[pwsvUpId] :: PollVerFailure -> !UpId

-- | Slot duration for this block version is already known and the one we
--   saw doesn't match it
PollWrongSlotDuration :: !Millisecond -> !Millisecond -> !UpId -> PollVerFailure
[pwsdExpected] :: PollVerFailure -> !Millisecond
[pwsdFound] :: PollVerFailure -> !Millisecond
[pwsdUpId] :: PollVerFailure -> !UpId

-- | Max block size for this block version is already known and the one we
--   saw doesn't match it
PollWrongMaxBlockSize :: !Byte -> !Byte -> !UpId -> PollVerFailure
[pwmbsExpected] :: PollVerFailure -> !Byte
[pwmbsFound] :: PollVerFailure -> !Byte
[pwmbsUpId] :: PollVerFailure -> !UpId

-- | A proposal tried to increase the block size limit more than it was
--   allowed to
PollLargeMaxBlockSize :: !Byte -> !Byte -> !UpId -> PollVerFailure
[plmbsMaxPossible] :: PollVerFailure -> !Byte
[plmbsFound] :: PollVerFailure -> !Byte
[plmbsUpId] :: PollVerFailure -> !UpId
PollNotFoundScriptVersion :: !BlockVersion -> PollVerFailure
PollSmallProposalStake :: !Coin -> !Coin -> !UpId -> PollVerFailure
[pspsThreshold] :: PollVerFailure -> !Coin
[pspsActual] :: PollVerFailure -> !Coin
[pspsUpId] :: PollVerFailure -> !UpId
PollNotRichman :: !StakeholderId -> !Coin -> !(Maybe Coin) -> PollVerFailure
[pnrStakeholder] :: PollVerFailure -> !StakeholderId
[pnrThreshold] :: PollVerFailure -> !Coin
[pnrStake] :: PollVerFailure -> !(Maybe Coin)
PollUnknownProposal :: !StakeholderId -> !UpId -> PollVerFailure
[pupStakeholder] :: PollVerFailure -> !StakeholderId
[pupProposal] :: PollVerFailure -> !UpId
PollUnknownStakes :: !EpochIndex -> PollVerFailure
Poll2ndActiveProposal :: !SoftwareVersion -> PollVerFailure
PollWrongSoftwareVersion :: !(Maybe NumSoftwareVersion) -> !ApplicationName -> !NumSoftwareVersion -> !UpId -> PollVerFailure
[pwsvStored] :: PollVerFailure -> !(Maybe NumSoftwareVersion)
[pwsvApp] :: PollVerFailure -> !ApplicationName
[pwsvGiven] :: PollVerFailure -> !NumSoftwareVersion
[pwsvUpId] :: PollVerFailure -> !UpId
PollProposalIsDecided :: !UpId -> !StakeholderId -> PollVerFailure
[ppidUpId] :: PollVerFailure -> !UpId
[ppidStakeholder] :: PollVerFailure -> !StakeholderId
PollExtraRevote :: !UpId -> !StakeholderId -> !Bool -> PollVerFailure
[perUpId] :: PollVerFailure -> !UpId
[perStakeholder] :: PollVerFailure -> !StakeholderId
[perDecision] :: PollVerFailure -> !Bool
PollWrongHeaderBlockVersion :: !BlockVersion -> !BlockVersion -> PollVerFailure
[pwhpvGiven] :: PollVerFailure -> !BlockVersion
[pwhpvAdopted] :: PollVerFailure -> !BlockVersion
PollBadBlockVersion :: !UpId -> !BlockVersion -> !BlockVersion -> PollVerFailure
[pbpvUpId] :: PollVerFailure -> !UpId
[pbpvGiven] :: PollVerFailure -> !BlockVersion
[pbpvAdopted] :: PollVerFailure -> !BlockVersion
PollTooBigBlock :: !HeaderHash -> !Byte -> !Byte -> PollVerFailure
[ptbbHash] :: PollVerFailure -> !HeaderHash
[ptbbSize] :: PollVerFailure -> !Byte
[ptbbLimit] :: PollVerFailure -> !Byte
PollInternalError :: !Text -> PollVerFailure

-- | Verify UpdatePayload with respect to data provided by MonadPoll. If
--   data is valid it is also applied. Otherwise PollVerificationFailure is
--   thrown using MonadError type class. When first flag is true and
--   proposal is present, <a>genesisUpdateProposalThd</a> is checked for
--   it, otherwise it's not checked. When second argument is 'Left epoch',
--   it means that temporary payload for given slot is applied. When it is
--   'Right header', it means that payload from block with given header is
--   applied.
verifyAndApplyUSPayload :: forall ssc m. (ApplyMode m, Ssc ssc) => Bool -> Either SlotId (MainBlockHeader ssc) -> UpdatePayload -> m ()

-- | Rollback application of UpdatePayload in MonadPoll using payload
--   itself and undo data.
rollbackUS :: forall m. MonadPoll m => USUndo -> m ()

-- | Normalize given proposals and votes with respect to current Poll
--   state, i. e. remove everything that is invalid. Valid data is applied.
--   This function doesn't consider <a>genesisUpdateProposalThd</a>.
normalizePoll :: forall ssc m. (MonadPoll m, Ssc ssc) => SlotId -> UpdateProposals -> LocalVotes -> m (UpdateProposals, LocalVotes)
filterProposalsByThd :: forall m. (MonadPollRead m) => EpochIndex -> UpdateProposals -> m (UpdateProposals, HashSet UpId)

-- | Check whether block with given <a>BlockVersion</a> can be created
--   according to current Poll.
--   
--   Specifically, one of the following conditions must be true. • Given
--   block version is equal to last adopted block version. • '(major,
--   minor)' of given block version is greater than '(major, minor)' of
--   adopted block version and this block version is confirmed.
canCreateBlockBV :: MonadPollRead m => BlockVersion -> m Bool

-- | Verify that size of block doesn't exceed currently adopted limit.
verifyBlockSize :: (MonadError PollVerFailure m, MonadPollRead m) => HeaderHash -> Byte -> m ()

-- | Process creation of genesis block for given epoch.
processGenesisBlock :: (MonadError PollVerFailure m, MonadPoll m) => EpochIndex -> m ()

-- | Record the fact that main block with given version and leader has been
--   issued by for the given slot.
recordBlockIssuance :: (MonadError PollVerFailure m, MonadPoll m) => StakeholderId -> BlockVersion -> SlotId -> HeaderHash -> m ()

-- | Unite two PollModifiers. Second argument dominates, i. e. if there are
--   two confliciting modifications, the second one wins.
modifyPollModifier :: PollModifier -> PollModifier -> PollModifier
newtype RollT m a
RollT :: StateT USUndo m a -> RollT m a
[getRollT] :: RollT m a -> StateT USUndo m a
runRollT :: RollT m a -> m (a, USUndo)
execRollT :: Monad m => RollT m a -> m USUndo

-- | Monad transformer which stores PollModifier and implements writable
--   MonadPoll.
--   
--   <ul>
--   <li><i>WARNING</i> This transformer uses StateT and is intended for
--   single-threaded usage only.</li>
--   </ul>
newtype PollT m a
PollT :: StateT PollModifier m a -> PollT m a
[getPollT] :: PollT m a -> StateT PollModifier m a
runPollT :: PollModifier -> PollT m a -> m (a, PollModifier)
evalPollT :: Functor m => PollModifier -> PollT m a -> m a
execPollT :: Functor m => PollModifier -> PollT m a -> m PollModifier

-- | State of UpdateProposal which can't be classified as approved or
--   rejected.
data UndecidedProposalState
UndecidedProposalState :: !StakeholderVotes -> !UpdateProposal -> !SlotId -> !Coin -> !Coin -> !(Maybe UpsExtra) -> UndecidedProposalState

-- | Votes given for this proposal.
[upsVotes] :: UndecidedProposalState -> !StakeholderVotes

-- | Proposal itself.
[upsProposal] :: UndecidedProposalState -> !UpdateProposal

-- | SlotId from block in which update was proposed.
[upsSlot] :: UndecidedProposalState -> !SlotId

-- | Total stake of all positive votes.
[upsPositiveStake] :: UndecidedProposalState -> !Coin

-- | Total stake of all negative votes.
[upsNegativeStake] :: UndecidedProposalState -> !Coin

-- | Extra data
[upsExtra] :: UndecidedProposalState -> !(Maybe UpsExtra)

-- | State of UpdateProposal which can be classified as approved or
--   rejected.
data DecidedProposalState
DecidedProposalState :: !Bool -> !UndecidedProposalState -> !(Maybe ChainDifficulty) -> !(Maybe DpsExtra) -> DecidedProposalState

-- | Whether proposal is approved.
[dpsDecision] :: DecidedProposalState -> !Bool

-- | Corresponding UndecidedProposalState
[dpsUndecided] :: DecidedProposalState -> !UndecidedProposalState

-- | Difficulty at which this proposal became approved/rejected. Can be
--   Nothing in temporary state.
[dpsDifficulty] :: DecidedProposalState -> !(Maybe ChainDifficulty)

-- | Extra data
[dpsExtra] :: DecidedProposalState -> !(Maybe DpsExtra)

-- | State of UpdateProposal.
data ProposalState
PSUndecided :: !UndecidedProposalState -> ProposalState
PSDecided :: !DecidedProposalState -> ProposalState

-- | Extra data required by wallet, stored in UndecidedProposalState
data UpsExtra
UpsExtra :: !HeaderHash -> UpsExtra

-- | Block in which this update was proposed
[ueProposedBlk] :: UpsExtra -> !HeaderHash

-- | Extra data required by wallet, stored in DecidedProposalState.
data DpsExtra
DpsExtra :: !HeaderHash -> !Bool -> DpsExtra

-- | HeaderHash of block in which this update was approved/rejected
[deDecidedBlk] :: DpsExtra -> !HeaderHash

-- | Which way we approve/reject this update proposal: implicit or explicit
[deImplicit] :: DpsExtra -> !Bool

-- | Information about confirmed proposals stored in DB.
data ConfirmedProposalState
ConfirmedProposalState :: !UpdateProposal -> !Bool -> !HeaderHash -> !HeaderHash -> !HeaderHash -> !(Maybe HeaderHash) -> !StakeholderVotes -> !Coin -> !Coin -> ConfirmedProposalState
[cpsUpdateProposal] :: ConfirmedProposalState -> !UpdateProposal
[cpsImplicit] :: ConfirmedProposalState -> !Bool
[cpsProposed] :: ConfirmedProposalState -> !HeaderHash
[cpsDecided] :: ConfirmedProposalState -> !HeaderHash
[cpsConfirmed] :: ConfirmedProposalState -> !HeaderHash
[cpsAdopted] :: ConfirmedProposalState -> !(Maybe HeaderHash)
[cpsVotes] :: ConfirmedProposalState -> !StakeholderVotes
[cpsPositiveStake] :: ConfirmedProposalState -> !Coin
[cpsNegativeStake] :: ConfirmedProposalState -> !Coin

-- | Get <a>BlockVersion</a> from <a>ConfirmedProposalState</a>.
cpsBlockVersion :: ConfirmedProposalState -> BlockVersion

-- | Get <a>SoftwareVersion</a> from <a>ConfirmedProposalState</a>.
cpsSoftwareVersion :: ConfirmedProposalState -> SoftwareVersion
psProposal :: ProposalState -> UpdateProposal
psVotes :: ProposalState -> StakeholderVotes

-- | Make UndecidedProposalState from immutable data, i. e. SlotId and
--   UpdateProposal.
mkUProposalState :: SlotId -> UpdateProposal -> UndecidedProposalState

-- | State of BlockVersion from update proposal.
data BlockVersionState
BlockVersionState :: !BlockVersionData -> !Bool -> !(HashSet StakeholderId) -> !(HashSet StakeholderId) -> !(Maybe HeaderHash) -> !(Maybe HeaderHash) -> BlockVersionState

-- | <tt>BlockVersioData</tt> associated with this block version.
[bvsData] :: BlockVersionState -> !BlockVersionData

-- | Whether proposal with this block version is confirmed.
[bvsIsConfirmed] :: BlockVersionState -> !Bool

-- | Identifiers of stakeholders which issued stable blocks with this
--   <a>BlockVersion</a>. Stability is checked by the same rules as used in
--   LRC. That is, <a>SlotId</a> is considered. If block is created after
--   crucial slot of <tt>i</tt>-th epoch, it is not stable when 'i+1'-th
--   epoch starts.
[bvsIssuersStable] :: BlockVersionState -> !(HashSet StakeholderId)

-- | Identifiers of stakeholders which issued unstable blocks with this
--   <a>BlockVersion</a>. See description of <a>bvsIssuersStable</a> for
--   details.
[bvsIssuersUnstable] :: BlockVersionState -> !(HashSet StakeholderId)

-- | Identifier of last block which modified set of
--   <a>bvsIssuersStable</a>.
[bvsLastBlockStable] :: BlockVersionState -> !(Maybe HeaderHash)

-- | Identifier of last block which modified set of
--   <a>bvsIssuersUnstable</a>.
[bvsLastBlockUnstable] :: BlockVersionState -> !(Maybe HeaderHash)
bvsScriptVersion :: BlockVersionState -> ScriptVersion
bvsSlotDuration :: BlockVersionState -> Millisecond
bvsMaxBlockSize :: BlockVersionState -> Byte

-- | PollModifier is used in verification. It represents operation which
--   one should apply to global state to obtain result of application of
--   MemPool or blocks which are verified.
data PollModifier
PollModifier :: !(HashMap BlockVersion BlockVersionState) -> !(HashSet BlockVersion) -> !(Maybe (BlockVersion, BlockVersionData)) -> !(HashMap ApplicationName NumSoftwareVersion) -> !(HashSet ApplicationName) -> !(HashMap SoftwareVersion ConfirmedProposalState) -> !(HashSet SoftwareVersion) -> !(HashMap UpId ProposalState) -> !(HashSet UpId) -> !(HashMap ApplicationName UpId) -> !(HashMap ApplicationName UpId) -> !(Maybe SlottingData) -> PollModifier
[pmNewBVs] :: PollModifier -> !(HashMap BlockVersion BlockVersionState)
[pmDelBVs] :: PollModifier -> !(HashSet BlockVersion)
[pmAdoptedBVFull] :: PollModifier -> !(Maybe (BlockVersion, BlockVersionData))
[pmNewConfirmed] :: PollModifier -> !(HashMap ApplicationName NumSoftwareVersion)
[pmDelConfirmed] :: PollModifier -> !(HashSet ApplicationName)
[pmNewConfirmedProps] :: PollModifier -> !(HashMap SoftwareVersion ConfirmedProposalState)
[pmDelConfirmedProps] :: PollModifier -> !(HashSet SoftwareVersion)
[pmNewActiveProps] :: PollModifier -> !(HashMap UpId ProposalState)
[pmDelActiveProps] :: PollModifier -> !(HashSet UpId)
[pmNewActivePropsIdx] :: PollModifier -> !(HashMap ApplicationName UpId)
[pmDelActivePropsIdx] :: PollModifier -> !(HashMap ApplicationName UpId)
[pmSlottingData] :: PollModifier -> !(Maybe SlottingData)
pmNewBVsL :: Lens' PollModifier (HashMap BlockVersion BlockVersionState)
pmDelBVsL :: Lens' PollModifier (HashSet BlockVersion)
pmAdoptedBVFullL :: Lens' PollModifier (Maybe (BlockVersion, BlockVersionData))
pmNewConfirmedL :: Lens' PollModifier (HashMap ApplicationName NumSoftwareVersion)
pmDelConfirmedL :: Lens' PollModifier (HashSet ApplicationName)
pmNewConfirmedPropsL :: Lens' PollModifier (HashMap SoftwareVersion ConfirmedProposalState)
pmDelConfirmedPropsL :: Lens' PollModifier (HashSet SoftwareVersion)
pmNewActivePropsL :: Lens' PollModifier (HashMap UpId ProposalState)
pmDelActivePropsL :: Lens' PollModifier (HashSet UpId)
pmNewActivePropsIdxL :: Lens' PollModifier (HashMap ApplicationName UpId)
pmDelActivePropsIdxL :: Lens' PollModifier (HashMap ApplicationName UpId)
pmSlottingDataL :: Lens' PollModifier (Maybe SlottingData)

-- | Previous value of something that could be missing.
data PrevValue a
PrevValue :: a -> PrevValue a
NoExist :: PrevValue a
maybeToPrev :: Maybe a -> PrevValue a

-- | Data necessary to unapply US data.
data USUndo
USUndo :: !(HashMap BlockVersion (PrevValue BlockVersionState)) -> !(Maybe BlockVersion) -> !(HashMap UpId (PrevValue ProposalState)) -> !(HashMap ApplicationName (PrevValue NumSoftwareVersion)) -> !(HashMap SoftwareVersion (PrevValue ConfirmedProposalState)) -> USUndo
[unChangedBV] :: USUndo -> !(HashMap BlockVersion (PrevValue BlockVersionState))
[unLastAdoptedBV] :: USUndo -> !(Maybe BlockVersion)
[unChangedProps] :: USUndo -> !(HashMap UpId (PrevValue ProposalState))
[unChangedSV] :: USUndo -> !(HashMap ApplicationName (PrevValue NumSoftwareVersion))
[unChangedConfProps] :: USUndo -> !(HashMap SoftwareVersion (PrevValue ConfirmedProposalState))
unChangedSVL :: Lens' USUndo (HashMap ApplicationName (PrevValue NumSoftwareVersion))
unChangedPropsL :: Lens' USUndo (HashMap UpId (PrevValue ProposalState))
unChangedBVL :: Lens' USUndo (HashMap BlockVersion (PrevValue BlockVersionState))
unLastAdoptedBVL :: Lens' USUndo (Maybe BlockVersion)
unChangedConfPropsL :: Lens' USUndo (HashMap SoftwareVersion (PrevValue ConfirmedProposalState))

-- | Update System related workers.
usWorkers :: WorkMode ssc m => ([WorkerSpec m], OutSpecs)


-- | Re-exports of Pos.Communication.*
module Pos.Communication


-- | Module for exposing JSON instances for Cardano types
module Pos.Aeson


-- | Web part of wallet.
module Pos.Wallet.Web

-- | Servant API which provides access to wallet.
type WalletApi = ("api" :> ("get_wallet" :> (Capture "address" CAddress :> Get '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("get_wallets" :> Get '[JSON] (Either WalletError [CWallet]))) :<|> (("api" :> ("send" :> (Capture "from" CAddress :> (Capture "to" CAddress :> (Capture "amount" Coin :> Post '[JSON] (Either WalletError CTx)))))) :<|> (("api" :> ("send" :> (Capture "from" CAddress :> (Capture "to" CAddress :> (Capture "amount" Coin :> (Capture "currency" CCurrency :> (Capture "title" Text :> (Capture "description" Text :> Post '[JSON] (Either WalletError CTx))))))))) :<|> (("api" :> ("txhistory" :> (Capture "address" CAddress :> (Capture "skip" Word :> (Capture "limit" Word :> Get '[JSON] (Either WalletError ([CTx], Word))))))) :<|> (("api" :> ("search_txhistory" :> (Capture "address" CAddress :> (Capture "search" Text :> (Capture "skip" Word :> (Capture "limit" Word :> Get '[JSON] (Either WalletError ([CTx], Word)))))))) :<|> (("api" :> ("update_transaction" :> (Capture "address" CAddress :> (Capture "transaction" CTxId :> (ReqBody '[JSON] CTxMeta :> Post '[JSON] (Either WalletError ())))))) :<|> (("api" :> ("new_wallet" :> (ReqBody '[JSON] CWalletInit :> Post '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("restore_wallet" :> (ReqBody '[JSON] CWalletInit :> Post '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("update_wallet" :> (Capture "address" CAddress :> (ReqBody '[JSON] CWalletMeta :> Post '[JSON] (Either WalletError CWallet))))) :<|> (("api" :> ("delete_wallet" :> (Capture "address" CAddress :> Post '[JSON] (Either WalletError ())))) :<|> (("api" :> ("valid_address" :> (Capture "currency" CCurrency :> (Capture "address" Text :> Get '[JSON] (Either WalletError Bool))))) :<|> (("api" :> ("get_profile" :> Get '[JSON] (Either WalletError CProfile))) :<|> (("api" :> ("update_profile" :> (ReqBody '[JSON] CProfile :> Post '[JSON] (Either WalletError CProfile)))) :<|> (("api" :> ("redeem_ada" :> (ReqBody '[JSON] CWalletRedeem :> Post '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("next_update" :> Get '[JSON] (Either WalletError CUpdateInfo))) :<|> (("api" :> ("apply_update" :> Post '[JSON] (Either WalletError ()))) :<|> (("api" :> ("slot_duration" :> Get '[JSON] (Either WalletError Word))) :<|> ("api" :> ("system_version" :> Get '[JSON] (Either WalletError SoftwareVersion))))))))))))))))))))

-- | Helper Proxy.
walletApi :: Proxy WalletApi

-- | Client address
data CAddress

-- | currencies handled by client Note: Cardano does not deal with other
--   currency than ADA yet
data CCurrency
ADA :: CCurrency
BTC :: CCurrency
ETH :: CCurrency

-- | Client hash
data CHash

-- | type of transactions It can be an input <i> output </i> exchange
--   transaction CTInOut CTExMeta -- Ex == exchange
data CTType
CTIn :: CTxMeta -> CTType
CTOut :: CTxMeta -> CTType

-- | Client profile (CP) all data of client are "meta data" - that is not
--   provided by Cardano (Flow type: accountType)
data CProfile
CProfile :: Text -> Text -> Text -> CPwHash -> POSIXTime -> Text -> Text -> CProfile
[cpName] :: CProfile -> Text
[cpEmail] :: CProfile -> Text
[cpPhoneNumber] :: CProfile -> Text
[cpPwHash] :: CProfile -> CPwHash
[cpPwCreated] :: CProfile -> POSIXTime
[cpLocale] :: CProfile -> Text
[cpPicture] :: CProfile -> Text

-- | Password hash of client profile
type CPwHash = Text

-- | Client transaction (CTx) Provides all Data about a transaction needed
--   by client. It includes meta data which are not part of Cardano, too
--   (Flow type: transactionType)
data CTx
CTx :: CTxId -> Coin -> Word -> CTType -> CTx
[ctId] :: CTx -> CTxId
[ctAmount] :: CTx -> Coin
[ctConfirmations] :: CTx -> Word
[ctType] :: CTx -> CTType

-- | Client transaction id
data CTxId

-- | meta data of transactions
data CTxMeta
CTxMeta :: CCurrency -> Text -> Text -> POSIXTime -> CTxMeta
[ctmCurrency] :: CTxMeta -> CCurrency
[ctmTitle] :: CTxMeta -> Text
[ctmDescription] :: CTxMeta -> Text
[ctmDate] :: CTxMeta -> POSIXTime

-- | meta data of exchanges
data CTExMeta
CTExMeta :: CCurrency -> Text -> Text -> POSIXTime -> Text -> Text -> CAddress -> CTExMeta
[cexCurrency] :: CTExMeta -> CCurrency
[cexTitle] :: CTExMeta -> Text
[cexDescription] :: CTExMeta -> Text
[cexDate] :: CTExMeta -> POSIXTime
[cexRate] :: CTExMeta -> Text
[cexLabel] :: CTExMeta -> Text
[cexAddress] :: CTExMeta -> CAddress

-- | Client Wallet (CW) (Flow type: walletType)
data CWallet
CWallet :: !CAddress -> !Coin -> !CWalletMeta -> CWallet
[cwAddress] :: CWallet -> !CAddress
[cwAmount] :: CWallet -> !Coin
[cwMeta] :: CWallet -> !CWalletMeta

-- | A wallet can be used as personal or shared wallet
data CWalletType
CWTPersonal :: CWalletType
CWTShared :: CWalletType

-- | Meta data of CWallet Includes data which are not provided by Cardano
data CWalletMeta
CWalletMeta :: !CWalletType -> !CCurrency -> !Text -> CWalletMeta
[cwType] :: CWalletMeta -> !CWalletType
[cwCurrency] :: CWalletMeta -> !CCurrency
[cwName] :: CWalletMeta -> !Text

-- | Query data for wallet creation (wallet meta + backup phrase)
data CWalletInit
CWalletInit :: !BackupPhrase -> !CWalletMeta -> CWalletInit
[cwBackupPhrase] :: CWalletInit -> !BackupPhrase
[cwInitMeta] :: CWalletInit -> !CWalletMeta

-- | Update system data
data CUpdateInfo
CUpdateInfo :: !SoftwareVersion -> !BlockVersion -> !ScriptVersion -> !Bool -> !Int -> !Int -> !Coin -> !Coin -> CUpdateInfo
[cuiSoftwareVersion] :: CUpdateInfo -> !SoftwareVersion
[cuiBlockVesion] :: CUpdateInfo -> !BlockVersion
[cuiScriptVersion] :: CUpdateInfo -> !ScriptVersion
[cuiImplicit] :: CUpdateInfo -> !Bool
[cuiVotesFor] :: CUpdateInfo -> !Int
[cuiVotesAgainst] :: CUpdateInfo -> !Int
[cuiPositiveStake] :: CUpdateInfo -> !Coin
[cuiNegativeStake] :: CUpdateInfo -> !Coin

-- | Query data for redeem
data CWalletRedeem
CWalletRedeem :: !CAddress -> !Text -> CWalletRedeem
[crWalletId] :: CWalletRedeem -> !CAddress
[crSeed] :: CWalletRedeem -> !Text
data NotifyEvent
ConnectionOpened :: NotifyEvent

-- | NewWalletTransaction CAddress | NewTransaction
NetworkDifficultyChanged :: ChainDifficulty -> NotifyEvent
LocalDifficultyChanged :: ChainDifficulty -> NotifyEvent
ConnectedPeersChanged :: Word -> NotifyEvent
UpdateAvailable :: NotifyEvent
ConnectionClosed :: NotifyEvent

-- | transform Address into CAddress TODO: this is not complitely safe. If
--   someone changes implementation of Buildable Address. It should be
--   probably more safe to introduce `class PSSimplified` that would have
--   the same implementation has it is with Buildable Address but then
--   person will know it will probably change something for purescript.
addressToCAddress :: Address -> CAddress
cAddressToAddress :: CAddress -> Either Text Address
mkCTx :: Address -> ChainDifficulty -> TxHistoryEntry -> CTxMeta -> CTx
mkCTxId :: Text -> CTxId

-- | transform TxId into CTxId
txIdToCTxId :: TxId -> CTxId
ctTypeMeta :: CTType -> CTxMeta
txContainsTitle :: Text -> CTx -> Bool

-- | Creates <tt>CTUpdateInfo</tt> from <a>ConfirmedProposalState</a>
toCUpdateInfo :: ConfirmedProposalState -> CUpdateInfo
walletDocsText :: Text
data WalletError

-- | Some internal error.
Internal :: !Text -> WalletError
walletServeWebFull :: forall ssc. SscConstraint ssc => SendActions (RawRealMode ssc) -> Bool -> FilePath -> Bool -> Word16 -> RawRealMode ssc ()
walletServerOuts :: OutSpecs
walletServeWebLite :: SendActions WalletRealMode -> FilePath -> Bool -> Word16 -> WalletRealMode ()
walletServerOuts :: OutSpecs
type WalletWebHandler m = WalletWebSockets (WalletWebDB m)
walletApplication :: WalletWebMode ssc m => m (Server WalletApi) -> m Application
walletServer :: (Monad m, WalletWebMode ssc (WalletWebHandler m)) => SendActions m -> WalletWebHandler m (WalletWebHandler m :~> Handler) -> WalletWebHandler m (Server WalletApi)
walletServeImpl :: (MonadIO m, MonadMask m, WalletWebMode ssc (WalletWebHandler m)) => WalletWebHandler m Application -> FilePath -> Bool -> Word16 -> m ()
walletServerOuts :: OutSpecs

-- | Holder for web wallet data
data WalletWebSockets m a
type WebWalletSockets m = (MonadWalletWebSockets m, MonadIO m)

-- | MonadWalletWebSockets stands for monad which is able to get web wallet
--   sockets
class Monad m => MonadWalletWebSockets m
getWalletWebSockets :: MonadWalletWebSockets m => m ConnectionsVar
type ConnectionsVar = TVar (Maybe Connection)
initWSConnection :: MonadIO m => m ConnectionsVar
closeWSConnection :: MonadIO m => ConnectionsVar -> m ()
upgradeApplicationWS :: ConnectionsVar -> Application -> Application
notify :: WebWalletSockets m => NotifyEvent -> m ()
runWalletWS :: ConnectionsVar -> WalletWebSockets m a -> m a

-- | Holder for web wallet data
newtype WalletWebDB m a
WalletWebDB :: ReaderT WalletState m a -> WalletWebDB m a
[getWalletWebDB] :: WalletWebDB m a -> ReaderT WalletState m a

-- | Execute <a>WalletWebDB</a> action with given <a>WalletState</a>
runWalletWebDB :: WalletState -> WalletWebDB m a -> m a
getWalletState :: Monad m => WalletWebDB m WalletState
type WalletState = ExtendedState WalletStorage

-- | MonadWalletWebDB stands for monad which is able to get web wallet
--   state
class Monad m => MonadWalletWebDB m
getWalletWebState :: MonadWalletWebDB m => m WalletState

-- | Constraint for working with web wallet DB
type WebWalletModeDB m = (MonadWalletWebDB m, MonadIO m, MonadMockable m)
openState :: MonadIO m => Bool -> FilePath -> m WalletState
openMemState :: MonadIO m => m WalletState
closeState :: MonadIO m => WalletState -> m ()
getProfile :: WebWalletModeDB m => m (Maybe CProfile)
getWalletMetas :: WebWalletModeDB m => m [CWalletMeta]
getWalletMeta :: WebWalletModeDB m => CAddress -> m (Maybe CWalletMeta)
getTxMeta :: WebWalletModeDB m => CAddress -> CTxId -> m (Maybe CTxMeta)
getWalletHistory :: WebWalletModeDB m => CAddress -> m (Maybe [CTxMeta])
getUpdates :: WebWalletModeDB m => m [CUpdateInfo]
getNextUpdate :: WebWalletModeDB m => m (Maybe CUpdateInfo)
createWallet :: WebWalletModeDB m => CAddress -> CWalletMeta -> m ()
setProfile :: WebWalletModeDB m => CProfile -> m ()
setWalletMeta :: WebWalletModeDB m => CAddress -> CWalletMeta -> m ()
setWalletTransactionMeta :: WebWalletModeDB m => CAddress -> CTxId -> CTxMeta -> m ()
setWalletHistory :: WebWalletModeDB m => CAddress -> [(CTxId, CTxMeta)] -> m ()
addOnlyNewTxMeta :: WebWalletModeDB m => CAddress -> CTxId -> CTxMeta -> m ()
removeWallet :: WebWalletModeDB m => CAddress -> m ()
addUpdate :: WebWalletModeDB m => CUpdateInfo -> m ()
removeNextUpdate :: WebWalletModeDB m => m ()


-- | High level workers.
module Pos.Worker

-- | All, but in reality not all, workers used by full node.
allWorkers :: (SscWorkersClass ssc, SecurityWorkersClass ssc, WorkMode ssc m) => ([WorkerSpec m], OutSpecs)
allWorkersCount :: Int


-- | High-level code capable of running various scenarios in various modes.
module Pos.Launcher

-- | Run full node in real mode.
runNodeProduction :: forall ssc. SscConstraint ssc => RealModeResources -> ([WorkerSpec (ProductionMode ssc)], OutSpecs) -> NodeParams -> SscParams ssc -> Production ()

-- | Run full node in benchmarking node
runNodeStats :: forall ssc. SscConstraint ssc => RealModeResources -> ([WorkerSpec (StatsMode ssc)], OutSpecs) -> NodeParams -> SscParams ssc -> Production ()
stakesDistr :: DistrOption -> DistrOption -> Bool -> StakeDistribution

-- | Contains all parameters required for hierarchical logger
--   initialization.
data LoggingParams
LoggingParams :: !LoggerName -> !(Maybe FilePath) -> !(Maybe FilePath) -> !(Maybe Int) -> LoggingParams

-- | Prefix for logger, like "time-slave"
[lpRunnerTag] :: LoggingParams -> !LoggerName

-- | Prefix of path for all logs
[lpHandlerPrefix] :: LoggingParams -> !(Maybe FilePath)

-- | Path to logger configuration
[lpConfigPath] :: LoggingParams -> !(Maybe FilePath)
[lpEkgPort] :: LoggingParams -> !(Maybe Int)

-- | Contains basic &amp; networking parameters for running node.
data BaseParams
BaseParams :: !NetworkAddress -> ![DHTNode] -> !(Maybe DHTKey) -> !Bool -> !LoggingParams -> !FilePath -> BaseParams

-- | Port to run on
[bpIpPort] :: BaseParams -> !NetworkAddress

-- | Peers passed from CLI
[bpDHTPeers] :: BaseParams -> ![DHTNode]
[bpDHTKey] :: BaseParams -> !(Maybe DHTKey)
[bpDHTExplicitInitial] :: BaseParams -> !Bool

-- | Logger parameters
[bpLoggingParams] :: BaseParams -> !LoggingParams

-- | Path to kademlia dump file
[bpKademliaDump] :: BaseParams -> !FilePath

-- | Contains algorithm specific &amp; storage parameters for Node.
data NodeParams
NodeParams :: !FilePath -> !Bool -> !Timestamp -> !SecretKey -> !UserSecret -> !BaseParams -> !Utxo -> !Bool -> !(Maybe FilePath) -> ![AttackType] -> ![AttackTarget] -> !Bool -> !FilePath -> !Bool -> ![Text] -> ![Text] -> NodeParams

-- | Path to node's database.
[npDbPathM] :: NodeParams -> !FilePath

-- | <tt>True</tt> if data-base should be rebuilt
[npRebuildDb] :: NodeParams -> !Bool

-- | System start
[npSystemStart] :: NodeParams -> !Timestamp

-- | Primary secret key of node
[npSecretKey] :: NodeParams -> !SecretKey

-- | All node secret keys
[npUserSecret] :: NodeParams -> !UserSecret

-- | See <a>BaseParams</a>
[npBaseParams] :: NodeParams -> !BaseParams

-- | predefined custom utxo
[npCustomUtxo] :: NodeParams -> !Utxo

-- | <tt>True</tt> if node started as time-lord
[npTimeLord] :: NodeParams -> !Bool
[npJLFile] :: NodeParams -> !(Maybe FilePath)

-- | List of attack types used by malicious emulation
[npAttackTypes] :: NodeParams -> ![AttackType]

-- | List of targets to attack by malicious emulation
[npAttackTargets] :: NodeParams -> ![AttackTarget]

-- | Whether to propagate txs, ssc data, blocks to neighbors
[npPropagation] :: NodeParams -> !Bool

-- | Path to update installer executable, downloaded by update system
[npUpdatePath] :: NodeParams -> !FilePath

-- | If <a>True</a> then use installer update mechanism
[npUpdateWithPkg] :: NodeParams -> !Bool

-- | List of update server URLs
[npUpdateServers] :: NodeParams -> ![Text]

-- | List of report server URLs
[npReportServers] :: NodeParams -> ![Text]

-- | RawRealMode runner.
runRawRealMode :: forall ssc a. SscConstraint ssc => RealModeResources -> NodeParams -> SscParams ssc -> ListenersWithOut (RawRealMode ssc) -> OutSpecs -> ActionSpec (RawRealMode ssc) a -> Production a

-- | ProductionMode runner.
runProductionMode :: forall ssc a. (SscConstraint ssc) => RealModeResources -> NodeParams -> SscParams ssc -> (ActionSpec (ProductionMode ssc) a, OutSpecs) -> Production a

-- | StatsMode runner. [CSL-169]: spawn here additional listener, which
--   would accept stat queries can be done as part of refactoring (or
--   someone who will refactor will create new issue).
runStatsMode :: forall ssc a. (SscConstraint ssc) => RealModeResources -> NodeParams -> SscParams ssc -> (ActionSpec (StatsMode ssc) a, OutSpecs) -> Production a

-- | ServiceMode runner.
runServiceMode :: RealModeResources -> BaseParams -> ListenersWithOut ServiceMode -> OutSpecs -> ActionSpec ServiceMode a -> Production a

-- | Runs node as time-slave inside IO monad.
runTimeSlaveReal :: (SscListenersClass ssc, SscHelpersClass ssc) => Proxy ssc -> RealModeResources -> BaseParams -> Production Timestamp

-- | Runs time-lord to acquire system start.
runTimeLordReal :: LoggingParams -> Production Timestamp
addDevListeners :: MinWorkMode m => Timestamp -> ListenersWithOut m -> ListenersWithOut m
setupLoggers :: MonadIO m => LoggingParams -> m ()
bracketDHTInstance :: BaseParams -> (KademliaDHTInstance -> Production a) -> Production a
runServer :: (MonadIO m, MonadMockable m, MonadFix m, WithLogger m, MonadDHT m) => Transport -> ListenersWithOut m -> OutSpecs -> (Node m -> m t) -> (t -> m ()) -> ActionSpec m b -> m b
runServer_ :: (MonadIO m, MonadMockable m, MonadFix m, WithLogger m, MonadDHT m) => Transport -> ListenersWithOut m -> OutSpecs -> ActionSpec m b -> m b

-- | RAII for node starter.
loggerBracket :: LoggingParams -> IO a -> IO a
createTransport :: (MonadIO m, WithLogger m, Mockable Throw m) => String -> Word16 -> m Transport
bracketTransport :: BaseParams -> (Transport -> Production a) -> Production a
bracketResources :: BaseParams -> (RealModeResources -> Production a) -> IO a
data RealModeResources
RealModeResources :: Transport -> KademliaDHTInstance -> RealModeResources
[rmTransport] :: RealModeResources -> Transport
[rmDHT] :: RealModeResources -> KademliaDHTInstance

-- | Run full node in any WorkMode.
runNode :: (SscConstraint ssc, WorkMode ssc m) => ([WorkerSpec m], OutSpecs) -> (WorkerSpec m, OutSpecs)
initSemaphore :: (WorkMode ssc m) => m ()
initLrc :: WorkMode ssc m => m ()

-- | Run full node in any WorkMode.
runNode' :: (SscConstraint ssc, WorkMode ssc m) => [WorkerSpec m] -> WorkerSpec m

module Pos.Wallet
data WalletParams
WalletParams :: !(Maybe FilePath) -> !Bool -> !FilePath -> !Timestamp -> !Bool -> !BaseParams -> WalletParams
[wpDbPath] :: WalletParams -> !(Maybe FilePath)
[wpRebuildDb] :: WalletParams -> !Bool
[wpKeyFilePath] :: WalletParams -> !FilePath
[wpSystemStart] :: WalletParams -> !Timestamp
[wpGenesisKeys] :: WalletParams -> !Bool
[wpBaseParams] :: WalletParams -> !BaseParams
runRawRealWallet :: RealModeResources -> WalletParams -> ListenersWithOut WalletRealMode -> (ActionSpec WalletRealMode a, OutSpecs) -> Production a

-- | WalletMode runner
runWalletRealMode :: RealModeResources -> WalletParams -> (ActionSpec WalletRealMode a, OutSpecs) -> Production a
runWalletReal :: RealModeResources -> WalletParams -> ([WorkerSpec WalletRealMode], OutSpecs) -> Production ()
runWallet :: WalletMode ssc m => ([WorkerSpec m], OutSpecs) -> (WorkerSpec m, OutSpecs)

-- | Makes a transaction which use P2PKH addresses as a source
makePubKeyTx :: SecretKey -> TxInputs -> TxOutputs -> TxAux
makeMOfNTx :: Script -> [Maybe SecretKey] -> TxInputs -> TxOutputs -> TxAux

-- | Construct Tx using secret key and given list of desired outputs
submitTx :: TxMode ssc m => SendActions m -> SecretKey -> [DHTNode] -> [TxOutAux] -> m (Either TxError TxAux)

-- | Send the ready-to-use transaction
submitTxRaw :: MinWorkMode m => SendActions m -> [DHTNode] -> TxAux -> m ()

-- | Make a multi-transaction using given secret key and info for outputs
createTx :: Utxo -> SecretKey -> TxOutputs -> Either TxError TxAux

-- | Make a transaction, using M-of-N script as a source
createMOfNTx :: Utxo -> [(PublicKey, Maybe SecretKey)] -> TxOutputs -> Either TxError TxAux
sendTxOuts :: OutSpecs

-- | Send UpdateVote to given addresses
submitVote :: MinWorkMode m => SendActions m -> [DHTNode] -> UpdateVote -> m ()

-- | Send UpdateProposal with one positive vote to given addresses
submitUpdateProposal :: MinWorkMode m => SendActions m -> SecretKey -> [DHTNode] -> UpdateProposal -> m ()
sendVoteOuts :: OutSpecs
sendProposalOuts :: OutSpecs

-- | A class which have the methods to get state of address' balance
class Monad m => MonadBalances m where getBalance addr = unsafeIntegerToCoin . sumCoins . map (txOutValue . fst) . toList <$> getOwnUtxo addr getOwnUtxo = lift . getOwnUtxo
getOwnUtxo :: MonadBalances m => Address -> m Utxo
getBalance :: MonadBalances m => Address -> m Coin
getOwnUtxo :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Address -> m Utxo

-- | A class which have methods to get transaction history
class Monad m => MonadTxHistory m where getTxHistory = lift . getTxHistory saveTx = lift . saveTx
getTxHistory :: MonadTxHistory m => Address -> m [TxHistoryEntry]
saveTx :: MonadTxHistory m => (TxId, TxAux) -> m ()
getTxHistory :: (MonadTxHistory m, MonadTrans t, MonadTxHistory m', t m' ~ m) => Address -> m [TxHistoryEntry]
saveTx :: (MonadTxHistory m, MonadTrans t, MonadTxHistory m', t m' ~ m) => (TxId, TxAux) -> m ()
class Monad m => MonadBlockchainInfo m where networkChainDifficulty = lift networkChainDifficulty localChainDifficulty = lift localChainDifficulty blockchainSlotDuration = lift blockchainSlotDuration connectedPeers = lift connectedPeers
networkChainDifficulty :: MonadBlockchainInfo m => m ChainDifficulty
localChainDifficulty :: MonadBlockchainInfo m => m ChainDifficulty
blockchainSlotDuration :: MonadBlockchainInfo m => m Millisecond
connectedPeers :: MonadBlockchainInfo m => m Word
networkChainDifficulty :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m ChainDifficulty
localChainDifficulty :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m ChainDifficulty
blockchainSlotDuration :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m Millisecond
connectedPeers :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m Word

-- | Abstraction over getting update proposals
class Monad m => MonadUpdates m where waitForUpdate = lift waitForUpdate applyLastUpdate = lift applyLastUpdate
waitForUpdate :: MonadUpdates m => m ConfirmedProposalState
applyLastUpdate :: MonadUpdates m => m ()
waitForUpdate :: (MonadUpdates m, MonadTrans t, MonadUpdates m', t m' ~ m) => m ConfirmedProposalState
applyLastUpdate :: (MonadUpdates m, MonadTrans t, MonadUpdates m', t m' ~ m) => m ()
type TxMode ssc m = (MinWorkMode m, MonadBalances m, MonadTxHistory m, MonadMockable m, MonadMask m)
type WalletMode ssc m = (TxMode ssc m, MonadKeys m, MonadBlockchainInfo m, MonadUpdates m, WithWalletContext m, MonadDHT m, WithPeerState m)
type WalletRealMode = PeerStateHolder (KademliaDHT (KeyStorage (WalletDB (ContextHolder (LoggerNameBox Production)))))
