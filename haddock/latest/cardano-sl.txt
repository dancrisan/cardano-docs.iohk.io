-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cardano SL main implementation
--   
--   Please see README.md
@package cardano-sl
@version 0.1.0.0


-- | Common things used in <a>Arbitrary</a> and <a>Arbitrary</a>
module Pos.Util.TimeWarp

-- | Full node address.
type NetworkAddress = (ByteString, Word16)

-- | <tt>"127.0.0.1"</tt>.
localhost :: ByteString

-- | Temporal solution
currentTime :: MonadIO m => m Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
mcs :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
ms :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
sec :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
minute :: Int -> Microsecond

-- | Converts a specified time to <a>Microsecond</a>.
hour :: Int -> Microsecond


-- | Contains all Shared Seed Calculation algorithms implemented in our
--   prototype. For now only NIST Beacon and more smart algorithm known as
--   <i>Coin tossing with guaranteed output delivery</i>
--   (<tt>GodTossing</tt>).
module Pos.Ssc.SscAlgo

-- | Options for command line
data SscAlgo
GodTossingAlgo :: SscAlgo
NistBeaconAlgo :: SscAlgo
instance GHC.Classes.Eq Pos.Ssc.SscAlgo.SscAlgo
instance GHC.Show.Show Pos.Ssc.SscAlgo.SscAlgo


-- | Exceptions hierarchy in cardano-sl.
module Pos.Exception

-- | Root of exceptions in cardano-sl.
data CardanoException
CardanoException :: e -> CardanoException

-- | Helper to define sub-exception of CardanoException.
cardanoExceptionToException :: (Buildable e, Exception e) => e -> SomeException

-- | Helper to define sub-exception of CardanoException.
cardanoExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Error indicating that something really bad happened.
data CardanoFatalError
CardanoFatalError :: !Text -> CardanoFatalError
instance GHC.Show.Show Pos.Exception.CardanoFatalError
instance GHC.Show.Show Pos.Exception.CardanoException
instance GHC.Exception.Exception Pos.Exception.CardanoException
instance Data.Text.Buildable.Buildable Pos.Exception.CardanoFatalError
instance GHC.Exception.Exception Pos.Exception.CardanoFatalError


-- | Helper data type for block, tx attributes.
--   
--   Map with integer 1-byte keys, arbitrary-type polymorph values. Needed
--   primarily for partial serialization. Values are either parsed and put
--   to some constructor or left as unparsed.
module Pos.Data.Attributes

-- | Convenient wrapper for the datatype to represent it (in binary format)
--   as k-v map.
data Attributes h
Attributes :: h -> ByteString -> Attributes h

-- | Data, containing known keys (deserialized)
[attrData] :: Attributes h -> h

-- | Unparsed ByteString
[attrRemain] :: Attributes h -> ByteString

-- | Generate <a>Attributes</a> reader given mapper from keys to
--   <a>Get</a>, maximum input length and the attribute value <tt>h</tt>
--   itself.
getAttributes :: (Word8 -> h -> Maybe (Get h)) -> Word32 -> h -> Get (Attributes h)

-- | Generate <a>Put</a> given the way to serialize inner attribute value
--   into set of keys and values.
putAttributes :: (h -> [(Word8, ByteString)]) -> Attributes h -> Put
mkAttributes :: h -> Attributes h
instance Control.DeepSeq.NFData h_6989586621679108643 => Control.DeepSeq.NFData (Pos.Data.Attributes.Attributes h_6989586621679108643)
instance GHC.Generics.Generic (Pos.Data.Attributes.Attributes h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Pos.Data.Attributes.Attributes h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Pos.Data.Attributes.Attributes h)
instance GHC.Show.Show h => GHC.Show.Show (Pos.Data.Attributes.Attributes h)
instance Data.Text.Buildable.Buildable h => Data.Text.Buildable.Buildable (Pos.Data.Attributes.Attributes h)
instance Data.Hashable.Class.Hashable h => Data.Hashable.Class.Hashable (Pos.Data.Attributes.Attributes h)
instance Data.SafeCopy.SafeCopy.SafeCopy h => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Data.Attributes.Attributes h)


-- | DHT types.
module Pos.DHT.Model.Types

-- | Dummy data for DHT.
newtype DHTData
DHTData :: () -> DHTData

-- | DHTKey should be strictly 20-byte long.
newtype DHTKey
DHTKey :: HashId -> DHTKey
[hashNodeId] :: DHTKey -> HashId

-- | DHT node.
data DHTNode
DHTNode :: NetworkAddress -> DHTKey -> DHTNode
[dhtAddr] :: DHTNode -> NetworkAddress
[dhtNodeId] :: DHTNode -> DHTKey

-- | Converts <a>ByteString</a> into <a>DHTKey</a> if possible.
bytesToDHTKey :: IsString s => ByteString -> Either s DHTKey

-- | Generate random <a>DHTKey</a>.
randomDHTKey :: MonadIO m => m DHTKey
addressToNodeId :: NetworkAddress -> NodeId
addressToNodeId' :: Word32 -> NetworkAddress -> NodeId
nodeIdToAddress :: NodeId -> Maybe NetworkAddress
instance GHC.Show.Show Pos.DHT.Model.Types.DHTNode
instance GHC.Classes.Ord Pos.DHT.Model.Types.DHTNode
instance GHC.Classes.Eq Pos.DHT.Model.Types.DHTNode
instance GHC.Generics.Generic Pos.DHT.Model.Types.DHTKey
instance GHC.Classes.Ord Pos.DHT.Model.Types.DHTKey
instance GHC.Classes.Eq Pos.DHT.Model.Types.DHTKey
instance GHC.Generics.Generic Pos.DHT.Model.Types.DHTData
instance GHC.Show.Show Pos.DHT.Model.Types.DHTData
instance GHC.Classes.Ord Pos.DHT.Model.Types.DHTData
instance GHC.Classes.Eq Pos.DHT.Model.Types.DHTData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.DHT.Model.Types.DHTData
instance Data.Hashable.Class.Hashable Pos.DHT.Model.Types.DHTKey
instance Data.Text.Buildable.Buildable Pos.DHT.Model.Types.DHTKey
instance GHC.Show.Show Pos.DHT.Model.Types.DHTKey
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.DHT.Model.Types.DHTKey
instance Data.Text.Buildable.Buildable Pos.DHT.Model.Types.DHTNode
instance Data.Text.Buildable.Buildable [Pos.DHT.Model.Types.DHTNode]

module Pos.DHT.Model.Class

-- | Data type for DHT exceptions.
data DHTException
NodeDown :: DHTException
AllPeersUnavailable :: DHTException

-- | Monad for Distributed Hash Table operations.
class Monad m => MonadDHT m
joinNetwork :: MonadDHT m => [DHTNode] -> m ()

-- | Peer discovery: query DHT for random key Processing request, node will
--   discover few other nodes We return these newly discovered nodes among
--   with already known (List of known nodes is updated as well)
discoverPeers :: MonadDHT m => m [DHTNode]
getKnownPeers :: MonadDHT m => m [DHTNode]
currentNodeKey :: MonadDHT m => m DHTKey
dhtLoggerName :: MonadDHT m => Proxy m -> LoggerName

-- | Perform some action using <a>dhtLoggerName</a>.
withDhtLogger :: (HasLoggerName m, MonadDHT m) => m a -> m a
instance GHC.Show.Show Pos.DHT.Model.Class.DHTException
instance Pos.DHT.Model.Class.MonadDHT m => Pos.DHT.Model.Class.MonadDHT (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Exception.Exception Pos.DHT.Model.Class.DHTException

module Pos.DHT.Model.Util

-- | Join distributed network without throwing <a>AllPeersUnavailable</a>
--   exception.
joinNetworkNoThrow :: (MonadDHT m, Mockable Catch m, Mockable Throw m, WithLogger m) => [DHTNode] -> m ()

module Pos.DHT.Real.Types

-- | Node of <i>Kademlia DHT</i> algorithm with access to
--   <tt>KademliaDHTContext</tt>.
newtype KademliaDHT m a
KademliaDHT :: ReaderT KademliaDHTInstance m a -> KademliaDHT m a

-- | Instance of node for <i>Kademlia DHT</i> algorithm.
data KademliaDHTInstance
KademliaDHTInstance :: !DHTHandle -> !DHTKey -> ![DHTNode] -> !Bool -> !(TVar [Node DHTKey]) -> KademliaDHTInstance

-- | Instance of part of config.
data KademliaDHTInstanceConfig
KademliaDHTInstanceConfig :: !Word16 -> !(Maybe DHTKey) -> ![DHTNode] -> !Bool -> !FilePath -> KademliaDHTInstanceConfig
type DHTHandle = KademliaInstance DHTKey DHTData

-- | Class for getting KademliaDHTInstance from <a>KademliaDHT</a>
class WithKademliaDHTInstance m
getKademliaDHTInstance :: WithKademliaDHTInstance m => m KademliaDHTInstance
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Trans.Class.MonadTrans Pos.DHT.Real.Types.KademliaDHT
instance (System.Wlog.LoggerNameBox.HasLoggerName m, GHC.Base.Monad m) => System.Wlog.LoggerNameBox.HasLoggerName (Pos.DHT.Real.Types.KademliaDHT m)
instance System.Wlog.CanLog.CanLog m => System.Wlog.CanLog.CanLog (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Pos.DHT.Real.Types.KademliaDHT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTData => Network.Kademlia.Types.Serialize Pos.DHT.Model.Types.DHTData
instance Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTKey => Network.Kademlia.Types.Serialize Pos.DHT.Model.Types.DHTKey
instance GHC.Base.Monad m => Pos.DHT.Real.Types.WithKademliaDHTInstance (Pos.DHT.Real.Types.KademliaDHT m)
instance (GHC.Base.Monad m, Pos.DHT.Real.Types.WithKademliaDHTInstance m) => Pos.DHT.Real.Types.WithKademliaDHTInstance (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Base.Monad m, Pos.DHT.Real.Types.WithKademliaDHTInstance m) => Pos.DHT.Real.Types.WithKademliaDHTInstance (Control.Monad.Trans.State.Lazy.StateT a m)
instance (Mockable.Class.Mockable d m, Mockable.Class.MFunctor' d (Control.Monad.Trans.Reader.ReaderT Pos.DHT.Real.Types.KademliaDHTInstance m) m, Mockable.Class.MFunctor' d (Pos.DHT.Real.Types.KademliaDHT m) (Control.Monad.Trans.Reader.ReaderT Pos.DHT.Real.Types.KademliaDHTInstance m)) => Mockable.Class.Mockable d (Pos.DHT.Real.Types.KademliaDHT m)
instance GHC.Base.Monad m => Serokell.Util.Lens.WrappedM (Pos.DHT.Real.Types.KademliaDHT m)


-- | Types for Shared Seed calculation.
module Pos.Ssc.Class.Types

-- | Main Shared Seed Calculation type class. Stores all needed type
--   parameters for general implementation of SSC.
class (Typeable ssc, Typeable (SscPayload ssc), Typeable (SscProof ssc), Typeable (SscSeedError ssc), Eq (SscProof ssc), Show (SscProof ssc), Show (SscPayload ssc), Buildable (SscPayload ssc), Buildable (SscSeedError ssc), Buildable (SscVerifyError ssc), Buildable (SscGlobalState ssc), Bi (SscProof ssc), Bi (SscPayload ssc), Default (SscLocalData ssc)) => Ssc ssc where type SscLocalData ssc type SscPayload ssc type SscGlobalState ssc type SscProof ssc type SscSeedError ssc type SscNodeContext ssc type SscParams ssc type SscVerifyError ssc where {
    type family SscLocalData ssc;
    type family SscPayload ssc;
    type family SscGlobalState ssc;
    type family SscProof ssc;
    type family SscSeedError ssc;
    type family SscNodeContext ssc;
    type family SscParams ssc;
    type family SscVerifyError ssc;
}

-- | Create proof (for inclusion into block header) from payload
mkSscProof :: Ssc ssc => Tagged ssc (SscPayload ssc -> SscProof ssc)

-- | Create SscNodeContext
sscCreateNodeContext :: (Ssc ssc, MonadIO m) => SscParams ssc -> m (SscNodeContext ssc)


-- | Miscellaneous unclassified utility functions.
module Pos.Util

-- | Type for generating list of unique (nonrepeating) elemets.
class Nonrepeating a
nonrepeating :: Nonrepeating a => Int -> Gen [a]

-- | ArbitraryUnsafe class ~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   This class is the same as <a>Arbitrary</a>, except instances of this
--   class for stuff like public/secret keys, VSS shares, commitments etc.
--   are designed not to mimic real data as presisely as possible (using
--   OpenSSL random), but rather to be simple and efficient.
--   
--   This is especially useful for benchmarking.
--   
--   Note: we don't need <a>Generic</a> to derive instances of
--   <a>ArbitraryUnsafe</a>. We can either use one-line instance
--   declaration, or <tt>-XStandaloneDeriving</tt> or
--   <tt>-XDeriveAnyClass</tt> to write something like <tt>deriving
--   (Arbitrary, ArbitraryUnsafe)</tt>.
class ArbitraryUnsafe a where arbitraryUnsafe = arbitrary
arbitraryUnsafe :: ArbitraryUnsafe a => Gen a
arbitraryUnsafe :: (ArbitraryUnsafe a, Arbitrary a) => Gen a
makeSmall :: Gen a -> Gen a

-- | Choose a random (shuffled) subset of length n. Throws an error if
--   there's not enough elements.
sublistN :: Int -> [a] -> Gen [a]

-- | Unsafely create list of <tt>n</tt> random values to be picked (see
--   note in <a>Arbitrary</a> for explanation) Used because genSharedSecret
--   already returns a list of EncShares, making the <a>replicateM</a>
--   unneeded.
unsafeMakeList :: Text -> IO [a] -> [a]

-- | Unsafely create pool of <tt>n</tt> random values to be picked (see
--   note in <a>Arbitrary</a> for explanation)
unsafeMakePool :: Text -> Int -> IO a -> [a]

-- | Make arbitrary <a>ByteString</a> of given length.
arbitrarySizedS :: Int -> Gen ByteString

-- | Make arbitrary <a>Lazy</a> of given length.
arbitrarySizedSL :: Int -> Gen ByteString

-- | A wrapper over <a>ByteString</a> for adding type safety to
--   <a>encryptRaw</a> and friends.
data Raw

-- | Convert (Reader s) to any (MonadState s)
readerToState :: MonadState s m => Reader s a -> m a

-- | A helper for simple error handling in executables
eitherPanic :: Show a => Text -> Either a b -> b

-- | This function performs checks at compile-time for different actions.
--   May slowdown implementation. To disable such checks (especially in
--   benchmarks) one should compile with: <tt>stack build --flag
--   cardano-sl:-asserts</tt>
inAssertMode :: Applicative m => m a -> m ()

-- | Remove elements which are in <tt>b</tt> from <tt>a</tt>
diffDoubleMap :: forall k1 k2 v. (Eq k1, Eq k2, Hashable k1, Hashable k2) => HashMap k1 (HashMap k2 v) -> HashMap k1 (HashMap k2 v) -> HashMap k1 (HashMap k2 v)

-- | Create HashSet from HashMap's keys
getKeys :: HashMap k v -> HashSet k
maybeThrow :: (MonadThrow m, Exception e) => e -> Maybe a -> m a
maybeThrow' :: (Mockable Throw m, Exception e) => e -> Maybe a -> m a
allDistinct :: Ord a => [a] -> Bool
type NE = NonEmpty
neZipWith3 :: (x -> y -> z -> q) -> NonEmpty x -> NonEmpty y -> NonEmpty z -> NonEmpty q
newtype NewestFirst f a
NewestFirst :: f a -> NewestFirst f a
[getNewestFirst] :: NewestFirst f a -> f a
newtype OldestFirst f a
OldestFirst :: f a -> OldestFirst f a
[getOldestFirst] :: OldestFirst f a -> f a
toNewestFirst :: Chrono f => OldestFirst f a -> NewestFirst f a
toOldestFirst :: Chrono f => NewestFirst f a -> OldestFirst f a

-- | A helper for <a>Data.SafeCopy</a> that creates <a>getCopy</a> given a
--   <a>Binary</a> instance.
getCopyBinary :: Bi a => String -> Contained (Get a)

-- | A helper for <a>Data.SafeCopy</a> that creates <a>putCopy</a> given a
--   <a>Binary</a> instance.
putCopyBinary :: Bi a => a -> Contained Put

-- | Make lenses for a data family instance.
makeLensesData :: Name -> Name -> DecsQ

-- | A <a>magnify</a> which in <a>MonadReader</a>.
magnify' :: MonadReader s m => LensLike' (Magnified (Reader s) a) s t -> ReaderT t Identity a -> m a

-- | Lens for the head of <a>NonEmpty</a>.
--   
--   We can't use <tt>_head</tt> because it doesn't work for
--   <a>NonEmpty</a>:
--   <a>https://github.com/ekmett/lens/issues/636#issuecomment-213981096</a>.
--   Even if we could though, it wouldn't be a lens, only a traversal.
_neHead :: Lens' (NonEmpty a) a

-- | Lens for the tail of <a>NonEmpty</a>.
_neTail :: Lens' (NonEmpty a) [a]

-- | Lens for the last element of <a>NonEmpty</a>.
_neLast :: Lens' (NonEmpty a) a

-- | A <a>zoom</a> which works in <a>MonadState</a>.
--   
--   See <a>https://github.com/ekmett/lens/issues/580</a>. You might be
--   surprised but actual <a>zoom</a> doesn't work in any
--   <a>MonadState</a>, it only works in a handful of state monads and
--   their combinations defined by <tt>Zoom</tt>.
zoom' :: MonadState s m => LensLike' (Zoomed (State s) a) s t -> StateT t Identity a -> m a
data Color :: *
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color

-- | Prettify <a>Text</a> message with <a>Vivid</a> color.
colorize :: Color -> Text -> Text

-- | Write colored message, do some action, write colored message. Intended
--   for debug only.
withColoredMessages :: MonadIO m => Color -> Text -> m a -> m a

-- | Constraint for something that can be logged in parallel with other
--   action.
type CanLogInParallel m = (Mockable Delay m, Mockable Fork m, WithLogger m, Mockable Bracket m)

-- | Data type to represent waiting strategy for printing warnings if
--   action take too much time.
--   
--   <ul>
--   <li><i>LW-4</i> this probably will be moved somewhere from here</li>
--   </ul>
data WaitingDelta

-- | wait s seconds and stop execution
WaitOnce :: Second -> WaitingDelta

-- | wait s, s * 2, s * 3 , s * 4 , ... seconds
WaitLinear :: Second -> WaitingDelta

-- | wait m, m * q, m * q^2, m * q^3, ... microseconds
WaitGeometric :: Microsecond -> Double -> WaitingDelta

-- | Run action and print warning if it takes more time than expected.
logWarningLongAction :: CanLogInParallel m => WaitingDelta -> Text -> m a -> m a

-- | Specialization of <a>logWarningLongAction</a> with <a>WaitOnce</a>.
logWarningWaitOnce :: CanLogInParallel m => Second -> Text -> m a -> m a

-- | Specialization of <a>logWarningLongAction</a> with <tt>WaiLinear</tt>.
logWarningWaitLinear :: CanLogInParallel m => Second -> Text -> m a -> m a

-- | Specialization of <a>logWarningLongAction</a> with
--   <a>WaitGeometric</a> with parameter <tt>1.3</tt>. Accepts
--   <a>Second</a>.
logWarningWaitInf :: CanLogInParallel m => Second -> Text -> m a -> m a

-- | Wait random interval and then perform given action.
runWithRandomIntervals' :: (MonadIO m, Mockable Delay m) => Microsecond -> Microsecond -> m () -> m ()

-- | Wait random number of <tt>Microsecond'</tt>s between min and max.
waitRandomInterval' :: (MonadIO m, Mockable Delay m) => Microsecond -> Microsecond -> m ()

-- | Wait random interval and then perform given action.
runWithRandomIntervals :: (MonadIO m, WithLogger m, Mockable Fork m, Mockable Delay m) => Microsecond -> Microsecond -> m () -> m ()

-- | Like <a>runWithRandomIntervals</a>, but performs action immidiatelly
--   at first time.
runWithRandomIntervalsNow :: (MonadIO m, WithLogger m, Mockable Fork m, Mockable Delay m) => Microsecond -> Microsecond -> m () -> m ()

-- | Wait random number of <tt>Microsecond'</tt>s between min and max.
waitRandomInterval :: (MonadIO m, Mockable Delay m) => Microsecond -> Microsecond -> m ()

-- | Remove all items from LRU, retaining maxSize property.
clearLRU :: Ord k => LRU k v -> LRU k v

-- | See <a>SerTypes</a> for details on this types
newtype AsBinary a
AsBinary :: ByteString -> AsBinary a
[getAsBinary] :: AsBinary a -> ByteString
class AsBinaryClass a
asBinary :: AsBinaryClass a => a -> AsBinary a
fromBinary :: AsBinaryClass a => AsBinary a -> Either String a
fromBinaryM :: (AsBinaryClass a, MonadFail m) => AsBinary a -> m a

-- | Makes a span on the list, considering tail only. Predicate has list
--   head as first argument. Used to take non-null prefix that depends on
--   the first element.
spanSafe :: (a -> a -> Bool) -> NonEmpty a -> (NonEmpty a, [a])
eitherToVerRes :: Either Text a -> VerificationRes
clearMVar :: MonadIO m => MVar a -> m ()
forcePutMVar :: MonadIO m => MVar a -> a -> m ()

-- | Block until value in MVar satisfies given predicate. When value
--   satisfies, it is returned.
readMVarConditional :: (MonadIO m) => (x -> Bool) -> MVar x -> m x

-- | Read until value is equal to stored value comparing by some function.
readUntilEqualMVar :: (Eq a, MonadIO m) => (x -> a) -> MVar x -> a -> m x

-- | Block until value in TVar satisfies given predicate. When value
--   satisfies, it is returned.
readTVarConditional :: (MonadIO m) => (x -> Bool) -> TVar x -> m x

-- | Read until value is equal to stored value comparing by some function.
readUntilEqualTVar :: (Eq a, MonadIO m) => (x -> a) -> TVar x -> a -> m x
stubListenerOneMsg :: (WithLogger m, Message r, Unpackable p r, Packable p r) => Proxy r -> ListenerAction p m
stubListenerConv :: (WithLogger m, Message r, Unpackable p r, Packable p Void) => Proxy r -> ListenerAction p m
withWaitLogConv :: (CanLogInParallel m, Message snd) => NodeId -> ConversationActions snd rcv m -> ConversationActions snd rcv m
withWaitLogConvL :: (CanLogInParallel m, Message rcv) => NodeId -> ConversationActions snd rcv m -> ConversationActions snd rcv m
withWaitLog :: (CanLogInParallel m) => SendActions p m -> SendActions p m
convWithTimeLimit :: (Mockable Async m, Mockable Bracket m, Mockable Delay m, WithLogger m) => Microsecond -> NodeId -> ConversationActions snd rcv m -> ConversationActions snd rcv m
sendActionsWithTimeLimit :: (Mockable Async m, Mockable Bracket m, Mockable Delay m, WithLogger m) => Microsecond -> SendActions p m -> SendActions p m
execWithTimeLimit :: (Mockable Async m, Mockable Delay m, Mockable Bracket m) => Microsecond -> m a -> m (Maybe a)
parseIntegralSafe :: Integral a => Parser a

-- | Helper class used for Pos.Util.Relay
class NamedMessagePart a
nMessageName :: NamedMessagePart a => Proxy a -> Text
instance Data.Hashable.Class.Hashable (Pos.Util.AsBinary a)
instance GHC.Classes.Ord (Pos.Util.AsBinary a)
instance GHC.Classes.Eq (Pos.Util.AsBinary a)
instance GHC.Show.Show (Pos.Util.AsBinary a)
instance GHC.Show.Show Pos.Util.WaitingDelta
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (System.Wlog.LoggerNameBox.LoggerNameBox m)
instance Pos.Util.OldestFirst f0 a0 ~ t0 => Control.Lens.Wrapped.Rewrapped (Pos.Util.OldestFirst f1 a1) t0
instance Control.Lens.Wrapped.Wrapped (Pos.Util.OldestFirst f0 a0)
instance Control.Lens.Each.Each (f a) (f b) a b => Control.Lens.Each.Each (Pos.Util.NewestFirst f a) (Pos.Util.NewestFirst f b) a b
instance Control.Lens.Each.Each (f a) (f b) a b => Control.Lens.Each.Each (Pos.Util.OldestFirst f a) (Pos.Util.OldestFirst f b) a b
instance Containers.One (f a) => Containers.One (Pos.Util.NewestFirst f a)
instance Containers.One (f a) => Containers.One (Pos.Util.OldestFirst f a)
instance Pos.Util.Chrono []
instance Pos.Util.Chrono Data.List.NonEmpty.NonEmpty
instance Language.Haskell.TH.Syntax.Lift Serokell.Data.Memory.Units.Byte
instance Data.Aeson.Types.Class.FromJSON Serokell.Data.Memory.Units.Byte
instance Data.Aeson.Types.Class.ToJSON Serokell.Data.Memory.Units.Byte
instance Data.SafeCopy.SafeCopy.SafeCopy a => Data.SafeCopy.SafeCopy.SafeCopy (Data.List.NonEmpty.NonEmpty a)
instance Data.SafeCopy.SafeCopy.SafeCopy Data.Time.Units.Millisecond
instance Data.SafeCopy.SafeCopy.SafeCopy Data.Time.Units.Microsecond
instance (GHC.Classes.Ord k, Data.SafeCopy.SafeCopy.SafeCopy k, Data.SafeCopy.SafeCopy.SafeCopy v) => Data.SafeCopy.SafeCopy.SafeCopy (Data.Cache.LRU.Internal.LRU k v)
instance Data.SafeCopy.SafeCopy.SafeCopy (Pos.Util.AsBinary a)
instance Data.String.IsString s => Control.Monad.Fail.MonadFail (Data.Either.Either s)
instance Control.Monad.Fail.MonadFail (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Pos.Util.NewestFirst f0 a0 ~ t0 => Control.Lens.Wrapped.Rewrapped (Pos.Util.NewestFirst f1 a1) t0
instance Control.Lens.Wrapped.Wrapped (Pos.Util.NewestFirst f0 a0)
instance Test.QuickCheck.Arbitrary.Arbitrary (f a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Util.OldestFirst f a)
instance Pos.Binary.Class.Bi (f a) => Pos.Binary.Class.Bi (Pos.Util.OldestFirst f a)
instance Data.Binary.Class.Binary (f a) => Data.Binary.Class.Binary (Pos.Util.OldestFirst f a)
instance Containers.NontrivialContainer (f a) => Containers.NontrivialContainer (Pos.Util.OldestFirst f a)
instance Containers.Container (f a) => Containers.Container (Pos.Util.OldestFirst f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Pos.Util.OldestFirst f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Pos.Util.OldestFirst f)
instance GHC.Base.Functor f => GHC.Base.Functor (Pos.Util.OldestFirst f)
instance GHC.Show.Show (f a) => GHC.Show.Show (Pos.Util.OldestFirst f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Pos.Util.OldestFirst f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Pos.Util.OldestFirst f a)
instance Test.QuickCheck.Arbitrary.Arbitrary (f a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Util.NewestFirst f a)
instance Pos.Binary.Class.Bi (f a) => Pos.Binary.Class.Bi (Pos.Util.NewestFirst f a)
instance Data.Binary.Class.Binary (f a) => Data.Binary.Class.Binary (Pos.Util.NewestFirst f a)
instance Containers.NontrivialContainer (f a) => Containers.NontrivialContainer (Pos.Util.NewestFirst f a)
instance Containers.Container (f a) => Containers.Container (Pos.Util.NewestFirst f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Pos.Util.NewestFirst f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Pos.Util.NewestFirst f)
instance GHC.Base.Functor f => GHC.Base.Functor (Pos.Util.NewestFirst f)
instance GHC.Show.Show (f a) => GHC.Show.Show (Pos.Util.NewestFirst f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Pos.Util.NewestFirst f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Pos.Util.NewestFirst f a)
instance Data.SafeCopy.SafeCopy.SafeCopy Serokell.Util.Verify.VerificationRes
instance GHC.Show.Show Pos.Util.Raw
instance GHC.Classes.Ord Pos.Util.Raw
instance GHC.Classes.Eq Pos.Util.Raw
instance Pos.Binary.Class.Bi Pos.Util.Raw


-- | Re-export of Crypto modules.
module Pos.Crypto

-- | <a>PublicKey</a> with corresponding <a>SecretKey</a>.
data KeyPair
KeyPair :: PublicKey -> SecretKey -> KeyPair
[getPub] :: KeyPair -> PublicKey
[getSec] :: KeyPair -> SecretKey
data WithHash a
WithHash :: a -> Hash a -> WithHash a
[whData] :: WithHash a -> a
[whHash] :: WithHash a -> Hash a
withHash :: Bi a => a -> WithHash a
_whData :: forall a_a1ybh. Lens' (WithHash a_a1ybh) a_a1ybh

-- | Lenses for <a>WithHash</a>
_whHash :: forall a_a1ybh. Lens' (WithHash a_a1ybh) (Hash a_a1ybh)

-- | Hash wrapper with phantom type for more type-safety. Made abstract in
--   order to support different algorithms in different situations
newtype AbstractHash algo a
AbstractHash :: (Digest algo) -> AbstractHash algo a

-- | Encode hash from base64 form.
encodeAbstractHash :: forall algo a. Bi (AbstractHash algo a) => AbstractHash algo a -> Text

-- | Parses given hash in base64 form.
decodeAbstractHash :: forall algo a. Bi (AbstractHash algo a) => Text -> AbstractHash algo a

-- | Encode hash from base64 form.
encodeHash :: Bi (Hash a) => Hash a -> Text

-- | Parses given hash in base64 form.
decodeHash :: Bi (Hash a) => Text -> Hash a

-- | Encode thing as <tt>Binary</tt> data and then wrap into constructor.
abstractHash :: (HashAlgorithm algo, Bi a) => a -> AbstractHash algo a

-- | Unsafe version of abstractHash.
unsafeAbstractHash :: (HashAlgorithm algo, Bi a) => a -> AbstractHash algo b

-- | Type alias for commonly used hash
type Hash = AbstractHash Blake2s_224

-- | Specialized formatter for <a>Hash</a>.
hashHexF :: Format r (AbstractHash algo a -> r)

-- | Smart formatter for <a>Hash</a> to show only first <tt>8</tt>
--   characters of <a>Hash</a>.
shortHashF :: Format r (AbstractHash algo a -> r)

-- | Short version of <a>unsafeHash</a>.
hash :: Bi a => a -> Hash a

-- | Raw constructor application.
hashRaw :: ByteString -> Hash Raw

-- | Encode thing as <a>Bi</a> data and then wrap into constructor.
unsafeHash :: Bi a => a -> Hash b

-- | Type class for unsafe cast between hashes. You must ensure that types
--   have identical Bi instances.
class CastHash a b where castHash (AbstractHash x) = AbstractHash x
castHash :: CastHash a b => AbstractHash algo a -> AbstractHash algo b
class HashAlgorithm a

-- | You can use <a>runSecureRandom</a> on any <a>MonadRandom</a>
--   computation to make it use a Really Secure™ randomness source (that
--   is, OpenSSL).
newtype SecureRandom a
SecureRandom :: IO a -> SecureRandom a
[runSecureRandom] :: SecureRandom a -> IO a

-- | Generate a cryptographically random <a>ByteString</a> of specific
--   length.
secureRandomBS :: MonadIO m => Int -> m ByteString

-- | You can use <a>deterministic</a> on any <a>MonadRandom</a> computation
--   to make it use a seed (hopefully produced by a Really Secure™
--   randomness source). The seed has to have enough entropy to make this
--   function secure.
deterministic :: ByteString -> MonadPseudoRandom ChaChaDRG a -> a

-- | Generate a random number in range [0, n).
--   
--   We want to avoid modulo bias, so we use the arc4random_uniform
--   implementation (http:/<i>stackoverflow.com</i>a<i>20051580</i>615030).
--   Specifically, we repeatedly generate a random number in range [0, 2^x)
--   until we hit on something outside of [0, 2^x mod n), which means that
--   it'll be in range [2^x mod n, 2^x). The amount of numbers in this
--   interval is guaranteed to be divisible by n, and thus applying
--   <a>mod</a> to it will be safe.
randomNumber :: MonadRandom m => Integer -> m Integer

-- | This key is used as public key in VSS.
newtype VssPublicKey
VssPublicKey :: PublicKey -> VssPublicKey
[getVssPublicKey] :: VssPublicKey -> PublicKey

-- | This key pair is used to decrypt share generated by VSS.
newtype VssKeyPair
VssKeyPair :: KeyPair -> VssKeyPair

-- | Extract VssPublicKey from VssKeyPair.
toVssPublicKey :: VssKeyPair -> VssPublicKey

-- | Generate VssKeyPair using Really Secure™ randomness.
vssKeyGen :: MonadIO m => m VssKeyPair

-- | Generate VssKeyPair using given seed.
deterministicVssKeyGen :: ByteString -> VssKeyPair
newtype DhSecret :: *
DhSecret :: ByteString -> DhSecret
type ShareId = Integer

-- | Encrypted share which needs to be decrypted using VssKeyPair first.
newtype EncShare
EncShare :: EncryptedShare -> EncShare
[getEncShare] :: EncShare -> EncryptedShare

-- | Secret can be generated by <a>genSharedSecret</a> function along with
--   shares.
newtype Secret
Secret :: Secret -> Secret
[getSecret] :: Secret -> Secret

-- | SecretProof may be used to commit Secret without revealing it.
newtype SecretProof
SecretProof :: Proof -> SecretProof

-- | This extra data may be used to verify encrypted share.
data SecretSharingExtra
SecretSharingExtra :: !ExtraGen -> ![Commitment] -> SecretSharingExtra

-- | Shares can be used to reconstruct Secret.
newtype Share
Share :: DecryptedShare -> Share
[getShare] :: Share -> DecryptedShare
type Threshold = Integer

-- | Returns id of <a>Share</a>.
shareId :: Share -> ShareId

-- | Returns id of encrypted share.
encShareId :: EncShare -> ShareId

-- | Decrypt share using secret key. Doesn't verify if an encrypted share
--   is valid, for this you need to use verifyEncShare.
decryptShare :: MonadRandom m => VssKeyPair -> EncShare -> m Share

-- | Extract ByteString from DhSecret.
getDhSecret :: DhSecret -> ByteString

-- | Generate random secret using MonadRandom and share it between given
--   public keys.
genSharedSecret :: MonadRandom m => Threshold -> NonEmpty VssPublicKey -> m (SecretSharingExtra, Secret, SecretProof, [EncShare])

-- | Get #Threshold decrypted shares from given list, or less if there is
--   not enough.
getValidShares :: Threshold -> [(EncShare, VssPublicKey, Share)] -> [Share]

-- | Recover secret if there are enough correct shares.
recoverSecret :: Threshold -> [(EncShare, VssPublicKey, Share)] -> Maybe Secret

-- | Transform a Secret into a usable random value.
secretToDhSecret :: Secret -> DhSecret

-- | Recover Secret from shares. Assumes that number of shares is enough to
--   do it. Consider using <a>getValidShares</a> first or use
--   <a>recoverSecret</a>
unsafeRecoverSecret :: [Share] -> Secret

-- | Verify an encrypted share using SecretSharingExtra.
verifyEncShare :: SecretSharingExtra -> VssPublicKey -> EncShare -> Bool

-- | Verify that SecretProof corresponds to Secret.
verifySecretProof :: SecretSharingExtra -> Secret -> SecretProof -> Bool

-- | Verify that Share has been decrypted correctly.
verifyShare :: EncShare -> VssPublicKey -> Share -> Bool

-- | Wrapper around <a>PublicKey</a>.
newtype PublicKey
PublicKey :: PublicKey -> PublicKey

-- | Wrapper around <a>SecretKey</a>.
newtype SecretKey
SecretKey :: SecretKey -> SecretKey

-- | Generate a key pair.
keyGen :: MonadIO m => m (PublicKey, SecretKey)

-- | Create key pair deterministically from 32 bytes.
deterministicKeyGen :: ByteString -> Maybe (PublicKey, SecretKey)

-- | Generate a public key from a secret key. Fast (it just drops some
--   bytes off the secret key).
toPublic :: SecretKey -> PublicKey

-- | <a>Builder</a> for <a>PublicKey</a> to show it in base64 encoded form.
formatFullPublicKey :: PublicKey -> Builder

-- | Formatter for <a>PublicKey</a> to show it in base64.
fullPublicKeyF :: Format r (PublicKey -> r)

-- | Formatter for <a>PublicKey</a> to show it in hex.
fullPublicKeyHexF :: Format r (PublicKey -> r)

-- | Parse <a>PublicKey</a> from base64 encoded string.
parseFullPublicKey :: (Bi PublicKey) => Text -> Maybe PublicKey

-- | Wrapper around <a>Signature</a>.
newtype Signature a
Signature :: Signature -> Signature a

-- | Encode something with <tt>Binary</tt> and sign it.
sign :: Bi a => SecretKey -> a -> Signature a

-- | Verify a signature. #verifyRaw
checkSig :: Bi a => PublicKey -> a -> Signature a -> Bool

-- | Formatter for <a>Signature</a> to show it in hex.
fullSignatureHexF :: Format r (Signature a -> r)

-- | Value and signature for this value.
data Signed a
Signed :: !a -> !(Signature a) -> Signed a

-- | Value to be signed
[signedValue] :: Signed a -> !a

-- | <a>Signature</a> of <a>signedValue</a>
[signedSig] :: Signed a -> !(Signature a)

-- | Smart constructor for <a>Signed</a> data type with proper signing.
mkSigned :: (Bi a) => SecretKey -> a -> Signed a

-- | Alias for constructor.
signRaw :: SecretKey -> ByteString -> Signature Raw

-- | Verify raw <a>ByteString</a>.
verifyRaw :: PublicKey -> ByteString -> Signature Raw -> Bool

-- | Proxy certificate, made of ω + public key of delegate.
newtype ProxyCert w
ProxyCert :: Signature -> ProxyCert w
[unProxyCert] :: ProxyCert w -> Signature

-- | Proxy certificate creation from secret key of issuer, public key of
--   delegate and the message space ω.
createProxyCert :: (Bi w) => SecretKey -> PublicKey -> w -> ProxyCert w

-- | Checks if certificate is valid, given issuer pk, delegate pk and ω.
verifyProxyCert :: (Bi w) => PublicKey -> PublicKey -> w -> ProxyCert w -> Bool

-- | Convenient wrapper for secret key, that's basically ω plus
--   certificate.
data ProxySecretKey w
ProxySecretKey :: w -> PublicKey -> PublicKey -> ProxyCert w -> ProxySecretKey w
[pskOmega] :: ProxySecretKey w -> w
[pskIssuerPk] :: ProxySecretKey w -> PublicKey
[pskDelegatePk] :: ProxySecretKey w -> PublicKey
[pskCert] :: ProxySecretKey w -> ProxyCert w

-- | Creates proxy secret key
createProxySecretKey :: (Bi w) => SecretKey -> PublicKey -> w -> ProxySecretKey w

-- | Checks if proxy secret key is valid (the signature/cert inside is
--   correct).
verifyProxySecretKey :: (Bi w) => ProxySecretKey w -> Bool

-- | Delegate signature made with certificate-based permission. <tt>a</tt>
--   stays for message type used in proxy (ω in the implementation notes),
--   <tt>b</tt> for type of message signed.
data ProxySignature w a
ProxySignature :: w -> PublicKey -> ProxyCert w -> Signature -> ProxySignature w a
[pdOmega] :: ProxySignature w a -> w
[pdDelegatePk] :: ProxySignature w a -> PublicKey
[pdCert] :: ProxySignature w a -> ProxyCert w
[pdSig] :: ProxySignature w a -> Signature

-- | Make a proxy delegate signature with help of certificate. If the
--   delegate secret key passed doesn't pair with delegate public key in
--   certificate inside, we panic. Please check this condition outside of
--   this function.
proxySign :: (Bi a) => SecretKey -> ProxySecretKey w -> a -> ProxySignature w a

-- | Verify delegated signature given issuer's pk, signature, message space
--   predicate and message itself.
proxyVerify :: (Bi w, Bi a) => PublicKey -> ProxySignature w a -> (w -> Bool) -> a -> Bool


-- | Merkle tree implementation.
--   
--   See <a>https://tools.ietf.org/html/rfc6962</a>.
module Pos.Merkle

-- | Data type for root of merkle tree.
newtype MerkleRoot a
MerkleRoot :: Hash Raw -> MerkleRoot a

-- | returns root <a>Hash</a> of Merkle Tree
[getMerkleRoot] :: MerkleRoot a -> Hash Raw

-- | Straightforward merkle tree representation in Haskell.
data MerkleTree a
MerkleEmpty :: MerkleTree a
MerkleTree :: Word32 -> (MerkleNode a) -> MerkleTree a

-- | Returns root of merkle tree.
mtRoot :: MerkleTree a -> MerkleRoot a

-- | Smart constructor for <a>MerkleTree</a>.
mkMerkleTree :: Bi a => [a] -> MerkleTree a
data MerkleNode a
MerkleBranch :: MerkleRoot a -> MerkleNode a -> MerkleNode a -> MerkleNode a
[mRoot] :: MerkleNode a -> MerkleRoot a
[mLeft] :: MerkleNode a -> MerkleNode a
[mRight] :: MerkleNode a -> MerkleNode a
MerkleLeaf :: MerkleRoot a -> a -> MerkleNode a
[mRoot] :: MerkleNode a -> MerkleRoot a
[mVal] :: MerkleNode a -> a
mkBranch :: MerkleNode a -> MerkleNode a -> MerkleNode a
mkLeaf :: Bi a => a -> MerkleNode a
instance Data.SafeCopy.SafeCopy.SafeCopy a0 => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Merkle.MerkleTree a0)
instance Data.SafeCopy.SafeCopy.SafeCopy a0 => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Merkle.MerkleNode a0)
instance GHC.Generics.Generic (Pos.Merkle.MerkleTree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Pos.Merkle.MerkleTree a)
instance GHC.Generics.Generic (Pos.Merkle.MerkleNode a)
instance GHC.Show.Show a => GHC.Show.Show (Pos.Merkle.MerkleNode a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Pos.Merkle.MerkleNode a)
instance Data.SafeCopy.SafeCopy.SafeCopy a0 => Data.SafeCopy.SafeCopy.SafeCopy (Pos.Merkle.MerkleRoot a0)
instance Data.Foldable.Foldable Pos.Merkle.MerkleTree
instance GHC.Show.Show a => GHC.Show.Show (Pos.Merkle.MerkleTree a)
instance Data.Foldable.Foldable Pos.Merkle.MerkleNode
instance Data.ByteArray.Types.ByteArrayAccess (Pos.Merkle.MerkleRoot a)
instance GHC.Generics.Generic (Pos.Merkle.MerkleRoot a)
instance GHC.Classes.Ord (Pos.Merkle.MerkleRoot a)
instance GHC.Classes.Eq (Pos.Merkle.MerkleRoot a)
instance GHC.Show.Show (Pos.Merkle.MerkleRoot a)

module Pos.Script.Type

-- | A script for inclusion into a transaction.
data Script

-- | Serialized script
Script :: ScriptVersion -> LByteString -> Script

-- | Version
[scrVersion] :: Script -> ScriptVersion
[scrScript] :: Script -> LByteString

-- | Deserialized script (i.e. an AST), version 0.
type Script_v0 = Program

-- | Version of script
type ScriptVersion = Word16
instance GHC.Show.Show (f PlutusCore.Term.PatternF) => GHC.Show.Show (PlutusCore.Term.PatternF (f PlutusCore.Term.PatternF))
instance GHC.Show.Show r => GHC.Show.Show (PlutusCore.Term.ClauseF r)
instance Language.Haskell.TH.Syntax.Lift Utils.Vars.FreeVar
instance Language.Haskell.TH.Syntax.Lift Utils.Vars.MetaVar
instance Language.Haskell.TH.Syntax.Lift Utils.Vars.BoundVar
instance Language.Haskell.TH.Syntax.Lift PlutusTypes.Type.TyConSig
instance Language.Haskell.TH.Syntax.Lift PlutusTypes.ConSig.ConSig
instance Language.Haskell.TH.Syntax.Lift PlutusTypes.Type.PolymorphicType
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Utils.Names.Sourced a)
instance Language.Haskell.TH.Syntax.Lift Utils.ABT.Variable
instance Language.Haskell.TH.Syntax.Lift (f (Utils.ABT.Scope f)) => Language.Haskell.TH.Syntax.Lift (Utils.ABT.ABT f)
instance Language.Haskell.TH.Syntax.Lift (f (Utils.ABT.Scope f)) => Language.Haskell.TH.Syntax.Lift (Utils.ABT.Scope f)
instance Language.Haskell.TH.Syntax.Lift r => Language.Haskell.TH.Syntax.Lift (PlutusCore.Term.ClauseF r)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (PlutusCore.Term.TermF a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (PlutusCore.Term.PatternF a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (PlutusTypes.Type.TypeF a)
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Term.PrimData
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Program.Program
instance Data.Functor.Classes.Eq1 PlutusTypes.Type.TypeF
instance Data.Binary.Class.Binary Utils.Vars.FreeVar
instance Data.Binary.Class.Binary Utils.Vars.MetaVar
instance Data.Binary.Class.Binary Utils.Vars.BoundVar
instance Data.Binary.Class.Binary PlutusTypes.Type.TyConSig
instance Data.Binary.Class.Binary PlutusTypes.ConSig.ConSig
instance Data.Binary.Class.Binary PlutusTypes.Type.PolymorphicType
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Utils.Names.Sourced a)
instance Data.Binary.Class.Binary Utils.ABT.Variable
instance Data.Binary.Class.Binary (f (Utils.ABT.Scope f)) => Data.Binary.Class.Binary (Utils.ABT.ABT f)
instance Data.Binary.Class.Binary (f (Utils.ABT.Scope f)) => Data.Binary.Class.Binary (Utils.ABT.Scope f)
instance Data.Binary.Class.Binary r => Data.Binary.Class.Binary (PlutusCore.Term.ClauseF r)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (PlutusCore.Term.TermF a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (PlutusCore.Term.PatternF a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (PlutusTypes.Type.TypeF a)
instance Data.Binary.Class.Binary PlutusCore.Term.PrimData
instance Data.Binary.Class.Binary PlutusCore.Program.Program
instance Control.DeepSeq.NFData Utils.Vars.FreeVar
instance Control.DeepSeq.NFData Utils.Vars.MetaVar
instance Control.DeepSeq.NFData Utils.Vars.BoundVar
instance Control.DeepSeq.NFData PlutusTypes.Type.TyConSig
instance Control.DeepSeq.NFData PlutusTypes.ConSig.ConSig
instance Control.DeepSeq.NFData PlutusTypes.Type.PolymorphicType
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Utils.Names.Sourced a)
instance Control.DeepSeq.NFData Utils.ABT.Variable
instance Control.DeepSeq.NFData (f (Utils.ABT.Scope f)) => Control.DeepSeq.NFData (Utils.ABT.ABT f)
instance Control.DeepSeq.NFData (f (Utils.ABT.Scope f)) => Control.DeepSeq.NFData (Utils.ABT.Scope f)
instance Control.DeepSeq.NFData r => Control.DeepSeq.NFData (PlutusCore.Term.ClauseF r)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Term.TermF a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Term.PatternF a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusTypes.Type.TypeF a)
instance Control.DeepSeq.NFData PlutusCore.Term.PrimData
instance Control.DeepSeq.NFData PlutusCore.Program.Program
instance Pos.Binary.Class.Bi PlutusCore.Term.Term => Data.SafeCopy.SafeCopy.SafeCopy PlutusCore.Term.Term
instance Pos.Binary.Class.Bi PlutusCore.Program.Program => Data.SafeCopy.SafeCopy.SafeCopy PlutusCore.Program.Program
instance Data.Hashable.Class.Hashable PlutusCore.Term.Term
instance Data.Hashable.Class.Hashable PlutusCore.Program.Program
instance Data.Functor.Classes.Eq1 PlutusCore.Term.TermF
instance Data.Functor.Classes.Eq1 PlutusCore.Term.ClauseF
instance Data.Functor.Classes.Eq1 PlutusCore.Term.PatternF
instance GHC.Show.Show PlutusCore.Term.PrimData
instance (GHC.Show.Show a, GHC.Show.Show (PlutusCore.Term.ClauseF a)) => GHC.Show.Show (PlutusCore.Term.TermF a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (PlutusCore.Term.ClauseF a)) => GHC.Classes.Eq (PlutusCore.Term.TermF a)
instance GHC.Classes.Eq PlutusTypes.Type.TyConSig
instance GHC.Classes.Eq PlutusTypes.ConSig.ConSig
instance GHC.Classes.Eq PlutusTypes.Type.PolymorphicType
instance GHC.Classes.Eq PlutusCore.Program.Program
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Script.Type.Script
instance GHC.Generics.Generic Pos.Script.Type.Script
instance GHC.Show.Show Pos.Script.Type.Script
instance GHC.Classes.Eq Pos.Script.Type.Script
instance Control.DeepSeq.NFData Pos.Script.Type.Script
instance Data.Hashable.Class.Hashable Pos.Script.Type.Script
instance Data.Text.Buildable.Buildable Pos.Script.Type.Script

module Pos.Types.Address

-- | Address is where you can send coins.
data Address
PubKeyAddress :: !(AddressHash PublicKey) -> Address
[addrKeyHash] :: Address -> !(AddressHash PublicKey)
ScriptAddress :: !(AddressHash Script) -> Address
[addrScriptHash] :: Address -> !(AddressHash Script)

-- | Specialized formatter for <a>Address</a>.
addressF :: Bi Address => Format r (Address -> r)

-- | A formatter showing guts of an <a>Address</a>.
addressDetailedF :: Format r (Address -> r)

-- | Check if given <a>Address</a> is created from given <a>PublicKey</a>
checkPubKeyAddress :: PublicKey -> Address -> Bool

-- | Check if given <a>Address</a> is created from given validation script
checkScriptAddress :: Bi Script => Script -> Address -> Bool

-- | A function for making an address from PublicKey
makePubKeyAddress :: PublicKey -> Address

-- | A function for making an address from a validation script
makeScriptAddress :: Bi Script => Script -> Address
decodeTextAddress :: Bi Address => Text -> Either Text Address

-- | Stakeholder identifier (stakeholders are identified by their public
--   keys)
type StakeholderId = AddressHash PublicKey
type AddressHash = AbstractHash Blake2s_224
addressHash :: Bi a => a -> AddressHash a
unsafeAddressHash :: Bi a => a -> AddressHash b
instance Pos.Binary.Class.Bi Pos.Types.Core.Address => Data.Hashable.Class.Hashable Pos.Types.Core.Address
instance Pos.Binary.Class.Bi Pos.Types.Core.Address => GHC.Show.Show Pos.Types.Core.Address
instance Pos.Binary.Class.Bi Pos.Types.Core.Address => Data.Text.Buildable.Buildable Pos.Types.Core.Address
instance Control.DeepSeq.NFData Pos.Types.Core.Address
instance Pos.Binary.Class.Bi Pos.Types.Core.Address => GHC.Read.Read Pos.Types.Core.Address

module Pos.Security.CLI
data AttackType
AttackNoBlocks :: AttackType
AttackNoCommitments :: AttackType
data AttackTarget
NetworkAddressTarget :: NetworkAddress -> AttackTarget
[attNetworkAddr] :: AttackTarget -> NetworkAddress
PubKeyAddressTarget :: StakeholderId -> AttackTarget
[attPkAddr] :: AttackTarget -> StakeholderId
data NodeAttackedError
AttackNoBlocksTriggered :: NodeAttackedError
instance GHC.Show.Show Pos.Security.CLI.NodeAttackedError
instance GHC.Show.Show Pos.Security.CLI.AttackTarget
instance GHC.Classes.Eq Pos.Security.CLI.AttackTarget
instance GHC.Show.Show Pos.Security.CLI.AttackType
instance GHC.Classes.Eq Pos.Security.CLI.AttackType
instance GHC.Exception.Exception Pos.Security.CLI.NodeAttackedError

module Pos.Types.Coin

-- | Coin formatter which restricts type.
coinF :: Format r (Coin -> r)
sumCoins :: [Coin] -> Integer

-- | Make Coin from Word64.
mkCoin :: Word64 -> Coin

-- | Unwraps <a>Coin</a>. It's called “unsafe” so that people wouldn't use
--   it willy-nilly if they want to sum coins or something. It's actually
--   safe.
unsafeGetCoin :: Coin -> Word64
coinToInteger :: Coin -> Integer
unsafeIntegerToCoin :: Integer -> Coin

-- | Only use if you're sure there'll be no overflow.
unsafeAddCoin :: Coin -> Coin -> Coin

-- | Only use if you're sure there'll be no underflow.
unsafeSubCoin :: Coin -> Coin -> Coin

-- | Only use if you're sure there'll be no overflow.
unsafeMulCoin :: Integral a => Coin -> a -> Coin
divCoin :: Integral a => Coin -> a -> Coin

-- | Apply CoinPortion to Coin. 'applyCoinPortion a b' is basically 'round
--   (a * b)'.
applyCoinPortion :: CoinPortion -> Coin -> Coin
instance Data.Text.Buildable.Buildable Pos.Types.Core.CoinPortion


-- | Slotting functionality.
module Pos.Types.Timestamp

-- | Timestamp is a number which represents some point in time. It is used
--   in MonadSlots and its meaning is up to implementation of this type
--   class. The only necessary knowledge is that difference between
--   timestamps is microsecond. Hence underlying type is Microsecond.
newtype Timestamp
Timestamp :: Microsecond -> Timestamp
[getTimestamp] :: Timestamp -> Microsecond

-- | Specialized formatter for <a>Timestamp</a> data type.
timestampF :: Format r (Timestamp -> r)
instance GHC.Show.Show Pos.Types.Core.Timestamp
instance GHC.Read.Read Pos.Types.Core.Timestamp
instance Data.Text.Buildable.Buildable Pos.Types.Core.Timestamp

module Pos.Types.Version

-- | Communication protocol version.
data BlockVersion
BlockVersion :: !Word16 -> !Word16 -> !Word8 -> BlockVersion
[bvMajor] :: BlockVersion -> !Word16
[bvMinor] :: BlockVersion -> !Word16
[bvAlt] :: BlockVersion -> !Word8
parseBlockVersion :: Parser BlockVersion

-- | Numeric software version associated with ApplicationName.
type NumSoftwareVersion = Word32

-- | Software version.
data SoftwareVersion
SoftwareVersion :: !ApplicationName -> !NumSoftwareVersion -> SoftwareVersion
[svAppName] :: SoftwareVersion -> !ApplicationName
[svNumber] :: SoftwareVersion -> !NumSoftwareVersion
newtype ApplicationName
ApplicationName :: Text -> ApplicationName
[getApplicationName] :: ApplicationName -> Text
mkApplicationName :: MonadFail m => Text -> m ApplicationName
applicationNameMaxLength :: Integral i => i
parseSoftwareVersion :: Parser SoftwareVersion
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Types.Core.SoftwareVersion
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Types.Core.BlockVersion
instance Data.SafeCopy.SafeCopy.SafeCopy Pos.Types.Core.ApplicationName
instance GHC.Show.Show Pos.Types.Core.BlockVersion
instance Data.Text.Buildable.Buildable Pos.Types.Core.BlockVersion
instance Data.Hashable.Class.Hashable Pos.Types.Core.BlockVersion
instance Data.Text.Buildable.Buildable Pos.Types.Core.SoftwareVersion
instance GHC.Show.Show Pos.Types.Core.SoftwareVersion
instance Data.Hashable.Class.Hashable Pos.Types.Core.SoftwareVersion


-- | Core of Update System.
module Pos.Update.Core

-- | Proposal for software update
data UpdateProposal
UpdateProposal :: !BlockVersion -> !BlockVersionData -> !SoftwareVersion -> !(HashMap SystemTag UpdateData) -> !UpAttributes -> UpdateProposal
[upBlockVersion] :: UpdateProposal -> !BlockVersion
[upBlockVersionData] :: UpdateProposal -> !BlockVersionData
[upSoftwareVersion] :: UpdateProposal -> !SoftwareVersion

-- | UpdateData for each system which this update affects. It must be
--   non-empty.
[upData] :: UpdateProposal -> !(HashMap SystemTag UpdateData)

-- | Attributes which are currently empty, but provide extensibility.
[upAttributes] :: UpdateProposal -> !UpAttributes

-- | ID of softwaree update proposal
type UpId = Hash UpdateProposal
type UpAttributes = Attributes ()

-- | Data which describes update. It is specific for each system.
data UpdateData
UpdateData :: !(Hash Raw) -> !(Hash Raw) -> !(Hash Raw) -> !(Hash Raw) -> UpdateData

-- | Hash of binary diff between two applications. This diff can be passed
--   to updater to create new application.
[udAppDiffHash] :: UpdateData -> !(Hash Raw)

-- | Hash of package to install new application. This package can be used
--   to install new application from scratch instead of updating existing
--   application.
[udPkgHash] :: UpdateData -> !(Hash Raw)

-- | Hash if update application which can be used to install this update
--   (relevant only when updater is used, not package).
[udUpdaterHash] :: UpdateData -> !(Hash Raw)

-- | Hash of metadata relevant to this update. It is raw hash, because
--   metadata can include image or something (maybe). Anyway, we can always
--   use <a>unsafeHash</a>.
[udMetadataHash] :: UpdateData -> !(Hash Raw)

-- | Data which is associated with <a>BlockVersion</a>.
data BlockVersionData
BlockVersionData :: !ScriptVersion -> !Millisecond -> !Byte -> !Byte -> !CoinPortion -> !CoinPortion -> !CoinPortion -> !CoinPortion -> !FlatSlotId -> !CoinPortion -> BlockVersionData
[bvdScriptVersion] :: BlockVersionData -> !ScriptVersion
[bvdSlotDuration] :: BlockVersionData -> !Millisecond
[bvdMaxBlockSize] :: BlockVersionData -> !Byte
[bvdMaxTxSize] :: BlockVersionData -> !Byte
[bvdMpcThd] :: BlockVersionData -> !CoinPortion
[bvdHeavyDelThd] :: BlockVersionData -> !CoinPortion
[bvdUpdateVoteThd] :: BlockVersionData -> !CoinPortion
[bvdUpdateProposalThd] :: BlockVersionData -> !CoinPortion
[bvdUpdateImplicit] :: BlockVersionData -> !FlatSlotId
[bvdUpdateSoftforkThd] :: BlockVersionData -> !CoinPortion

-- | Tag of system for which update data is purposed, e.g. win64, mac32
data SystemTag
mkSystemTag :: MonadFail m => Text -> m SystemTag
systemTagMaxLength :: Integral i => i
patakUpdateData :: HashMap SystemTag UpdateData
upScriptVersion :: UpdateProposal -> ScriptVersion
upSlotDuration :: UpdateProposal -> Millisecond
upMaxBlockSize :: UpdateProposal -> Byte

-- | Format <a>UpdateVote</a> compactly.
formatVoteShort :: UpdateVote -> Builder

-- | Formatter for <a>UpdateVote</a> which displays it compactly.
shortVoteF :: Format r (UpdateVote -> r)

-- | Vote for update proposal
data UpdateVote
UpdateVote :: !PublicKey -> !UpId -> !Bool -> !(Signature (UpId, Bool)) -> UpdateVote

-- | Public key of stakeholder, who votes
[uvKey] :: UpdateVote -> !PublicKey

-- | Proposal to which this vote applies
[uvProposalId] :: UpdateVote -> !UpId

-- | Approval/rejection bit
[uvDecision] :: UpdateVote -> !Bool

-- | Signature of (Update proposal, Approval/rejection bit) by stakeholder
[uvSignature] :: UpdateVote -> !(Signature (UpId, Bool))
type VoteId = (UpId, PublicKey, Bool)

-- | Type alias for set of votes from stakeholders
type StakeholderVotes = HashMap PublicKey VoteState
type UpdateProposals = HashMap UpId UpdateProposal
type LocalVotes = HashMap UpId (HashMap PublicKey UpdateVote)
mkVoteId :: UpdateVote -> VoteId

-- | Update System payload. <a>BodyProof</a> contains <a>UpdateProof</a> =
--   <tt>Hash UpdatePayload</tt>.
data UpdatePayload
UpdatePayload :: !(Maybe UpdateProposal) -> ![UpdateVote] -> UpdatePayload
[upProposal] :: UpdatePayload -> !(Maybe UpdateProposal)
[upVotes] :: UpdatePayload -> ![UpdateVote]

-- | Proof that body of update message contains <a>UpdatePayload</a>.
type UpdateProof = Hash UpdatePayload
mkUpdateProof :: Bi UpdatePayload => UpdatePayload -> UpdateProof

-- | This type represents summary of votes issued by stakeholder.
data VoteState

-- | Stakeholder voted once positively.
PositiveVote :: VoteState

-- | Stakeholder voted once positively.
NegativeVote :: VoteState

-- | Stakeholder voted negatively, then positively.
PositiveRevote :: VoteState

-- | Stakeholder voted positively, then negatively.
NegativeRevote :: VoteState

-- | Check whether given decision is a valid vote if applied to existing
--   vote (which may not exist).
canCombineVotes :: Bool -> Maybe VoteState -> Bool

-- | Apply decision to given vote (or Nothing). This function returns
--   <a>Nothing</a> if decision can't be applied. <a>canCombineVotes</a>
--   can be used to check whether it will be successful.
combineVotes :: Bool -> Maybe VoteState -> Maybe VoteState
isPositiveVote :: VoteState -> Bool

-- | Create new VoteState from bool, which is simple vote, not revote.
newVoteState :: Bool -> VoteState


-- | Secret key file storage and management functions based on file
--   locking.
module Pos.Util.UserSecret

-- | User secret data. Includes secret keys only for now (not including
--   auxiliary <tt>_usPath</tt>).
data UserSecret
usKeys :: Lens' UserSecret [SecretKey]
usVss :: Lens' UserSecret (Maybe VssKeyPair)
getUSPath :: UserSecret -> FilePath

-- | Create a simple UserSecret from secret key and file path
simpleUserSecret :: SecretKey -> FilePath -> UserSecret

-- | Reads user secret from the given file. If the file does not exist/is
--   empty, returns empty user secret
peekUserSecret :: (MonadIO m) => FilePath -> m UserSecret

-- | Read user secret putting an exclusive lock on it. To unlock, use
--   <a>writeUserSecretRelease</a>.
takeUserSecret :: (MonadIO m) => FilePath -> m UserSecret

-- | Writes user secret .
writeUserSecret :: (MonadFail m, MonadIO m) => UserSecret -> m ()

-- | Writes user secret and releases the lock. UserSecret can't be used
--   after this function call anymore.
writeUserSecretRelease :: (MonadFail m, MonadIO m) => UserSecret -> m ()
instance GHC.Show.Show Pos.Util.UserSecret.UserSecret
instance Data.Default.Class.Default Pos.Util.UserSecret.UserSecret
instance Pos.Binary.Class.Bi Pos.Util.UserSecret.UserSecret


-- | Module for command-line utilites, parsers and convenient handlers.
module Pos.CLI

-- | Parsed for network address in format <tt>host:port</tt>.
addrParser :: Parser NetworkAddress
attackTypeParser :: Parser AttackType
attackTargetParser :: Parser AttackTarget

-- | Default logger config. Will be used if `--log-config` argument is not
--   passed. Corresponds to next logger config:
--   
--   <pre>
--   node:
--     severity: Info
--     comm:
--       severity: Warning
--   </pre>
defaultLoggerConfig :: LoggerConfig

-- | Parser for DHT key.
dhtKeyParser :: Parser DHTKey

-- | Parser for <a>DHTNode</a>.
dhtNodeParser :: Parser DHTNode

-- | Reads logger config from given path. By default return
--   <a>defaultLoggerConfig</a>.
readLoggerConfig :: MonadIO m => Maybe FilePath -> m LoggerConfig

-- | Decides which secret-sharing algorithm to use.
sscAlgoParser :: Parser SscAlgo
data CommonArgs
CommonArgs :: !Bool -> ![DHTNode] -> !(Maybe FilePath) -> !(Maybe FilePath) -> !SscAlgo -> !Bool -> !(Maybe (Int, Int)) -> !(Maybe (Int, Int)) -> !Bool -> CommonArgs
[dhtExplicitInitial] :: CommonArgs -> !Bool
[dhtPeers] :: CommonArgs -> ![DHTNode]
[logConfig] :: CommonArgs -> !(Maybe FilePath)
[logPrefix] :: CommonArgs -> !(Maybe FilePath)
[sscAlgo] :: CommonArgs -> !SscAlgo
[disablePropagation] :: CommonArgs -> !Bool
[flatDistr] :: CommonArgs -> !(Maybe (Int, Int))
[bitcoinDistr] :: CommonArgs -> !(Maybe (Int, Int))
[expDistr] :: CommonArgs -> !Bool
commonArgsParser :: String -> Parser CommonArgs
optionalJSONPath :: Parser (Maybe String)
optionalLogPrefix :: Parser (Maybe String)
portOption :: Word16 -> Parser Word16
timeLordOption :: Parser Bool
webPortOption :: Word16 -> String -> Parser Word16
ipPortOption :: NetworkAddress -> Parser NetworkAddress
instance GHC.Show.Show Pos.CLI.CommonArgs


-- | Definitions of the most fundamental types.
module Pos.Types.Types

-- | Represents transaction attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending transaction with new
--   fields via softfork.
type TxAttributes = Attributes ()

-- | A witness for a single input.
data TxInWitness
PkWitness :: PublicKey -> TxSig -> TxInWitness
[twKey] :: TxInWitness -> PublicKey
[twSig] :: TxInWitness -> TxSig
ScriptWitness :: Script -> Script -> TxInWitness
[twValidator] :: TxInWitness -> Script
[twRedeemer] :: TxInWitness -> Script

-- | A witness is a proof that a transaction is allowed to spend the funds
--   it spends (by providing signatures, redeeming scripts, etc). A
--   separate proof is provided for each input.
type TxWitness = Vector TxInWitness

-- | Distribution of “fake” stake that follow-the-satoshi would use for a
--   particular transaction.
newtype TxDistribution
TxDistribution :: [[(StakeholderId, Coin)]] -> TxDistribution
[getTxDistribution] :: TxDistribution -> [[(StakeholderId, Coin)]]

-- | Data that is being signed when creating a TxSig.
type TxSigData = (TxId, Word32, Hash [TxOut], Hash TxDistribution)

-- | <a>Signature</a> of addrId.
type TxSig = Signature TxSigData

-- | Represents transaction identifier as <a>Hash</a> of <a>Tx</a>.
type TxId = Hash Tx

-- | Transaction input.
data TxIn
TxIn :: !TxId -> !Word32 -> TxIn

-- | Which transaction's output is used
[txInHash] :: TxIn -> !TxId

-- | Index of the output in transaction's outputs
[txInIndex] :: TxIn -> !Word32

-- | Make pair from TxIn
toPair :: TxIn -> (TxId, Word32)

-- | Transaction output.
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[txOutAddress] :: TxOut -> !Address
[txOutValue] :: TxOut -> !Coin

-- | Use this function if you need to know how a <a>TxOut</a> distributes
--   stake (e.g. for the purpose of running follow-the-satoshi).
txOutStake :: TxOutAux -> [(StakeholderId, Coin)]

-- | Transaction.
--   
--   NB: transaction witnesses are stored separately.
data Tx
Tx :: ![TxIn] -> ![TxOut] -> !TxAttributes -> Tx

-- | Inputs of transaction.
[txInputs] :: Tx -> ![TxIn]

-- | Outputs of transaction.
[txOutputs] :: Tx -> ![TxOut]

-- | Attributes of transaction
[txAttributes] :: Tx -> !TxAttributes
_txInputs :: Lens' Tx [TxIn]
_txOutputs :: Lens' Tx [TxOut]
_txAttributes :: Lens' Tx TxAttributes

-- | Specialized formatter for <a>Tx</a>.
txF :: Format r (Tx -> r)

-- | Specialized formatter for <a>Tx</a> with auxiliary data
txaF :: Bi Script => Format r (TxAux -> r)

-- | Transaction + auxiliary data
type TxAux = (Tx, TxWitness, TxDistribution)
type TxOutAux = (TxOut, [(StakeholderId, Coin)])

-- | Unspent transaction outputs.
--   
--   Transaction inputs are identified by (transaction ID, index in list of
--   output) pairs.
type Utxo = Map (TxId, Word32) TxOutAux

-- | Format <a>Utxo</a> map as json.
formatUtxo :: Utxo -> Builder

-- | Specialized formatter for <a>Utxo</a>.
utxoF :: Format r (Utxo -> r)

-- | Particular undo needed for transactions
type TxUndo = [[TxOutAux]]

-- | This is a shared seed used for follow-the-satoshi. This seed is
--   randomly generated by each party and eventually they agree on the same
--   value.
newtype SharedSeed
SharedSeed :: ByteString -> SharedSeed
[getSharedSeed] :: SharedSeed -> ByteString

-- | <a>NonEmpty</a> list of slot leaders.
type SlotLeaders = NonEmpty StakeholderId

-- | Proxy signature used in csl -- holds a pair of epoch indices. Block is
--   valid if it's epoch index is inside this range.
type ProxySigEpoch a = ProxySignature (EpochIndex, EpochIndex) a

-- | Same alias for the proxy secret key (see <a>ProxySigEpoch</a>).
type ProxySKEpoch = ProxySecretKey (EpochIndex, EpochIndex)

-- | Simple proxy signature without ttl/epoch index constraints.
type ProxySigSimple a = ProxySignature () a

-- | Correspondent SK for no-ttl proxy signature scheme.
type ProxySKSimple = ProxySecretKey ()

-- | Some proxy secret key.
type ProxySKEither = Either ProxySKEpoch ProxySKSimple

-- | Blockchain type class generalizes some functionality common for
--   different blockchains.
class Blockchain p where data BodyProof p :: * data ConsensusData p :: * type ExtraHeaderData p :: * type BBlockHeader p :: * type BHeaderHash p :: * data Body p :: * type ExtraBodyData p :: * type BBlock p :: * type ExtraHeaderData p = () type BBlockHeader p = GenericBlockHeader p type BHeaderHash p = HeaderHash type ExtraBodyData p = () type BBlock p = GenericBlock p checkBodyProof body proof = mkBodyProof body == proof where {
    data family BodyProof p :: *;
    data family ConsensusData p :: *;
    type family ExtraHeaderData p :: *;
    type family BBlockHeader p :: *;
    type family BHeaderHash p :: *;
    data family Body p :: *;
    type family ExtraBodyData p :: *;
    type family BBlock p :: *;
    type ExtraHeaderData p = ();
    type BBlockHeader p = GenericBlockHeader p;
    type BHeaderHash p = HeaderHash;
    type ExtraBodyData p = ();
    type BBlock p = GenericBlock p;
}
mkBodyProof :: Blockchain p => Body p -> BodyProof p
checkBodyProof :: Blockchain p => Body p -> BodyProof p -> Bool
checkBodyProof :: (Blockchain p, Eq (BodyProof p)) => Body p -> BodyProof p -> Bool

-- | Header of block contains some kind of summary. There are various
--   benefits which people get by separating header from other data.
data GenericBlockHeader b
GenericBlockHeader :: !(BHeaderHash b) -> !(BodyProof b) -> !(ConsensusData b) -> !(ExtraHeaderData b) -> GenericBlockHeader b

-- | Pointer to the header of the previous block.
[_gbhPrevBlock] :: GenericBlockHeader b -> !(BHeaderHash b)

-- | Proof of body.
[_gbhBodyProof] :: GenericBlockHeader b -> !(BodyProof b)

-- | Consensus data to verify consensus algorithm.
[_gbhConsensus] :: GenericBlockHeader b -> !(ConsensusData b)

-- | Any extra data.
[_gbhExtra] :: GenericBlockHeader b -> !(ExtraHeaderData b)

-- | In general Block consists of header and body. It may contain extra
--   data as well.
data GenericBlock b
GenericBlock :: !(GenericBlockHeader b) -> !(Body b) -> !(ExtraBodyData b) -> GenericBlock b
[_gbHeader] :: GenericBlock b -> !(GenericBlockHeader b)
[_gbBody] :: GenericBlock b -> !(Body b)
[_gbExtra] :: GenericBlock b -> !(ExtraBodyData b)

-- | Represents blockchain consisting of main blocks, i. e. blocks with
--   transactions and MPC messages.
data MainBlockchain ssc

-- | Header of generic main block.
type MainBlockHeader ssc = GenericBlockHeader (MainBlockchain ssc)

-- | Represents main block extra data
newtype MainExtraBodyData
MainExtraBodyData :: BlockBodyAttributes -> MainExtraBodyData
[_mebAttributes] :: MainExtraBodyData -> BlockBodyAttributes

-- | Represents main block header extra data
data MainExtraHeaderData
MainExtraHeaderData :: !BlockVersion -> !SoftwareVersion -> !BlockHeaderAttributes -> MainExtraHeaderData

-- | Version of block.
[_mehBlockVersion] :: MainExtraHeaderData -> !BlockVersion

-- | Software version.
[_mehSoftwareVersion] :: MainExtraHeaderData -> !SoftwareVersion

-- | Header attributes
[_mehAttributes] :: MainExtraHeaderData -> !BlockHeaderAttributes

-- | Represents main block header attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending header with new fields
--   via softfork.
type BlockHeaderAttributes = Attributes ()

-- | Represents main block body attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending block with new fields
--   via softfork.
type BlockBodyAttributes = Attributes ()

-- | Ssc w/ buildable blockchain
type BiSsc ssc = (Ssc ssc, Bi (GenericBlockHeader (GenesisBlockchain ssc)), Bi (GenericBlockHeader (MainBlockchain ssc)))

-- | Signature of the block. Can be either regular signature from the
--   issuer or delegated signature having a constraint on epoch indices (it
--   means the signature is valid only if block's slot id has epoch inside
--   the constrained interval).
data BlockSignature ssc
BlockSignature :: (Signature (MainToSign ssc)) -> BlockSignature ssc
BlockPSignatureEpoch :: (ProxySigEpoch (MainToSign ssc)) -> BlockSignature ssc
BlockPSignatureSimple :: (ProxySigSimple (MainToSign ssc)) -> BlockSignature ssc

-- | Data to be signed in main block.
type MainToSign ssc = (HeaderHash, BodyProof (MainBlockchain ssc), SlotId, ChainDifficulty)

-- | MainBlock is a block with transactions and MPC messages. It's the main
--   part of our consensus algorithm.
type MainBlock ssc = GenericBlock (MainBlockchain ssc)

-- | Represents blockchain consisting of genesis blocks. Genesis block
--   doesn't have any special payload and is not strictly necessary.
--   However, it is good idea to store list of leaders explicitly, because
--   calculating it may be expensive operation. For example, it is useful
--   for SPV-clients.
data GenesisBlockchain ssc

-- | Header of Genesis block.
type GenesisBlockHeader ssc = GenericBlockHeader (GenesisBlockchain ssc)

-- | Genesis block parametrized by <a>GenesisBlockchain</a>.
type GenesisBlock ssc = GenericBlock (GenesisBlockchain ssc)

-- | Either header of ordinary main block or genesis block.
type BlockHeader ssc = Either (GenesisBlockHeader ssc) (MainBlockHeader ssc)

-- | Block.
type Block ssc = Either (GenesisBlock ssc) (MainBlock ssc)

-- | This function is required because type inference fails in attempts to
--   hash only <tt>Right</tt> or <tt>Left</tt>.
blockHeaderHash :: BiHeader ssc => BlockHeader ssc -> HeaderHash

-- | Class for something that has previous block (lens to <a>Hash</a> for
--   this block).
class HasPrevBlock s
prevBlockL :: HasPrevBlock s => Lens' s HeaderHash

-- | Lens from <a>Block</a> to <a>BlockHeader</a>.
--   
--   This gives a “redundant constraint” message warning which will be
--   fixed in lens-4.15 (not in LTS yet).
blockHeader :: Getter (Block ssc) (BlockHeader ssc)

-- | Lens from <a>MainBlock</a> to <a>PublicKey</a>.
blockLeaderKey :: Lens' (MainBlock ssc) PublicKey

-- | Lens from <a>GenesisBlock</a> to <a>SlotLeaders</a>.
blockLeaders :: Lens' (GenesisBlock ssc) SlotLeaders

-- | Lens from <a>MainBlock</a> to <a>SscPayload</a>.
blockMpc :: Lens' (MainBlock ssc) (SscPayload ssc)

-- | Lens from <a>MainBlock</a> to <a>Signature</a>.
blockSignature :: Lens' (MainBlock ssc) (BlockSignature ssc)

-- | Lens from <a>MainBlock</a> to <a>SlotId</a>.
blockSlot :: Lens' (MainBlock ssc) SlotId

-- | Lens from <a>MainBlock</a> to <a>MerkleTree</a>.
blockTxs :: Lens' (MainBlock ssc) (MerkleTree Tx)

-- | Getter from <a>MainBlock</a> to a list of transactions together with
--   auxiliary data.
blockTxas :: Getter (MainBlock ssc) [TxAux]

-- | Lens from <a>MainBlock</a> to <a>ProxySKSimple</a> list.
blockProxySKs :: Lens' (MainBlock ssc) [ProxySKSimple]
gbBody :: forall b_a3r6C. Lens' (GenericBlock b_a3r6C) (Body b_a3r6C)

-- | Lens from <a>GenericBlock</a> to <a>BodyProof</a>.
gbBodyProof :: Lens' (GenericBlock b) (BodyProof b)
gbExtra :: forall b_a3r6C. Lens' (GenericBlock b_a3r6C) (ExtraBodyData b_a3r6C)
gbHeader :: forall b_a3r6C. Lens' (GenericBlock b_a3r6C) (GenericBlockHeader b_a3r6C)

-- | Lens for <a>ChainDifficulty</a> of <a>GenesisBlockchain</a> in
--   <a>ConsensusData</a>.
gcdDifficulty :: Lens' (ConsensusData (GenesisBlockchain ssc)) ChainDifficulty

-- | Lens for <a>EpochIndex</a> of <a>GenesisBlockchain</a> in
--   <a>ConsensusData</a>.
gcdEpoch :: Lens' (ConsensusData (GenesisBlockchain ssc)) EpochIndex
gbhConsensus :: forall b_a3r6D. Lens' (GenericBlockHeader b_a3r6D) (ConsensusData b_a3r6D)
gbhExtra :: forall b_a3r6D. Lens' (GenericBlockHeader b_a3r6D) (ExtraHeaderData b_a3r6D)
gbhPrevBlock :: forall b_a3r6D. Lens' (GenericBlockHeader b_a3r6D) (BHeaderHash b_a3r6D)
gbhBodyProof :: forall b_a3r6D. Lens' (GenericBlockHeader b_a3r6D) (BodyProof b_a3r6D)

-- | Take <a>BlockHeader</a> from either <a>GenesisBlock</a> or
--   <a>MainBlock</a>.
getBlockHeader :: Block ssc -> BlockHeader ssc

-- | Lens from <a>MainBlockHeader</a> to <a>PublicKey</a>.
headerLeaderKey :: Lens' (MainBlockHeader ssc) PublicKey

-- | Lens from <a>MainBlockHeader</a> to <a>Signature</a>.
headerSignature :: Lens' (MainBlockHeader ssc) (BlockSignature ssc)

-- | Lens from <a>MainBlockHeader</a> to <a>SlotId</a>.
headerSlot :: Lens' (MainBlockHeader ssc) SlotId

-- | Lens for <a>SscPayload</a> in main block body.
mbMpc :: Lens' (Body (MainBlockchain ssc)) (SscPayload ssc)

-- | Lens for transaction tree in main block body.
mbTxs :: Lens' (Body (MainBlockchain ssc)) (MerkleTree Tx)

-- | Lens for witness list in main block body.
mbWitnesses :: Lens' (Body (MainBlockchain ssc)) [TxWitness]

-- | Lens for ProxySKs in main block body.
mbProxySKs :: Lens' (Body (MainBlockchain ssc)) [ProxySKSimple]

-- | Lens for <a>UpdatePayload</a> in main block body.
mbUpdatePayload :: Lens' (Body (MainBlockchain ssc)) UpdatePayload

-- | Lens for <a>SlotId</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdSlot :: Lens' (ConsensusData (MainBlockchain ssc)) SlotId

-- | Lens for <a>PublicKey</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdLeaderKey :: Lens' (ConsensusData (MainBlockchain ssc)) PublicKey

-- | Lens for <a>ChainDifficulty</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdDifficulty :: Lens' (ConsensusData (MainBlockchain ssc)) ChainDifficulty

-- | Lens for <a>Signature</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdSignature :: Lens' (ConsensusData (MainBlockchain ssc)) (BlockSignature ssc)
mehBlockVersion :: Lens' MainExtraHeaderData BlockVersion
mehSoftwareVersion :: Lens' MainExtraHeaderData SoftwareVersion
mehAttributes :: Lens' MainExtraHeaderData BlockHeaderAttributes
mebAttributes :: Iso' MainExtraBodyData BlockBodyAttributes
instance Control.DeepSeq.NFData Pos.Types.Types.Tx
instance Control.DeepSeq.NFData Pos.Types.Types.TxDistribution
instance Control.DeepSeq.NFData Pos.Types.Types.TxOut
instance Control.DeepSeq.NFData Pos.Types.Types.TxInWitness
instance Control.DeepSeq.NFData Pos.Types.Types.TxIn
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.ConsensusData (Pos.Types.Types.MainBlockchain ssc))
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.ConsensusData (Pos.Types.Types.GenesisBlockchain ssc))
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.MainBlockHeader ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.GenesisBlockHeader ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.BlockHeader ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.MainBlock ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.GenesisBlock ssc)
instance Pos.Types.Core.HasDifficulty (Pos.Types.Types.Block ssc)
instance Pos.Types.Types.HasPrevBlock s => Pos.Types.Types.HasPrevBlock (s, z)
instance Pos.Types.Types.BHeaderHash b ~ Pos.Types.Core.HeaderHash => Pos.Types.Types.HasPrevBlock (Pos.Types.Types.GenericBlockHeader b)
instance Pos.Types.Types.BHeaderHash b ~ Pos.Types.Core.HeaderHash => Pos.Types.Types.HasPrevBlock (Pos.Types.Types.GenericBlock b)
instance (Pos.Types.Types.HasPrevBlock s, Pos.Types.Types.HasPrevBlock s') => Pos.Types.Types.HasPrevBlock (Data.Either.Either s s')
instance Pos.Types.Core.HasEpochIndex Pos.Types.Core.SlotId
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Types.MainBlock ssc)
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Types.MainBlockHeader ssc)
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Types.GenesisBlock ssc)
instance Pos.Types.Core.HasEpochIndex (Pos.Types.Types.GenesisBlockHeader ssc)
instance (Pos.Types.Core.HasEpochIndex a, Pos.Types.Core.HasEpochIndex b) => Pos.Types.Core.HasEpochIndex (Data.Either.Either a b)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Types.MainBlockHeader ssc)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Types.GenesisBlockHeader ssc)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Types.MainBlock ssc)
instance Pos.Types.Core.HasEpochOrSlot (Pos.Types.Types.GenesisBlock ssc)
instance (Pos.Types.Core.HasEpochOrSlot a, Pos.Types.Core.HasEpochOrSlot b) => Pos.Types.Core.HasEpochOrSlot (Data.Either.Either a b)
instance GHC.Generics.Generic Pos.Types.Types.MainExtraBodyData
instance GHC.Show.Show Pos.Types.Types.MainExtraBodyData
instance GHC.Classes.Eq Pos.Types.Types.MainExtraBodyData
instance GHC.Generics.Generic Pos.Types.Types.MainExtraHeaderData
instance GHC.Show.Show Pos.Types.Types.MainExtraHeaderData
instance GHC.Classes.Eq Pos.Types.Types.MainExtraHeaderData
instance GHC.Classes.Eq (Pos.Types.Types.BlockSignature ssc)
instance GHC.Show.Show (Pos.Types.Types.BlockSignature ssc)
instance GHC.Generics.Generic (Pos.Types.Types.GenericBlockHeader b)
instance GHC.Generics.Generic (Pos.Types.Types.GenericBlock b)
instance Control.DeepSeq.NFData Pos.Types.Types.SharedSeed
instance GHC.Generics.Generic Pos.Types.Types.SharedSeed
instance GHC.Classes.Ord Pos.Types.Types.SharedSeed
instance GHC.Classes.Eq Pos.Types.Types.SharedSeed
instance GHC.Show.Show Pos.Types.Types.SharedSeed
instance GHC.Generics.Generic (Pos.Types.Types.Body (Pos.Types.Types.MainBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Types.ConsensusData (Pos.Types.Types.MainBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Types.ConsensusData (Pos.Types.Types.MainBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Types.ConsensusData (Pos.Types.Types.MainBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Types.BodyProof (Pos.Types.Types.MainBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Types.Body (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Types.Body (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Types.Body (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Types.ConsensusData (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Types.ConsensusData (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Types.ConsensusData (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Types.Types.BodyProof (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Types.Types.BodyProof (Pos.Types.Types.GenesisBlockchain ssc))
instance GHC.Classes.Eq (Pos.Types.Types.BodyProof (Pos.Types.Types.GenesisBlockchain ssc))
instance (GHC.Show.Show (Pos.Types.Types.BHeaderHash b), GHC.Show.Show (Pos.Types.Types.BodyProof b), GHC.Show.Show (Pos.Types.Types.ConsensusData b), GHC.Show.Show (Pos.Types.Types.ExtraHeaderData b)) => GHC.Show.Show (Pos.Types.Types.GenericBlockHeader b)
instance (GHC.Classes.Eq (Pos.Types.Types.BHeaderHash b), GHC.Classes.Eq (Pos.Types.Types.BodyProof b), GHC.Classes.Eq (Pos.Types.Types.ConsensusData b), GHC.Classes.Eq (Pos.Types.Types.ExtraHeaderData b)) => GHC.Classes.Eq (Pos.Types.Types.GenericBlockHeader b)
instance (GHC.Show.Show (Pos.Types.Types.GenericBlockHeader b), GHC.Show.Show (Pos.Types.Types.Body b), GHC.Show.Show (Pos.Types.Types.ExtraBodyData b)) => GHC.Show.Show (Pos.Types.Types.GenericBlock b)
instance (GHC.Classes.Eq (Pos.Types.Types.BHeaderHash b), GHC.Classes.Eq (Pos.Types.Types.Body b), GHC.Classes.Eq (Pos.Types.Types.BodyProof b), GHC.Classes.Eq (Pos.Types.Types.ConsensusData b), GHC.Classes.Eq (Pos.Types.Types.ExtraBodyData b), GHC.Classes.Eq (Pos.Types.Types.ExtraHeaderData b)) => GHC.Classes.Eq (Pos.Types.Types.GenericBlock b)
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Types.Types.BodyProof (Pos.Types.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Types.Types.BodyProof (Pos.Types.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Types.Types.Body (Pos.Types.Types.MainBlockchain ssc))
instance (GHC.Classes.Eq (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Types.Ssc ssc) => GHC.Classes.Eq (Pos.Types.Types.Body (Pos.Types.Types.MainBlockchain ssc))
instance Data.Hashable.Class.Hashable Pos.Types.Types.Tx
instance Data.Text.Buildable.Buildable Pos.Types.Types.Tx
instance Data.Text.Buildable.Buildable Pos.Types.Types.SharedSeed
instance Data.Text.Buildable.Buildable (Pos.Types.Types.BlockSignature ssc)
instance Data.Text.Buildable.Buildable Pos.Types.Types.MainExtraHeaderData
instance Data.Text.Buildable.Buildable Pos.Types.Types.MainExtraBodyData
instance (Pos.Ssc.Class.Types.Ssc ssc, Pos.Binary.Class.Bi Pos.Types.Types.TxWitness, Pos.Binary.Class.Bi Pos.Update.Core.Types.UpdatePayload) => Pos.Types.Types.Blockchain (Pos.Types.Types.MainBlockchain ssc)
instance Pos.Types.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Types.MainBlockHeader ssc)
instance (Pos.Binary.Class.Bi Pos.Update.Core.Types.UpdateProposal, Pos.Types.Types.BiSsc ssc) => Data.Text.Buildable.Buildable (Pos.Types.Types.MainBlock ssc)
instance Pos.Types.Types.Blockchain (Pos.Types.Types.GenesisBlockchain ssc)
instance Pos.Types.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Types.GenesisBlock ssc)
instance Pos.Types.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Types.GenesisBlockHeader ssc)
instance Pos.Types.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Types.BlockHeader ssc)
instance Pos.Types.Core.HasHeaderHash Pos.Types.Core.HeaderHash
instance Pos.Types.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Types.MainBlockHeader ssc)
instance Pos.Types.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Types.GenesisBlockHeader ssc)
instance Pos.Types.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Types.BlockHeader ssc)
instance Pos.Types.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Types.MainBlock ssc)
instance Pos.Types.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Types.GenesisBlock ssc)
instance Pos.Types.Types.BiHeader ssc => Pos.Types.Core.HasHeaderHash (Pos.Types.Types.Block ssc)
instance GHC.Generics.Generic Pos.Types.Types.TxInWitness
instance GHC.Show.Show Pos.Types.Types.TxInWitness
instance GHC.Classes.Eq Pos.Types.Types.TxInWitness
instance GHC.Generics.Generic Pos.Types.Types.TxIn
instance GHC.Show.Show Pos.Types.Types.TxIn
instance GHC.Classes.Ord Pos.Types.Types.TxIn
instance GHC.Classes.Eq Pos.Types.Types.TxIn
instance GHC.Show.Show Pos.Types.Types.Tx
instance GHC.Generics.Generic Pos.Types.Types.Tx
instance GHC.Classes.Ord Pos.Types.Types.Tx
instance GHC.Classes.Eq Pos.Types.Types.Tx
instance GHC.Show.Show Pos.Types.Types.TxOut
instance GHC.Generics.Generic Pos.Types.Types.TxOut
instance GHC.Classes.Ord Pos.Types.Types.TxOut
instance GHC.Classes.Eq Pos.Types.Types.TxOut
instance GHC.Generics.Generic Pos.Types.Types.TxDistribution
instance GHC.Show.Show Pos.Types.Types.TxDistribution
instance GHC.Classes.Eq Pos.Types.Types.TxDistribution
instance Data.Hashable.Class.Hashable Pos.Types.Types.TxInWitness
instance Pos.Binary.Class.Bi Pos.Script.Type.Script => Data.Text.Buildable.Buildable Pos.Types.Types.TxInWitness
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxDistribution
instance Data.Hashable.Class.Hashable Pos.Types.Types.TxIn
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxIn
instance Data.Hashable.Class.Hashable Pos.Types.Types.TxOut
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxOut
instance Data.Text.Buildable.Buildable Pos.Types.Types.TxOutAux


-- | A wrapper over Plutus (the scripting language used in transactions).
module Pos.Script

-- | A script for inclusion into a transaction.
data Script

-- | Serialized script
Script :: ScriptVersion -> LByteString -> Script

-- | Version
[scrVersion] :: Script -> ScriptVersion
[scrScript] :: Script -> LByteString
type TxScriptError = String

-- | Validate a transaction, given a validator and a redeemer.
txScriptCheck :: Bi Script_v0 => TxSigData -> Script -> Script -> Either TxScriptError ()

-- | Parse a script intended to serve as a validator (or “lock”) in a
--   transaction output.
parseValidator :: Bi Script_v0 => Text -> Either String Script

-- | Parse a script intended to serve as a redeemer (or “proof”) in a
--   transaction input.
--   
--   Can be given an optional validator (e.g. if the redeemer uses
--   functions or types defined by the validator).
parseRedeemer :: Bi Script_v0 => Maybe Script -> Text -> Either String Script
stdlib :: Program
isKnownScriptVersion :: Word16 -> Bool


-- | Some example scripts used in tests.
module Pos.Script.Examples
alwaysSuccessValidator :: Script
alwaysFailureValidator :: Script
idValidator :: Script
intValidator :: Script
goodIntRedeemer :: Script
badIntRedeemer :: Script
stdlibValidator :: Script
goodStdlibRedeemer :: Script
multisigValidator :: Int -> [PublicKey] -> Script
multisigRedeemer :: TxSigData -> [Maybe SecretKey] -> Script
intValidatorWithBlah :: Script
goodIntRedeemerWithBlah :: Script

-- | Does N rounds of SHA3-256. Should be used with <a>idValidator</a>.
--   
--   Actually it does (N div 10) * 10 rounds. Unrolling the loop is done so
--   that more petrol would be spent on hashing and less – on substraction
--   and function calls.
shaStressRedeemer :: Int -> Script

-- | Checks a signature N times. Should be used with <a>idValidator</a>.
sigStressRedeemer :: Int -> Script

module Pos.Ssc.Class.Helpers
class Ssc ssc => SscHelpersClass ssc
sscVerifyPayload :: SscHelpersClass ssc => Tagged ssc (MainBlockHeader ssc -> SscPayload ssc -> Either (SscVerifyError ssc) ())


-- | <tt>Arbitrary</tt> unsafe instances for some types from <a>Types</a>.
module Pos.Types.Arbitrary.Unsafe
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Types.SharedSeed
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.EpochIndex
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.LocalSlotIndex
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.Coin
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.Address
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Core.SlotId
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Types.Types.TxOut


-- | Compile-time configuration support.
module Pos.CompileConfig

-- | Compile time configuration. See example in <i>constants.yaml</i> file.
data CompileConfig
CompileConfig :: !Int -> !Int -> !Int -> !Byte -> !Byte -> !Double -> !Double -> !Double -> !Double -> !Word -> !Double -> !Int -> !Int -> !Word -> ![String] -> !Int -> !Word -> !Int -> !Int -> !Word64 -> !Word64 -> !Int -> !Int -> !Word -> !Int -> !Int -> !Int -> ![String] -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> CompileConfig

-- | Security parameter from paper
[ccK] :: CompileConfig -> !Int

-- | Number of pre-generated keys
[ccGenesisN] :: CompileConfig -> !Int

-- | Length of slot in seconds
[ccGenesisSlotDurationSec] :: CompileConfig -> !Int

-- | Maximum block size in bytes
[ccGenesisMaxBlockSize] :: CompileConfig -> !Byte

-- | Maximum tx size in bytes
[ccGenesisMaxTxSize] :: CompileConfig -> !Byte

-- | Eligibility threshold for MPC
[ccGenesisMpcThd] :: CompileConfig -> !Double

-- | Threshold for heavyweight delegation
[ccGenesisHeavyDelThd] :: CompileConfig -> !Double

-- | Portion of total stake necessary to vote for or against update.
[ccGenesisUpdateVoteThd] :: CompileConfig -> !Double

-- | Portion of total stake such that block containing UpdateProposal must
--   contain positive votes for this proposal from stakeholders owning at
--   least this amount of stake.
[ccGenesisUpdateProposalThd] :: CompileConfig -> !Double

-- | Number of slots after which update is implicitly approved unless it
--   has more negative votes than positive.
[ccGenesisUpdateImplicit] :: CompileConfig -> !Word

-- | Portion of total stake such that if total stake of issuers of blocks
--   with some block version is bigger than this portion, this block
--   version is adopted.
[ccGenesisUpdateSoftforkThd] :: CompileConfig -> !Double

-- | Estimated time for broadcasting messages
[ccNetworkDiameter] :: CompileConfig -> !Int

-- | Broadcasting threshold
[ccNeighboursSendThreshold] :: CompileConfig -> !Int

-- | Max number of transactions in Storage
[ccMaxLocalTxs] :: CompileConfig -> !Word

-- | List of default peers
[ccDefaultPeers] :: CompileConfig -> ![String]

-- | Number of slots to broadcast system time
[ccSysTimeBroadcastSlots] :: CompileConfig -> !Int

-- | Length of interval for sending MPC message
[ccMpcSendInterval] :: CompileConfig -> !Word

-- | Threshold of slots for malicious activity detection
[ccMdNoBlocksSlotThreshold] :: CompileConfig -> !Int

-- | Threshold of epochs for malicious activity detection
[ccMdNoCommitmentsEpochThreshold] :: CompileConfig -> !Int

-- | VSS certificates max timeout to live (number of epochs)
[ccVssMaxTTL] :: CompileConfig -> !Word64

-- | VSS certificates min timeout to live (number of epochs)
[ccVssMinTTL] :: CompileConfig -> !Word64

-- | Magic constant for separating real/testnet
[ccProtocolMagic] :: CompileConfig -> !Int

-- | Timeout for holding light psks confirmations
[ccLightDlgConfirmationTimeout] :: CompileConfig -> !Int

-- | True if we should enable enhanced bessage broadcast
[ccEnhancedMessageBroadcast] :: CompileConfig -> !Word

-- | Numbers of headers put in message in recovery mode.
[ccRecoveryHeadersMessage] :: CompileConfig -> !Int

-- | Interval we ignore cached messages in components that support caching
[ccMessageCacheTimeout] :: CompileConfig -> !Int

-- | Interval for dumping Kademlia state in slots
[ccKademliaDumpInterval] :: CompileConfig -> !Int

-- | Servers for downloading application updates
[ccUpdateServers] :: CompileConfig -> ![String]

-- | How often request to NTP server and response collection
[ccNtpResponseTimeout] :: CompileConfig -> !Int

-- | How often send request to NTP server
[ccNtpPollDelay] :: CompileConfig -> !Int

-- | Network connection timeout in milliseconds
[ccNetworkConnectionTimeout] :: CompileConfig -> !Int

-- | Block retrieval queue capacity
[ccBlockRetrievalQueueSize] :: CompileConfig -> !Int

-- | Network timeout on <tt>recv</tt> in milliseconds
[ccNetworkReceiveTimeout] :: CompileConfig -> !Int

-- | Start time of network (in <tt>Prodution</tt> running mode). If set to
--   zero, then running time is 2 minutes after build.
[ccProductionNetworkStartTime] :: CompileConfig -> !Int

-- | Used in code compile-time configuration from <i>constants-*.yaml</i>
--   file.
compileConfig :: CompileConfig


-- | Constants used by algorithm. See paper for more details. Some
--   constants are parsed at compile-time (see <a>Type</a>). Others are
--   derived from those.
module Pos.Constants

-- | Security parameter which is maximum number of blocks which can be
--   rolled back.
blkSecurityParam :: Integral a => a

-- | Security parameter expressed in number of slots. It uses chain quality
--   property. It's basically 'blkSecurityParam / chain_quality'.
slotSecurityParam :: Integral a => a

-- | Number of slots inside one epoch.
epochSlots :: Integral a => a

-- | Estimated time needed to broadcast message from one node to all other
--   nodes. Also see <a>ccNetworkDiameter</a>.
networkDiameter :: Microsecond

-- | Length of shared seed.
sharedSeedLength :: Integral a => a

-- | Length of interval during which node should send her MPC message.
--   Relevant only for one SSC implementation. Also see
--   <a>ccMpcSendInterval</a>.
mpcSendInterval :: Microsecond

-- | <tt>True</tt> if current mode is <tt>Development</tt>.
isDevelopment :: Bool

-- | System start time embeded into binary.
staticSysStart :: Maybe Timestamp

-- | See <a>ccGenesisN</a>.
genesisN :: Integral i => i

-- | Length of slot.
genesisSlotDuration :: Millisecond

-- | Maximum size of a block (in bytes)
genesisMaxBlockSize :: Byte

-- | See <a>ccGenesisMaxTxSize</a>.
genesisMaxTxSize :: Byte

-- | See <a>ccGenesisMpcThd</a>.
genesisMpcThd :: CoinPortion

-- | See <a>ccGenesisHeavyDelThd</a>.
genesisHeavyDelThd :: CoinPortion

-- | See <a>ccGenesisUpdateVoteThd</a>.
genesisUpdateVoteThd :: CoinPortion

-- | See <a>ccGenesisUpdateProposalThd</a>.
genesisUpdateProposalThd :: CoinPortion

-- | See <a>ccGenesisUpdateImplicit</a>.
genesisUpdateImplicit :: Integral i => i

-- | See <a>ccGenesisUpdateSoftforkThd</a>.
genesisUpdateSoftforkThd :: CoinPortion

-- | Maximum amount of transactions we have in storage (i.e. we can accept
--   without putting them in block). There're next kind of storages in our
--   implementation:
--   
--   <ul>
--   <li>temporary storage of transactions</li>
--   <li>utxo map that corresponds to it</li>
--   <li>utxo of blocks in history</li>
--   </ul>
--   
--   This constant is size of first set. Also see <a>ccMaxLocalTxs</a>.
maxLocalTxs :: Integral i => i

-- | See <a>ccNeighboursSendThreshold</a>.
neighborsSendThreshold :: Integral a => a
networkConnectionTimeout :: Microsecond
networkReceiveTimeout :: Microsecond
blockRetrievalQueueSize :: Integral a => a

-- | See <a>ccDefaultPeers</a>.
defaultPeers :: [DHTNode]

-- | <i>Time-lord</i> node announces system start time by broadcast. She
--   does it during first <a>ccSysTimeBroadcastSlots</a> slots.
sysTimeBroadcastSlots :: Integral i => i

-- | Max VSS certificate TTL (Ssc.GodTossing part)
vssMaxTTL :: Integral i => i

-- | Min VSS certificate TTL (Ssc.GodTossing part)
vssMinTTL :: Integral i => i

-- | Protocol magic constant. Is put to block serialized version to
--   distinguish testnet and realnet (for example, possible usages are
--   wider).
protocolMagic :: Int32

-- | Setting this to true enables enhanced message broadcast
enhancedMessageBroadcast :: Integral a => a

-- | Maximum amount of headers node can put into headers message while in
--   "after offline" or "recovery" mode. Should be more than
--   <a>blkSecurityParam</a>.
recoveryHeadersMessage :: (Integral a) => a

-- | Interval for dumping state of Kademlia in slots
kademliaDumpInterval :: (Integral a) => a

-- | Timeout for caching system. Components that use caching on messages
--   can use this timeout to invalidate caches.
messageCacheTimeout :: (Integral a) => a

-- | Amount of time we hold confirmations for light PSKs.
lightDlgConfirmationTimeout :: (Integral a) => a

-- | Number of slots used by malicious actions detection to check if we are
--   not receiving generated blocks.
mdNoBlocksSlotThreshold :: Integral i => i

-- | Number of epochs used by malicious actions detection to check if our
--   commitments are not included in blockchain.
mdNoCommitmentsEpochThreshold :: Integral i => i

-- | Last block version application is aware of.
lastKnownBlockVersion :: BlockVersion

-- | Version of application (code running)
curSoftwareVersion :: SoftwareVersion

-- | Name of our application.
ourAppName :: ApplicationName
appSystemTag :: SystemTag

-- | Update servers
updateServers :: [String]
pkgUpdatesDir :: FilePath
pkgExecutablesDir :: FilePath

-- | Inaccuracy in call threadDelay (actually it is error much less than 1
--   sec)
ntpMaxError :: Microsecond

-- | How often request to NTP server and response collection
ntpResponseTimeout :: Microsecond

-- | How often send request to NTP server
ntpPollDelay :: Microsecond


-- | Transaction related functions.
module Pos.Types.Tx

-- | Verify that Tx itself is correct. Most likely you will also want to
--   verify that inputs are legal, signed properly and have enough coins;
--   <a>verifyTxAlone</a> doesn't do that.
verifyTxAlone :: Tx -> VerificationRes

-- | Global context data needed for script execution -- is same for the
--   whole transaction. VT stands for "Verify Tx". Currently empty.
data VTxGlobalContext
VTxGlobalContext :: VTxGlobalContext

-- | Local context data for scripts -- differs per input.
data VTxLocalContext
VTxLocalContext :: TxOutAux -> VTxLocalContext

-- | Transaction output
[vtlTxOut] :: VTxLocalContext -> TxOutAux

-- | CHECK: Verify Tx correctness using magic function which resolves input
--   into Address and Coin. It optionally does checks from
--   <a>verifyTxAlone</a> and also the following checks:
--   
--   <ul>
--   <li>sum of inputs &gt;= sum of outputs;</li>
--   <li>every input has a proper witness verifying that input;</li>
--   <li>script witnesses have matching script versions;</li>
--   <li>every input is a known unspent output.</li>
--   </ul>
--   
--   Note that <a>verifyTx</a> doesn't attempt to verify scripts with
--   versions higher than maximum script version we can handle. That's
--   because we want blocks with such transactions to be accepted (to avoid
--   hard forks). However, we won't include such transactions into blocks
--   when we're creating a block.
verifyTx :: (Monad m) => Bool -> VTxGlobalContext -> (TxIn -> m (Maybe VTxLocalContext)) -> TxAux -> m (Either [Text] [TxOutAux])
verifyTxPure :: Bool -> VTxGlobalContext -> (TxIn -> Maybe VTxLocalContext) -> TxAux -> Either [Text] [TxOutAux]

-- | Does topological sort on things that contain transactions – e.g. can
--   be used both for sorting <tt>[Tx]</tt> and <tt>[(Tx, TxWitness)]</tt>.
--   
--   (Backwards dfs from every node with reverse visiting order recording.
--   Returns nothing on loop encountered. Return order is head-first.)
topsortTxs :: forall a. (a -> WithHash Tx) -> [a] -> Maybe [a]
instance GHC.Show.Show Pos.Types.Tx.VTxLocalContext
instance GHC.Show.Show Pos.Types.Tx.VTxGlobalContext


-- | Utxo related operations.
module Pos.Types.Utxo
class Monad m => MonadUtxoRead m where utxoGet = lift . utxoGet
utxoGet :: MonadUtxoRead m => TxIn -> m (Maybe TxOutAux)
utxoGet :: (MonadUtxoRead m, MonadTrans t, MonadUtxoRead m', t m' ~ m) => TxIn -> m (Maybe TxOutAux)
class MonadUtxoRead m => MonadUtxo m where utxoPut a = lift . utxoPut a utxoDel = lift . utxoDel
utxoPut :: MonadUtxo m => TxIn -> TxOutAux -> m ()
utxoPut :: (MonadUtxo m, MonadTrans t, MonadUtxo m', t m' ~ m) => TxIn -> TxOutAux -> m ()
utxoDel :: MonadUtxo m => TxIn -> m ()
utxoDel :: (MonadUtxo m, MonadTrans t, MonadUtxo m', t m' ~ m) => TxIn -> m ()

-- | Remove unspent outputs used in given transaction, add new unspent
--   outputs.
applyTxToUtxo :: MonadUtxo m => WithHash Tx -> TxDistribution -> m ()

-- | Delete given TxIn from Utxo if any.
deleteTxIn :: TxIn -> Utxo -> Utxo

-- | Find transaction input in Utxo assuming it is valid.
findTxIn :: TxIn -> Utxo -> Maybe TxOutAux

-- | Verify single Tx using MonadUtxoRead as TxIn resolver.
verifyTxUtxo :: MonadUtxoRead m => Bool -> TxAux -> m (Either [Text] [TxOutAux])

-- | Verify transactions correctness with respect to Utxo applying them
--   one-by-one. Note: transactions must be topsorted to pass check.
--   Warning: this function may apply some transactions and fail
--   eventually. Use it only on temporary data.
verifyAndApplyTxs :: forall m. MonadUtxo m => Bool -> [(WithHash Tx, TxWitness, TxDistribution)] -> m (Either [Text] TxUndo)
applyTxToUtxo' :: MonadUtxo m => (TxId, TxAux) -> m ()

-- | A predicate for <a>TxOut</a> which selects outputs for given address
belongsTo :: TxOutAux -> Address -> Bool

-- | Select only TxOuts for given addresses
filterUtxoByAddr :: Address -> Utxo -> Utxo
utxoToStakes :: Utxo -> HashMap StakeholderId Coin
newtype UtxoReaderT m a
UtxoReaderT :: ReaderT Utxo m a -> UtxoReaderT m a
[getUtxoReaderT] :: UtxoReaderT m a -> ReaderT Utxo m a
runUtxoReaderT :: UtxoReaderT m a -> Utxo -> m a
type UtxoReader = UtxoReaderT Identity
runUtxoReader :: UtxoReader a -> Utxo -> a
newtype UtxoStateT m a
UtxoStateT :: StateT Utxo m a -> UtxoStateT m a
[getUtxoStateT] :: UtxoStateT m a -> StateT Utxo m a
runUtxoStateT :: UtxoStateT m a -> Utxo -> m (a, Utxo)
evalUtxoStateT :: Monad m => UtxoStateT m a -> Utxo -> m a
execUtxoStateT :: Monad m => UtxoStateT m a -> Utxo -> m Utxo
type UtxoState = UtxoStateT Identity
runUtxoState :: UtxoState a -> Utxo -> (a, Utxo)
evalUtxoState :: UtxoState a -> Utxo -> a
execUtxoState :: UtxoState a -> Utxo -> Utxo

-- | Pure version of applyTxToUtxo.
applyTxToUtxoPure :: WithHash Tx -> TxDistribution -> Utxo -> Utxo

-- | Pure version of applyTxToUtxo'.
applyTxToUtxoPure' :: (TxId, TxAux) -> Utxo -> Utxo

-- | Pure version of verifyTxUtxo.
verifyTxUtxoPure :: Bool -> Utxo -> TxAux -> VerificationRes

module Pos.DHT.Model.Neighbors

-- | Send default message to neighbours in parallel. It's a broadcasting to
--   the neighbours without sessions (i.e. we don't have to wait for reply
--   from the listeners).
sendToNeighbors :: (MonadDHT m, MonadMockable m, Serializable packing body, WithLogger m, Message body) => SendActions packing m -> body -> m ()
sendToNode :: (MonadMockable m, Serializable packing body, Message body) => SendActions packing m -> NetworkAddress -> body -> m ()
converseToNeighbors :: (MonadDHT m, MonadMockable m, WithLogger m, Unpackable packing rcv, Packable packing snd, Message snd) => SendActions packing m -> (NodeId -> ConversationActions snd rcv m -> m ()) -> m ()
converseToNode :: (MonadMockable m, Unpackable packing rcv, Packable packing snd, Message snd) => SendActions packing m -> NetworkAddress -> (NodeId -> ConversationActions snd rcv m -> m t) -> m t


-- | Distributed Hash Table for peer discovery.
module Pos.DHT.Model

module Pos.DHT.Real.Real

-- | Run KademliaDHT
runKademliaDHT :: (MonadMockable m, Eq (Promise m (Maybe ())), MonadIO m, WithLogger m) => KademliaDHTInstance -> KademliaDHT m a -> m a

-- | Start <a>KademliaDHTInstance</a> with
--   <a>KademliaDHTInstanceConfig</a>.
startDHTInstance :: (MonadIO m, Mockable Catch m, Mockable Throw m, WithLogger m, Bi DHTData, Bi DHTKey) => KademliaDHTInstanceConfig -> m KademliaDHTInstance

-- | Stop chosen <a>KademliaDHTInstance</a>.
stopDHTInstance :: MonadIO m => KademliaDHTInstance -> m ()
instance (Control.Monad.IO.Class.MonadIO m, Mockable.Class.Mockable Mockable.Concurrent.Async m, Mockable.Class.Mockable Mockable.Exception.Catch m, Mockable.Class.Mockable Mockable.Exception.Throw m, GHC.Classes.Eq (Mockable.Concurrent.Promise m (GHC.Base.Maybe ())), System.Wlog.CanLog.WithLogger m, Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTData, Pos.Binary.Class.Bi Pos.DHT.Model.Types.DHTKey) => Pos.DHT.Model.Class.MonadDHT (Pos.DHT.Real.Types.KademliaDHT m)


-- | Implementation of peer discovery using using Kademlia Distributed Hash
--   Table. For more details regarding DHT see this package on hackage:
--   <a>https://hackage.haskell.org/package/kademlia</a>
module Pos.DHT.Real


-- | <a>Arbitrary</a> instances for core types for using in tests and
--   benchmarks
module Pos.Types.Arbitrary

-- | Ill-formed <a>Tx</a> with bad signatures.
newtype BadSigsTx
BadSigsTx :: [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)] -> BadSigsTx
[getBadSigsTx] :: BadSigsTx -> [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)]

-- | Well-formed transaction <a>Tx</a>.
newtype GoodTx
GoodTx :: [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)] -> GoodTx
[getGoodTx] :: GoodTx -> [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)]

-- | Ill-formed <a>Tx</a> with overflow.
newtype OverflowTx
OverflowTx :: [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)] -> OverflowTx
[getOverflowTx] :: OverflowTx -> [((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)]
newtype SmallBadSigsTx
SmallBadSigsTx :: BadSigsTx -> SmallBadSigsTx
newtype SmallHashMap
SmallHashMap :: (HashMap PublicKey (HashMap PublicKey (AsBinary Share))) -> SmallHashMap
newtype SmallGoodTx
SmallGoodTx :: GoodTx -> SmallGoodTx
newtype SmallOverflowTx
SmallOverflowTx :: OverflowTx -> SmallOverflowTx
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679190047 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.FixedSizeInt a_6989586621679190047)
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679190048 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.SignedVarInt a_6989586621679190048)
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679190049 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.UnsignedVarInt a_6989586621679190049)
instance GHC.Show.Show Pos.Types.Arbitrary.SmallHashMap
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.Timestamp
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.SoftwareVersion
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Units.Millisecond
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Units.Microsecond
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallHashMap
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.BlockVersion
instance GHC.Show.Show Pos.Types.Arbitrary.SmallBadSigsTx
instance GHC.Show.Show Pos.Types.Arbitrary.BadSigsTx
instance GHC.Show.Show Pos.Types.Arbitrary.SmallOverflowTx
instance GHC.Show.Show Pos.Types.Arbitrary.OverflowTx
instance GHC.Show.Show Pos.Types.Arbitrary.SmallGoodTx
instance GHC.Show.Show Pos.Types.Arbitrary.GoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.GoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallGoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.OverflowTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallOverflowTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.BadSigsTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallBadSigsTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.SharedSeed
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.ApplicationName
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxDistribution
instance System.Random.Random Pos.Types.Core.EpochIndex
instance System.Random.Random Pos.Types.Core.LocalSlotIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxOut
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.Coin
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.CoinPortion
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.EpochIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.LocalSlotIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.SlotId
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.EpochOrSlot
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.TxInWitness
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.ChainDifficulty
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Script.Type.Script
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Core.Address


-- | Functions related to blocks and headers.
module Pos.Types.Block

-- | Difficulty of the Block, which is determined from header.
blockDifficulty :: Block ssc -> ChainDifficulty

-- | Difficulty of the BlockHeader. 0 for genesis block, 1 for main block.
headerDifficulty :: BlockHeader ssc -> ChainDifficulty

-- | Smart constructor for <a>GenericBlock</a>. Uses
--   <tt>mkGenericBlockHeader</tt>.
mkGenericBlock :: forall b. (HasHeaderHash (BBlockHeader b), Blockchain b, BHeaderHash b ~ HeaderHash) => Maybe (BBlockHeader b) -> Body b -> (BHeaderHash b -> BodyProof b -> ConsensusData b) -> ExtraHeaderData b -> ExtraBodyData b -> GenericBlock b

-- | Smart constructor for <a>GenericBlockHeader</a>.
mkGenericHeader :: forall b. (HasHeaderHash (BBlockHeader b), Blockchain b, BHeaderHash b ~ HeaderHash) => Maybe (BBlockHeader b) -> Body b -> (BHeaderHash b -> BodyProof b -> ConsensusData b) -> ExtraHeaderData b -> GenericBlockHeader b

-- | Smart constructor for <a>MainBlock</a>. Uses <a>mkMainHeader</a>.
mkMainBlock :: BiSsc ssc => Maybe (BlockHeader ssc) -> SlotId -> SecretKey -> Maybe ProxySKEither -> Body (MainBlockchain ssc) -> MainExtraHeaderData -> MainExtraBodyData -> MainBlock ssc

-- | Smart constructor for <a>Body</a> of <a>MainBlockchain</a>.
mkMainBody :: [(Tx, TxWitness, TxDistribution)] -> SscPayload ssc -> [ProxySKSimple] -> UpdatePayload -> Body (MainBlockchain ssc)

-- | Smart constructor for <a>MainBlockHeader</a>.
mkMainHeader :: BiSsc ssc => Maybe (BlockHeader ssc) -> SlotId -> SecretKey -> Maybe ProxySKEither -> Body (MainBlockchain ssc) -> MainExtraHeaderData -> MainBlockHeader ssc

-- | Smart constructor for <a>GenesisBlockHeader</a>. Uses
--   <a>mkGenericHeader</a>.
mkGenesisHeader :: BiSsc ssc => Maybe (BlockHeader ssc) -> EpochIndex -> Body (GenesisBlockchain ssc) -> GenesisBlockHeader ssc

-- | Smart constructor for <a>GenesisBlock</a>. Uses
--   <a>mkGenesisHeader</a>.
mkGenesisBlock :: BiSsc ssc => Maybe (BlockHeader ssc) -> EpochIndex -> SlotLeaders -> GenesisBlock ssc

-- | Predefined <a>Hash</a> of <a>GenesisBlock</a>.
genesisHash :: Hash a

-- | Parameters of Block static verification. Note: to check that block
--   references previous block and/or is referenced by next block, use
--   header verification (via vbpVerifyHeader).
data VerifyBlockParams ssc
VerifyBlockParams :: !(Maybe (VerifyHeaderParams ssc)) -> !Bool -> !Bool -> !Bool -> !Bool -> VerifyBlockParams ssc

-- | Verifies header accordingly to params (<a>verifyHeader</a>)
[vbpVerifyHeader] :: VerifyBlockParams ssc -> !(Maybe (VerifyHeaderParams ssc))

-- | Checks <tt>verifyGenesisBlock</tt> property.
[vbpVerifyGeneric] :: VerifyBlockParams ssc -> !Bool

-- | Checks that each transaction passes <a>verifyTxAlone</a> check.
[vbpVerifyTxs] :: VerifyBlockParams ssc -> !Bool

-- | Verifies ssc payload with <a>sscVerifyPayload</a>.
[vbpVerifySsc] :: VerifyBlockParams ssc -> !Bool

-- | Check that's number of sks is limited (1000 for now).
[vbpVerifyProxySKs] :: VerifyBlockParams ssc -> !Bool

-- | Extra data which may be used by verifyHeader function to do more
--   checks.
data VerifyHeaderParams ssc
VerifyHeaderParams :: !Bool -> !(Maybe (BlockHeader ssc)) -> !(Maybe (BlockHeader ssc)) -> !(Maybe SlotId) -> !(Maybe SlotLeaders) -> VerifyHeaderParams ssc
[vhpVerifyConsensus] :: VerifyHeaderParams ssc -> !Bool

-- | Nothing means that block is unknown, not genesis.
[vhpPrevHeader] :: VerifyHeaderParams ssc -> !(Maybe (BlockHeader ssc))
[vhpNextHeader] :: VerifyHeaderParams ssc -> !(Maybe (BlockHeader ssc))
[vhpCurrentSlot] :: VerifyHeaderParams ssc -> !(Maybe SlotId)
[vhpLeaders] :: VerifyHeaderParams ssc -> !(Maybe SlotLeaders)

-- | Check predicates defined by VerifyBlockParams. #verifyHeader
--   #verifyGenericBlock
verifyBlock :: (SscHelpersClass ssc, BiSsc ssc) => VerifyBlockParams ssc -> Block ssc -> VerificationRes

-- | Verify a sequence of blocks.
--   
--   foldl' is used here which eliminates laziness of triple. It doesn't
--   affect laziness of <a>VerificationRes</a> which is good because
--   laziness for this data type is crucial.
verifyBlocks :: forall ssc f t. (SscHelpersClass ssc, BiSsc ssc, t ~ OldestFirst f (Block ssc), NontrivialContainer t) => Maybe SlotId -> Maybe SlotLeaders -> OldestFirst f (Block ssc) -> VerificationRes

-- | Perform cheap checks of GenericBlock, which can be done using only
--   block itself. Checks which can be done using only header are ignored
--   here. It is assumed that they will be done separately.
verifyGenericBlock :: forall b. Blockchain b => GenericBlock b -> VerificationRes

-- | Check some predicates (determined by VerifyHeaderParams) about
--   BlockHeader. #verifyConsensusLocal
verifyHeader :: forall ssc. BiSsc ssc => VerifyHeaderParams ssc -> BlockHeader ssc -> VerificationRes

-- | Verifies a set of block headers.
verifyHeaders :: BiSsc ssc => Bool -> NewestFirst [] (BlockHeader ssc) -> VerificationRes

-- | Compute size of <a>MainBlock</a> in bytes.
blockSize :: Ssc ssc => MainBlock ssc -> Byte
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Types.Block.VerifyHeaderParams ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Types.Block.VerifyHeaderParams ssc)
instance Data.Default.Class.Default (Pos.Types.Block.VerifyHeaderParams ssc)
instance Data.Default.Class.Default (Pos.Types.Block.VerifyBlockParams ssc)


-- | Slotting types.
module Pos.Types.Slotting

-- | Flatten <a>SlotId</a> (which is basically pair of integers) into a
--   single number.
flattenSlotId :: SlotId -> FlatSlotId

-- | Flattens <a>EpochIndex</a> into a single number.
flattenEpochIndex :: EpochIndex -> FlatSlotId

-- | Transforms some <a>HasEpochOrSlot</a> to a single number.
flattenEpochOrSlot :: (HasEpochOrSlot a) => a -> FlatSlotId

-- | Construct <a>SlotId</a> from a flattened variant.
unflattenSlotId :: FlatSlotId -> SlotId

-- | Slot such that at the beginning of epoch blocks with SlotId ≤- this
--   slot are stable.
crucialSlot :: EpochIndex -> SlotId
instance GHC.Enum.Enum Pos.Types.Core.SlotId


-- | Re-export of Pos.Types.* + binary instances
module Pos.Types

-- | Coin is the least possible unit of currency.
data Coin

-- | CoinPortion is some portion of Coin, it must be in [0 ..
--   coinPortionDenominator]. Main usage of it is multiplication with Coin.
--   Usually it's needed to determine some threshold expressed as portion
--   of total stake.
data CoinPortion

-- | Coin formatter which restricts type.
coinF :: Format r (Coin -> r)

-- | Unwraps <a>Coin</a>. It's called “unsafe” so that people wouldn't use
--   it willy-nilly if they want to sum coins or something. It's actually
--   safe.
unsafeGetCoin :: Coin -> Word64
getCoinPortion :: CoinPortion -> Word64

-- | Make Coin from Word64.
mkCoin :: Word64 -> Coin

-- | Denominator used by <a>CoinPortion</a>.
coinPortionDenominator :: Word64

-- | Make <a>CoinPortion</a> from <a>Word64</a> checking whether it is not
--   greater than <a>coinPortionDenominator</a>.
mkCoinPortion :: MonadFail m => Word64 -> m CoinPortion

-- | Make CoinPortion from Double. Caller must ensure that value is in [0
--   .. 1]. Internally <a>CoinPortion</a> stores <a>Word64</a> which is
--   divided by <a>coinPortionDenominator</a> to get actual value. So some
--   rounding may take place.
unsafeCoinPortionFromDouble :: Double -> CoinPortion

-- | Index of epoch.
newtype EpochIndex
EpochIndex :: Word64 -> EpochIndex
[getEpochIndex] :: EpochIndex -> Word64

-- | Class for something that has <a>EpochIndex</a>.
class HasEpochIndex a
epochIndexL :: HasEpochIndex a => Lens' a EpochIndex

-- | FlatSlotId is a flat version of SlotId
type FlatSlotId = Word64

-- | Index of slot inside a concrete epoch.
newtype LocalSlotIndex
LocalSlotIndex :: Word16 -> LocalSlotIndex
[getSlotIndex] :: LocalSlotIndex -> Word16

-- | Slot is identified by index of epoch and local index of slot in this
--   epoch. This is a global index
data SlotId
SlotId :: !EpochIndex -> !LocalSlotIndex -> SlotId
[siEpoch] :: SlotId -> !EpochIndex
[siSlot] :: SlotId -> !LocalSlotIndex

-- | Represents SlotId or EpochIndex. Useful because genesis blocks have
--   only EpochIndex, while main blocks have SlotId.
newtype EpochOrSlot
EpochOrSlot :: Either EpochIndex SlotId -> EpochOrSlot
[unEpochOrSlot] :: EpochOrSlot -> Either EpochIndex SlotId
class HasEpochOrSlot a where getEpochOrSlot = EpochOrSlot . _getEpochOrSlot epochOrSlotG = to getEpochOrSlot
_getEpochOrSlot :: HasEpochOrSlot a => a -> Either EpochIndex SlotId
getEpochOrSlot :: HasEpochOrSlot a => a -> EpochOrSlot
epochOrSlotG :: HasEpochOrSlot a => Getter a EpochOrSlot

-- | Timestamp is a number which represents some point in time. It is used
--   in MonadSlots and its meaning is up to implementation of this type
--   class. The only necessary knowledge is that difference between
--   timestamps is microsecond. Hence underlying type is Microsecond.
newtype Timestamp
Timestamp :: Microsecond -> Timestamp
[getTimestamp] :: Timestamp -> Microsecond

-- | Specialized formatter for <a>SlotId</a>.
slotIdF :: Format r (SlotId -> r)

-- | Apply one of the function depending on content of EpochOrSlot.
epochOrSlot :: (EpochIndex -> a) -> (SlotId -> a) -> EpochOrSlot -> a

-- | Address is where you can send coins.
data Address
PubKeyAddress :: !(AddressHash PublicKey) -> Address
[addrKeyHash] :: Address -> !(AddressHash PublicKey)
ScriptAddress :: !(AddressHash Script) -> Address
[addrScriptHash] :: Address -> !(AddressHash Script)
type AddressHash = AbstractHash Blake2s_224

-- | Stakeholder identifier (stakeholders are identified by their public
--   keys)
type StakeholderId = AddressHash PublicKey

-- | Chain difficulty represents necessary effort to generate a chain. In
--   the simplest case it can be number of blocks in chain.
newtype ChainDifficulty
ChainDifficulty :: Word64 -> ChainDifficulty
[getChainDifficulty] :: ChainDifficulty -> Word64

-- | Type class for something that has <a>ChainDifficulty</a>.
class HasDifficulty a
difficultyL :: HasDifficulty a => Lens' a ChainDifficulty
newtype ApplicationName
ApplicationName :: Text -> ApplicationName
[getApplicationName] :: ApplicationName -> Text

-- | Communication protocol version.
data BlockVersion
BlockVersion :: !Word16 -> !Word16 -> !Word8 -> BlockVersion
[bvMajor] :: BlockVersion -> !Word16
[bvMinor] :: BlockVersion -> !Word16
[bvAlt] :: BlockVersion -> !Word8

-- | Numeric software version associated with ApplicationName.
type NumSoftwareVersion = Word32

-- | Software version.
data SoftwareVersion
SoftwareVersion :: !ApplicationName -> !NumSoftwareVersion -> SoftwareVersion
[svAppName] :: SoftwareVersion -> !ApplicationName
[svNumber] :: SoftwareVersion -> !NumSoftwareVersion
data BlockHeaderStub

-- | <a>Hash</a> of block header. This should be <tt>Hash (BlockHeader
--   ssc)</tt> but we don't want to have <tt>ssc</tt> in <a>HeaderHash</a>
--   type.
type HeaderHash = Hash BlockHeaderStub

-- | Class for something that has <a>HeaderHash</a>.
class HasHeaderHash a where headerHashG = to headerHash
headerHash :: HasHeaderHash a => a -> HeaderHash
headerHashG :: HasHeaderHash a => Getter a HeaderHash

-- | Specialized formatter for <a>HeaderHash</a>.
headerHashF :: Format r (HeaderHash -> r)


-- | Everything related to <i>follow-the-satoshi</i> procedure.
module Pos.Lrc.FollowTheSatoshi

-- | Choose several random stakeholders (specifically, their amount is
--   currently hardcoded in <a>epochSlots</a>).
--   
--   The probability that a stakeholder will be chosen is proportional to
--   the number of coins this stakeholder holds. The same stakeholder can
--   be picked more than once.
--   
--   How the algorithm works: we sort all unspent outputs in a
--   deterministic way (lexicographically) and have an ordered sequence of
--   pairs <tt>(StakeholderId, Coin)</tt>. Then we choose several random
--   <tt>i</tt>s between 1 and amount of satoshi in the system; to find
--   owner of <tt>i</tt>th coin we find the lowest x such that sum of all
--   coins in this list up to <tt>i</tt>th is not less than <tt>i</tt> (and
--   then <tt>x</tt>th address is the owner).
--   
--   With P2SH addresses, we don't know who is going to end up with funds
--   sent to them. Therefore, P2SH addresses can contain
--   <tt>addrDestination</tt> which specifies which addresses should count
--   as “owning” funds for the purposes of follow-the-satoshi.
followTheSatoshi :: SharedSeed -> Utxo -> NonEmpty StakeholderId

-- | A version of <a>followTheSatoshi</a> that uses an iterator over
--   <tt>TxOut</tt>s instead of <a>Utxo</a>.
followTheSatoshiM :: forall m. MonadIterator (StakeholderId, Coin) m => SharedSeed -> Coin -> m (NonEmpty StakeholderId)


-- | Blockchain genesis. Not to be confused with genesis block in epoch.
--   Blockchain genesis means genesis values which are hardcoded in advance
--   (before system starts doing anything). Genesis block in epoch exists
--   in every epoch and it's not known in advance.
module Pos.Genesis

-- | Stake distribution in genesis block. FlatStakes is a flat
--   distribution, i. e. each node has the same amount of coins.
--   BitcoinStakes is a Bitcoin mining pool-style ditribution.
data StakeDistribution
FlatStakes :: !Word -> !Coin -> StakeDistribution
BitcoinStakes :: !Word -> !Coin -> StakeDistribution
TestnetStakes :: !Coin -> !Word -> !Word -> StakeDistribution
[sdTotalStake] :: StakeDistribution -> !Coin
[sdRichmen] :: StakeDistribution -> !Word
[sdPoor] :: StakeDistribution -> !Word
ExponentialStakes :: StakeDistribution
ExplicitStakes :: !(HashMap Address Coin) -> StakeDistribution

-- | Hardcoded genesis data
data GenesisData
GenesisData :: [Address] -> StakeDistribution -> VssCertificatesMap -> GenesisData
[gdAddresses] :: GenesisData -> [Address]
[gdDistribution] :: GenesisData -> StakeDistribution
[gdVssCertificates] :: GenesisData -> VssCertificatesMap

-- | Fetch pre-generated genesis data from <i>genesis.bin</i> in compile
--   time Doesn't use TH with lift because it's difficult to provide
--   <tt>Lift</tt> instance to <a>GenesisData</a>
compileGenData :: GenesisData

-- | List of <tt>Address'</tt>es in genesis. See <a>genesisPublicKeys</a>.
genesisAddresses :: [Address]

-- | List of pairs from <a>SecretKey</a> with corresponding
--   <a>PublicKey</a>.
genesisKeyPairs :: [(PublicKey, SecretKey)]

-- | List of <tt>PublicKey'</tt>s in genesis.
genesisPublicKeys :: [PublicKey]

-- | List of <tt>SecrekKey'</tt>s in genesis.
genesisSecretKeys :: [SecretKey]
genesisStakeDistribution :: StakeDistribution

-- | Genesis <a>Utxo</a>.
genesisUtxo :: StakeDistribution -> Utxo
genesisDelegation :: HashMap StakeholderId [StakeholderId]

-- | Leaders of genesis. See <a>followTheSatoshi</a>.
genesisLeaders :: Utxo -> SlotLeaders

-- | BlockVersion used at the very beginning.
genesisBlockVersion :: BlockVersion

-- | <a>BlockVersionData</a> for genesis <a>BlockVersion</a>.
genesisBlockVersionData :: BlockVersionData

-- | Software Versions
genesisSoftwareVersions :: [SoftwareVersion]

-- | ScriptVersion used at the very beginning
genesisScriptVersion :: ScriptVersion

-- | Initial slot duration
genesisSlotDuration :: Millisecond

-- | Initial block size limit
genesisMaxBlockSize :: Byte
instance Data.Default.Class.Default Pos.Genesis.Types.StakeDistribution


-- | Slotting functionality.
module Pos.Slotting

-- | Type class providing information about time when system started
--   functioning.
class Monad m => MonadSlots m where getSystemStartTime = lift getSystemStartTime getCurrentTime = lift getCurrentTime getCurrentSlot = lift getCurrentSlot getSlotDuration = lift getSlotDuration
getSystemStartTime :: MonadSlots m => m Timestamp
getCurrentTime :: MonadSlots m => m Timestamp
getCurrentSlot :: MonadSlots m => m SlotId
getSlotDuration :: MonadSlots m => m Millisecond
getSystemStartTime :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m Timestamp
getCurrentTime :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m Timestamp
getCurrentSlot :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m SlotId
getSlotDuration :: (MonadSlots m, MonadTrans t, MonadSlots m', t m' ~ m) => m Millisecond

-- | Get flat id of current slot based on MonadSlots.
getCurrentSlotFlat :: MonadSlots m => m FlatSlotId

-- | Get timestamp when given slot starts.
getSlotStart :: MonadSlots m => SlotId -> m Timestamp
getCurrentSlotUsingNtp :: (MonadSlots m, Mockable CurrentTime m) => SlotId -> (Microsecond, Microsecond) -> m SlotId

-- | Run given action as soon as new slot starts, passing SlotId to it.
--   This function uses Mockable and assumes consistency between MonadSlots
--   and Mockable implementations.
onNewSlot :: (MonadIO m, MonadSlots m, MonadCatch m, WithLogger m, Mockable Fork m, Mockable Delay m) => Bool -> (SlotId -> m ()) -> m a

-- | Same as onNewSlot, but also logs debug information.
onNewSlotWithLogging :: (MonadIO m, MonadSlots m, MonadCatch m, WithLogger m, Mockable Fork m, Mockable Delay m) => Bool -> (SlotId -> m ()) -> m a

-- | Data needed for the slotting algorithm to work.
data SlottingState
SlottingState :: !Millisecond -> !SlotId -> !(Microsecond, Microsecond) -> SlottingState

-- | Current slot duration. (It can be changed by update proposals.)
[ssSlotDuration] :: SlottingState -> !Millisecond

-- | Slot which was returned from getCurrentSlot in last time
[ssNtpLastSlot] :: SlottingState -> !SlotId

-- | Data for the NTP Worker. First element: margin (difference between
--   global time and local time) which we got from NTP server in last time.
--   Second element: time (local) for which we got margin in last time.
[ssNtpData] :: SlottingState -> !(Microsecond, Microsecond)
ssSlotDurationL :: Lens' SlottingState Millisecond
ssNtpLastSlotL :: Lens' SlottingState SlotId
ssNtpDataL :: Lens' SlottingState (Microsecond, Microsecond)
instance Pos.Slotting.MonadSlots m => Pos.Slotting.MonadSlots (Control.Monad.Trans.Reader.ReaderT s m)
instance Pos.Slotting.MonadSlots m => Pos.Slotting.MonadSlots (Control.Monad.Trans.Except.ExceptT s m)
instance Pos.Slotting.MonadSlots m => Pos.Slotting.MonadSlots (Control.Monad.Trans.State.Lazy.StateT s m)
instance Pos.Slotting.MonadSlots m => Pos.Slotting.MonadSlots (Pos.DHT.Real.Types.KademliaDHT m)


-- | GState DB stores whole global state, i. e. result of application of
--   all blocks up to <i>tip</i>.
module Pos.DB.GState

-- | Get total amount of stake to be used for follow-the-satoshi. It's
--   different from total amount of coins in the system.
getTotalFtsStake :: MonadDB ssc m => m Coin

-- | Get stake owne by given stakeholder (according to rules used for FTS).
getFtsStake :: MonadDB ssc m => StakeholderId -> m (Maybe Coin)
getFtsStakeFromDB :: (MonadIO m, MonadThrow m) => StakeholderId -> DB ssc -> m (Maybe Coin)
data BalancesOp
PutFtsSum :: !Coin -> BalancesOp
PutFtsStake :: !StakeholderId -> !Coin -> BalancesOp
prepareGStateBalances :: forall ssc m. MonadDB ssc m => Utxo -> m ()
data BalIter
runBalanceIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc BalIter a -> m a
runBalanceMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc BalIter v a -> (IterType BalIter -> v) -> m a
sanityCheckBalances :: (MonadMask m, MonadDB ssc m, WithLogger m) => m ()

-- | Tries to retrieve next block using current one (given a block/header).
resolveForwardLink :: (HasHeaderHash a, MonadDB ssc m) => a -> m (Maybe HeaderHash)

-- | Check if given hash representing block is in main chain.
isBlockInMainChain :: (HasHeaderHash a, MonadDB ssc m) => a -> m Bool
data BlockExtraOp

-- | Adds or overwrites forward link
AddForwardLink :: HeaderHash -> HeaderHash -> BlockExtraOp

-- | Removes forward link
RemoveForwardLink :: HeaderHash -> BlockExtraOp

-- | Enables or disables "in main chain" status of the block
SetInMainChain :: Bool -> HeaderHash -> BlockExtraOp

-- | Returns headers loaded up.
loadHeadersUpWhile :: (Ssc ssc, MonadDB ssc m, HasHeaderHash a) => a -> (BlockHeader ssc -> Int -> Bool) -> m (OldestFirst [] (BlockHeader ssc))

-- | Returns blocks loaded up.
loadBlocksUpWhile :: (Ssc ssc, MonadDB ssc m, HasHeaderHash a) => a -> (Block ssc -> Int -> Bool) -> m (OldestFirst [] (Block ssc))
prepareGStateBlockExtra :: MonadDB ssc m => HeaderHash -> m ()

-- | Get current tip from GState DB.
getTip :: (MonadDB ssc m) => m HeaderHash

-- | Get the hash of the first genesis block from GState DB.
getBot :: (MonadDB ssc m) => m HeaderHash

-- | Put missing initial common data into GState DB.
prepareGStateCommon :: forall ssc m. MonadDB ssc m => HeaderHash -> m ()
getBi :: (MonadDB ssc m, Bi v) => ByteString -> m (Maybe v)
putBi :: (MonadDB ssc m, Bi v) => ByteString -> v -> m ()
delete :: (MonadDB ssc m) => ByteString -> m ()
writeBatchGState :: (RocksBatchOp a, MonadDB ssc m) => [a] -> m ()
data CommonOp
PutTip :: HeaderHash -> CommonOp

-- | Retrieves certificate by issuer address (hash of public key) if
--   present.
getPSKByIssuerAddressHash :: MonadDB ssc m => StakeholderId -> m (Maybe ProxySKSimple)

-- | Retrieves certificate by issuer public key if present.
getPSKByIssuer :: MonadDB ssc m => PublicKey -> m (Maybe ProxySKSimple)
isIssuerByAddressHash :: MonadDB ssc m => StakeholderId -> m Bool
data DelegationOp

-- | Adds PSK. Overwrites if present.
AddPSK :: !ProxySKSimple -> DelegationOp

-- | Removes PSK by issuer PK.
DelPSK :: !PublicKey -> DelegationOp
runPskIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc PskIter a -> m a
runPskMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc PskIter v a -> (IterType PskIter -> v) -> m a

-- | Put missing initial data into GState DB.
prepareGStateDB :: forall ssc m. (WithNodeContext ssc m, MonadDB ssc m) => HeaderHash -> m ()

-- | Check that GState DB is consistent.
sanityCheckGStateDB :: forall ssc m. (MonadDB ssc m, MonadMask m, WithLogger m) => m ()
usingGStateSnapshot :: (MonadDB ssc m, MonadMask m) => m a -> m a

-- | Get last adopted block version.
getAdoptedBV :: MonadDB ssc m => m BlockVersion

-- | Get state of last adopted BlockVersion.
getAdoptedBVData :: MonadDB ssc m => m BlockVersionData

-- | Get last adopted BlockVersion and data associated with it.
getAdoptedBVFull :: MonadDB ssc m => m (BlockVersion, BlockVersionData)

-- | Get <a>BlockVersionState</a> associated with given BlockVersion.
getBVState :: MonadDB ssc m => BlockVersion -> m (Maybe BlockVersionState)

-- | Get state of UpdateProposal for given UpId
getProposalState :: MonadDB ssc m => UpId -> m (Maybe ProposalState)

-- | Get UpId of current proposal for given appName
getAppProposal :: MonadDB ssc m => ApplicationName -> m (Maybe UpId)

-- | Get state of Update Proposal for given AppName
getProposalStateByApp :: MonadDB ssc m => ApplicationName -> m (Maybe ProposalState)

-- | Get last confirmed SoftwareVersion of given application.
getConfirmedSV :: MonadDB ssc m => ApplicationName -> m (Maybe NumSoftwareVersion)

-- | Get actual slot duration.
getSlotDuration :: MonadDB ssc m => m Millisecond

-- | Get maximum block size (in bytes).
getMaxBlockSize :: MonadDB ssc m => m Byte
data UpdateOp
PutProposal :: !ProposalState -> UpdateOp
DeleteProposal :: !UpId -> !ApplicationName -> UpdateOp
ConfirmVersion :: !SoftwareVersion -> UpdateOp
DelConfirmedVersion :: !ApplicationName -> UpdateOp
AddConfirmedProposal :: !ConfirmedProposalState -> UpdateOp
DelConfirmedProposal :: !SoftwareVersion -> UpdateOp
SetAdopted :: !BlockVersion -> BlockVersionData -> UpdateOp
SetBVState :: !BlockVersion -> !BlockVersionState -> UpdateOp
DelBV :: !BlockVersion -> UpdateOp
prepareGStateUS :: forall ssc m. MonadDB ssc m => m ()
data PropIter
runProposalMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc PropIter v a -> (IterType PropIter -> v) -> m a
runProposalIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc PropIter a -> m a

-- | Get all proposals which were issued no later than given slot.
getOldProposals :: forall ssc m. MonadDB ssc m => SlotId -> m [UndecidedProposalState]

-- | Get all decided proposals which were accepted deeper than given
--   difficulty.
getDeepProposals :: forall ssc m. MonadDB ssc m => ChainDifficulty -> m [DecidedProposalState]
data ConfPropIter

-- | Get confirmed proposals which update our application and have version
--   bigger than argument (or all proposals if <a>Nothing</a> is passed).
--   For instance, current software version can be passed to this function
--   to get all proposals with bigger version.
getConfirmedProposals :: MonadDB ssc m => Maybe NumSoftwareVersion -> m [ConfirmedProposalState]
data BVIter

-- | Get all proposed <a>BlockVersion</a>s.
getProposedBVs :: MonadDB ssc m => m [BlockVersion]

-- | Get all confirmed <a>BlockVersion</a>s and their states.
getConfirmedBVStates :: MonadDB ssc m => m [(BlockVersion, BlockVersionState)]
getProposedBVStates :: MonadDB ssc m => m [BlockVersionState]

-- | Get genesis utxo
getGenUtxo :: (MonadThrow m, MonadDB ssc m) => m Utxo
getTxOutFromDB :: (MonadIO m, MonadThrow m) => TxIn -> DB ssc -> m (Maybe TxOutAux)
getTxOut :: MonadDB ssc m => TxIn -> m (Maybe TxOutAux)
data UtxoOp
DelTxIn :: !TxIn -> UtxoOp
AddTxOut :: !TxIn -> !TxOutAux -> UtxoOp
prepareGStateUtxo :: forall ssc m. MonadDB ssc m => Utxo -> m ()
data UtxoIter
runUtxoIterator :: forall m ssc a. MonadDB ssc m => DBnIterator ssc UtxoIter a -> m a
runUtxoMapIterator :: forall v m ssc a. MonadDB ssc m => DBnMapIterator ssc UtxoIter v a -> (IterType UtxoIter -> v) -> m a

-- | Get small sub-utxo containing only outputs of given address
getFilteredUtxo :: MonadDB ssc m => Address -> m Utxo
sanityCheckUtxo :: (MonadDB ssc m, WithLogger m) => Coin -> m ()


-- | This module defines type class for local data storage.
module Pos.Ssc.Class.LocalData
type LocalQuery ssc a = forall m. (MonadReader (SscLocalData ssc) m) => m a
type LocalUpdate ssc a = forall m. (MonadState (SscLocalData ssc) m) => m a

-- | This type class abstracts local data used for SSC. Local means that it
--   is not stored in blocks.
class Ssc ssc => SscLocalDataClass ssc

-- | Get local payload to be put into main block and SlotId for which it's
--   valid (wrt current tip).
sscGetLocalPayloadQ :: SscLocalDataClass ssc => LocalQuery ssc (SlotId, SscPayload ssc)

-- | Update LocalData using global data from blocks (last version of best
--   known chain).
sscApplyGlobalStateU :: SscLocalDataClass ssc => Richmen -> SscGlobalState ssc -> LocalUpdate ssc ()


-- | Storage for generic Shared Seed calculation implementation.
module Pos.Ssc.Class.Storage
class Ssc ssc => SscStorageClass ssc
sscLoadGlobalState :: (SscStorageClass ssc, MonadDB ssc m, WithLogger m) => m (SscGlobalState ssc)
sscApplyBlocksM :: SscStorageClass ssc => OldestFirst NE (Block ssc) -> SscGlobalUpdate ssc ()

-- | Rollback application of blocks.
sscRollbackM :: SscStorageClass ssc => NewestFirst NE (Block ssc) -> SscGlobalUpdate ssc ()

-- | Verify Ssc-related predicates of block sequence which is about to be
--   applied. It should check that SSC payload will be consistent if this
--   blocks are applied (after possible rollback if first argument isn't
--   zero).
sscVerifyBlocksM :: SscStorageClass ssc => Bool -> Richmen -> OldestFirst NE (Block ssc) -> SscGlobalQuery ssc (Either (SscVerifyError ssc) ())
sscCalculateSeedM :: SscStorageClass ssc => EpochIndex -> SscGlobalQuery ssc (Either (SscSeedError ssc) SharedSeed)
type SscGlobalQuery ssc a = forall m. (MonadReader (SscGlobalState ssc) m, WithLogger m) => m a
type SscGlobalUpdate ssc a = forall m. (MonadState (SscGlobalState ssc) m) => m a


-- | Re-exports of Pos.DB functionality.
module Pos.DB

-- | Get block with given hash from Block DB.
getBlock :: (Ssc ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (Block ssc))

-- | Returns header of block that was requested from Block DB.
getBlockHeader :: (Ssc ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (BlockHeader ssc))

-- | Get StoredBlock by hash from Block DB.
getStoredBlock :: (Ssc ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (StoredBlock ssc))

-- | Get undo data for block with given hash from Block DB.
getUndo :: MonadDB ssc m => HeaderHash -> m (Maybe Undo)

-- | Retrieves block and undo together.
getBlockWithUndo :: (Ssc ssc, MonadDB ssc m) => HeaderHash -> m (Maybe (Block ssc, Undo))
deleteBlock :: (MonadDB ssc m) => HeaderHash -> m ()

-- | Put given block, its metadata and Undo data into Block DB.
putBlock :: (Ssc ssc, MonadDB ssc m) => Undo -> Block ssc -> m ()
prepareBlockDB :: forall ssc m. (Ssc ssc, MonadDB ssc m) => GenesisBlock ssc -> m ()

-- | Load blunds starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadBlundsWhile :: (Ssc ssc, MonadDB ssc m) => (Block ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (Blund ssc))

-- | Load blunds which have depth less than given.
loadBlundsByDepth :: (Ssc ssc, MonadDB ssc m) => Word -> HeaderHash -> m (NewestFirst [] (Blund ssc))

-- | Load blocks starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadBlocksWhile :: (Ssc ssc, MonadDB ssc m) => (Block ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (Block ssc))

-- | Load headers starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadHeadersWhile :: (Ssc ssc, MonadDB ssc m) => (BlockHeader ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))

-- | Load headers which have depth less than given.
loadHeadersByDepth :: (Ssc ssc, MonadDB ssc m) => Word -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))

-- | Load headers which have depth less than given and match some
--   criterion.
loadHeadersByDepthWhile :: (Ssc ssc, MonadDB ssc m) => (BlockHeader ssc -> Bool) -> Word -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))
class (MonadIO m, MonadThrow m) => MonadDB ssc m | m -> ssc
getNodeDBs :: MonadDB ssc m => m (NodeDBs ssc)
usingReadOptions :: MonadDB ssc m => ReadOptions -> ASetter' (NodeDBs ssc) (DB ssc) -> m a -> m a
usingWriteOptions :: MonadDB ssc m => WriteOptions -> ASetter' (NodeDBs ssc) (DB ssc) -> m a -> m a
getBlockDB :: MonadDB ssc m => m (DB ssc)
getUtxoDB :: MonadDB ssc m => m (DB ssc)
getLrcDB :: MonadDB ssc m => m (DB ssc)
getMiscDB :: MonadDB ssc m => m (DB ssc)

-- | Open all DBs stored on disk.
openNodeDBs :: (MonadIO m) => Bool -> FilePath -> m (NodeDBs ssc)

-- | Initialize DBs if necessary.
initNodeDBs :: forall ssc m. (Ssc ssc, WithNodeContext ssc m, MonadDB ssc m) => m ()

-- | Get current tip from GState DB.
getTip :: (MonadDB ssc m) => m HeaderHash

-- | Get block corresponding to tip.
getTipBlock :: (Ssc ssc, MonadDB ssc m) => m (Block ssc)

-- | Get BlockHeader corresponding to tip.
getTipBlockHeader :: (Ssc ssc, MonadDB ssc m) => m (BlockHeader ssc)

-- | Load blunds from BlockDB starting from tip and while the
--   <tt>condition</tt> is true.
loadBlundsFromTipWhile :: (Ssc ssc, MonadDB ssc m) => (Block ssc -> Bool) -> m (NewestFirst [] (Blund ssc))

-- | Load blunds from BlockDB starting from tip which have depth less than
--   given.
loadBlundsFromTipByDepth :: (Ssc ssc, MonadDB ssc m) => Word -> m (NewestFirst [] (Blund ssc))
sanityCheckDB :: (MonadMask m, MonadDB ssc m, WithLogger m) => m ()
class DBIteratorClass i where type IterKey i :: * type IterValue i :: * where {
    type family IterKey i :: *;
    type family IterValue i :: *;
}
iterKeyPrefix :: DBIteratorClass i => Proxy i -> ByteString
type IterType i = (IterKey i, IterValue i)
newtype DBIterator i m a
DBIterator :: ReaderT Iterator m a -> DBIterator i m a
[getDBIterator] :: DBIterator i m a -> ReaderT Iterator m a

-- | Encapsulate `map f elements`, where <tt>elements</tt> - collection
--   elements of type <tt>a</tt>. Holds `DBIterator m a` and apply f for
--   every <a>nextItem</a> and <a>curItem</a> call. If f :: a -&gt; b then
--   we iterate by collection elements of type b.
newtype DBMapIterator i v m a
DBMapIterator :: ReaderT (IterType i -> v) (DBIterator i m) a -> DBMapIterator i v m a
[getDBMapIterator] :: DBMapIterator i v m a -> ReaderT (IterType i -> v) (DBIterator i m) a
type DBKeyIterator i = DBMapIterator i (IterKey i)
type DBValueIterator i = DBMapIterator i (IterValue i)
type DBnIterator ssc i = DBHolder ssc (DBIterator i IO)
type DBnMapIterator ssc i v = DBHolder ssc (DBMapIterator i v IO)
runDBnIterator :: forall i m ssc a. (MonadDB ssc m, DBIteratorClass i) => (NodeDBs ssc -> DB ssc) -> DBnIterator ssc i a -> m a
runDBnMapIterator :: forall i v m ssc a. (MonadDB ssc m, DBIteratorClass i) => (NodeDBs ssc -> DB ssc) -> DBnMapIterator ssc i v a -> (IterType i -> v) -> m a

-- | Run DBIterator by `DB ssc`.
runIterator :: forall i a m ssc. (MonadIO m, MonadMask m, DBIteratorClass i) => DBIterator i m a -> DB ssc -> m a

-- | Run DBMapIterator by `DB ssc`.
runMapIterator :: forall i v m ssc a. (MonadIO m, MonadMask m, DBIteratorClass i) => DBMapIterator i v m a -> (IterType i -> v) -> DB ssc -> m a
data DBError

-- | Structure of DB is malformed (e. g. data is inconsistent, something is
--   missing, etc.)
DBMalformed :: !Text -> DBError
openDB :: MonadIO m => FilePath -> m (DB ssc)
encodeWithKeyPrefix :: forall i. (DBIteratorClass i, Bi (IterKey i)) => IterKey i -> ByteString
rocksDelete :: (MonadIO m) => ByteString -> DB ssc -> m ()

-- | Read serialized value from RocksDB using given key.
rocksGetBi :: forall v m ssc. (Bi v, MonadIO m, MonadThrow m) => ByteString -> DB ssc -> m (Maybe v)

-- | Read ByteString from RocksDb using given key.
rocksGetBytes :: (MonadIO m) => ByteString -> DB ssc -> m (Maybe ByteString)

-- | Write serializable value to RocksDb for given key.
rocksPutBi :: (Bi v, MonadIO m) => ByteString -> v -> DB ssc -> m ()

-- | Write ByteString to RocksDB for given key.
rocksPutBytes :: (MonadIO m) => ByteString -> ByteString -> DB ssc -> m ()
rocksDecodeWP :: forall i m. (MonadThrow m, DBIteratorClass i, Bi (IterKey i)) => ByteString -> m (IterKey i)
rocksDecodeMaybe :: (Bi v) => ByteString -> Maybe v
rocksDecodeMaybeWP :: forall i. (DBIteratorClass i, Bi (IterKey i)) => ByteString -> Maybe (IterKey i)
rocksDecodeKeyValMaybe :: (Bi k, Bi v) => (ByteString, ByteString) -> Maybe (k, v)
class RocksBatchOp a
toBatchOp :: RocksBatchOp a => a -> [BatchOp]
data SomeBatchOp
SomeBatchOp :: a -> SomeBatchOp
data SomePrettyBatchOp
SomePrettyBatchOp :: a -> SomePrettyBatchOp

-- | Write Batch encapsulation
rocksWriteBatch :: (RocksBatchOp a, MonadIO m) => [a] -> DB ssc -> m ()
newtype DBHolder ssc m a
DBHolder :: ReaderT (NodeDBs ssc) m a -> DBHolder ssc m a
[getDBHolder] :: DBHolder ssc m a -> ReaderT (NodeDBs ssc) m a

-- | Execute <a>DBHolder</a> action with given <tt>NodeState</tt>.
runDBHolder :: NodeDBs ssc -> DBHolder ssc m a -> m a
prepareMiscDB :: forall ssc m. (MonadDB ssc m) => m ()

-- | Gets proxy secret keys stored by node
getProxySecretKeys :: MonadDB ssc m => m [ProxySKEpoch]

-- | Adds proxy secret key if not present. Nothing if present.
addProxySecretKey :: MonadDB ssc m => ProxySKEpoch -> m ()

-- | Removes proxy secret key if present by issuer pk.
removeProxySecretKey :: MonadDB ssc m => PublicKey -> m ()

-- | Given epochindex, throws away all outdated PSKs. Remark: it doesn't
--   remove keys that can be used in future.
dropOldProxySecretKeys :: MonadDB ssc m => EpochIndex -> m ()
getSecretStorage :: MonadDB SscGodTossing m => m (Maybe GtSecretStorage)
putSecretStorage :: MonadDB SscGodTossing m => GtSecretStorage -> m ()

-- | Puts or overwrites secret key of the node. Returns if it was
--   overwritten.
putSecretKeyHash :: MonadDB ssc m => Hash SecretKey -> m Bool

-- | Checks if given secret key hash matches the hash in the database. Puts
--   it into the database and return True if nothing was stored there.
checkSecretKeyHash :: MonadDB ssc m => Hash SecretKey -> m Bool
data DB ssc
DB :: !ReadOptions -> !WriteOptions -> !Options -> !DB -> DB ssc
[rocksReadOpts] :: DB ssc -> !ReadOptions
[rocksWriteOpts] :: DB ssc -> !WriteOptions
[rocksOptions] :: DB ssc -> !Options
[rocksDB] :: DB ssc -> !DB
data NodeDBs ssc
NodeDBs :: !(DB ssc) -> !(DB ssc) -> !(DB ssc) -> !(DB ssc) -> NodeDBs ssc

-- | Blocks, block index, undo data.
[_blockDB] :: NodeDBs ssc -> !(DB ssc)

-- | Global state corresponding to some tip.
[_gStateDB] :: NodeDBs ssc -> !(DB ssc)

-- | Data computed by LRC.
[_lrcDB] :: NodeDBs ssc -> !(DB ssc)

-- | Everything small and insignificant
[_miscDB] :: NodeDBs ssc -> !(DB ssc)
blockDB :: forall ssc_a6xoH. Lens' (NodeDBs ssc_a6xoH) (DB ssc_a6xoH)
gStateDB :: forall ssc_a6xoH. Lens' (NodeDBs ssc_a6xoH) (DB ssc_a6xoH)
lrcDB :: forall ssc_a6xoH. Lens' (NodeDBs ssc_a6xoH) (DB ssc_a6xoH)
miscDB :: forall ssc_a6xoH. Lens' (NodeDBs ssc_a6xoH) (DB ssc_a6xoH)
newtype Snapshot
Snapshot :: Snapshot -> Snapshot
usingSnapshot :: (MonadIO m, MonadMask m) => DB ssc -> (Snapshot -> m a) -> m a
data StoredBlock ssc
StoredBlock :: !(Block ssc) -> StoredBlock ssc

-- | Block itself.
[sbBlock] :: StoredBlock ssc -> !(Block ssc)
data LeadersStorage ssc
LeadersStorage :: !EpochIndex -> !SlotLeaders -> LeadersStorage ssc
[lrcEpoch] :: LeadersStorage ssc -> !EpochIndex
[lrcLeaders] :: LeadersStorage ssc -> !SlotLeaders
data GtRichmenStorage ssc
GtRichmenStorage :: !EpochIndex -> !RichmenStake -> GtRichmenStorage ssc
[gtRichmenEpoch] :: GtRichmenStorage ssc -> !EpochIndex
[gtRichmen] :: GtRichmenStorage ssc -> !RichmenStake


-- | Monadic represantion of something that has <tt>json</tt> journaled log
--   of operations.
module Pos.Util.JsonLog

-- | Json log event.
data JLEvent
JLCreatedBlock :: JLBlock -> JLEvent
JLAdoptedBlock :: BlockId -> JLEvent
JLTpsStat :: Int -> JLEvent

-- | Json log of one block with corresponding <a>BlockId</a>.
data JLBlock
JLBlock :: BlockId -> BlockId -> [TxId] -> JLSlotId -> JLBlock
[jlHash] :: JLBlock -> BlockId
[jlPrevBlock] :: JLBlock -> BlockId
[jlTxs] :: JLBlock -> [TxId]
[jlSlot] :: JLBlock -> JLSlotId

-- | <a>JLEvent</a> with <tt>Timestamp</tt> -- corresponding time of this
--   event.
data JLTimedEvent
JLTimedEvent :: Integer -> JLEvent -> JLTimedEvent
[jlTimestamp] :: JLTimedEvent -> Integer
[jlEvent] :: JLTimedEvent -> JLEvent

-- | Return event of created block.
jlCreatedBlock :: BiSsc ssc => Block ssc -> JLEvent

-- | Returns event of created <a>Block</a>.
jlAdoptedBlock :: Ssc ssc => Block ssc -> JLEvent

-- | Monad for things that can log Json log events.
class Monad m => MonadJL m
jlLog :: MonadJL m => JLEvent -> m ()

-- | Append event into log by given <a>FilePath</a>.
appendJL :: (MonadIO m) => FilePath -> JLEvent -> m ()

-- | Get <a>SlotId</a> from <a>JLSlotId</a>.
fromJLSlotId :: JLSlotId -> SlotId
instance Data.Aeson.Types.Class.ToJSON Pos.Util.JsonLog.JLTimedEvent
instance Data.Aeson.Types.Class.FromJSON Pos.Util.JsonLog.JLTimedEvent
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Control.Monad.Trans.Reader.ReaderT s m)
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Aeson.Types.Class.ToJSON Pos.Util.JsonLog.JLEvent
instance Data.Aeson.Types.Class.FromJSON Pos.Util.JsonLog.JLEvent
instance Data.Aeson.Types.Class.ToJSON Pos.Util.JsonLog.JLBlock
instance Data.Aeson.Types.Class.FromJSON Pos.Util.JsonLog.JLBlock
instance GHC.Show.Show Pos.Util.JsonLog.JLTimedEvent
instance GHC.Show.Show Pos.Util.JsonLog.JLEvent
instance GHC.Show.Show Pos.Util.JsonLog.JLBlock


-- | Re-exports of Pos.Context.* functionality.
module Pos.Context

-- | Class for something that has <a>NodeContext</a> inside.
class WithNodeContext ssc m | m -> ssc
getNodeContext :: WithNodeContext ssc m => m (NodeContext ssc)

-- | Data used for LRC syncronization. First value is <b>False</b> iff LRC
--   is running now. Second value is last epoch for which we have already
--   computed LRC.
type LrcSyncData = (Bool, EpochIndex)

-- | NodeContext contains runtime context of node.
data NodeContext ssc
NodeContext :: !Timestamp -> !SecretKey -> !Utxo -> !SlotLeaders -> !(TVar SlottingState) -> !Bool -> !(Maybe (MVar FilePath)) -> !FilePath -> !(SscNodeContext ssc) -> ![AttackType] -> ![AttackTarget] -> !Bool -> !(MVar HeaderHash) -> !(TVar LrcSyncData) -> !(TVar UserSecret) -> !FilePath -> !(TBQueue (NodeId, NewestFirst NE (BlockHeader ssc))) -> !(TMVar (NodeId, BlockHeader ssc)) -> !(MVar ConfirmedProposalState) -> NodeContext ssc

-- | Time when system started working.
[ncSystemStart] :: NodeContext ssc -> !Timestamp

-- | Secret key used for blocks creation.
[ncSecretKey] :: NodeContext ssc -> !SecretKey

-- | Genesis utxo
[ncGenesisUtxo] :: NodeContext ssc -> !Utxo

-- | Leaders for 0-th epoch
[ncGenesisLeaders] :: NodeContext ssc -> !SlotLeaders

-- | Data needed for the slotting algorithm to work
[ncSlottingState] :: NodeContext ssc -> !(TVar SlottingState)

-- | Is time lord
[ncTimeLord] :: NodeContext ssc -> !Bool
[ncJLFile] :: NodeContext ssc -> !(Maybe (MVar FilePath))

-- | Path to the database
[ncDbPath] :: NodeContext ssc -> !FilePath
[ncSscContext] :: NodeContext ssc -> !(SscNodeContext ssc)

-- | Attack types used by malicious emulation
[ncAttackTypes] :: NodeContext ssc -> ![AttackType]

-- | Attack targets used by malicious emulation
[ncAttackTargets] :: NodeContext ssc -> ![AttackTarget]

-- | Whether to propagate txs, ssc data, blocks to neighbors
[ncPropagation] :: NodeContext ssc -> !Bool

-- | Semaphore which manages access to block application. Stored hash is a
--   hash of last applied block.
[ncBlkSemaphore] :: NodeContext ssc -> !(MVar HeaderHash)

-- | Primitive for synchronization with LRC.
[ncLrcSync] :: NodeContext ssc -> !(TVar LrcSyncData)

-- | Secret keys (and path to file) which are used to send transactions
[ncUserSecret] :: NodeContext ssc -> !(TVar UserSecret)

-- | Path to kademlia dump file
[ncKademliaDump] :: NodeContext ssc -> !FilePath

-- | Concurrent queue that holds block headers that are to be downloaded.
[ncBlockRetrievalQueue] :: NodeContext ssc -> !(TBQueue (NodeId, NewestFirst NE (BlockHeader ssc)))

-- | In case of recovery mode this variable holds the latest header hash we
--   know about so we can do chained block requests. Invariant: this mvar
--   is full iff we're more than <tt>recoveryHeadersMessage</tt> blocks
--   deep relatively to some valid header and we're downloading blocks.
--   Every time we get block that's more difficult than this one, we
--   overwrite. Every time we process some blocks and fail or see that
--   we've downloaded this header, we clean mvar.
[ncRecoveryHeader] :: NodeContext ssc -> !(TMVar (NodeId, BlockHeader ssc))

-- | A semaphore which is unlocked when update data is downloaded and ready
--   to apply
[ncUpdateSemaphore] :: NodeContext ssc -> !(MVar ConfirmedProposalState)

-- | Generate <a>PublicKey</a> from <a>SecretKey</a> of <a>NodeContext</a>.
ncPublicKey :: NodeContext ssc -> PublicKey

-- | Generate <a>Address</a> from <a>SecretKey</a> of <a>NodeContext</a>
ncPubKeyAddress :: NodeContext ssc -> Address
genesisUtxoM :: (Functor m, WithNodeContext ssc m) => m Utxo
genesisLeadersM :: (Functor m, WithNodeContext ssc m) => m SlotLeaders
putBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => HeaderHash -> m ()
readBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => m HeaderHash
takeBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => m HeaderHash

-- | Block until LRC data is available for given epoch.
waitLrc :: (MonadIO m, WithNodeContext ssc m) => EpochIndex -> m ()
lrcActionOnEpoch :: (MonadIO m, WithNodeContext ssc m, MonadThrow m) => EpochIndex -> (EpochIndex -> m (Maybe a)) -> m a
lrcActionOnEpochReason :: (MonadIO m, WithNodeContext ssc m, MonadThrow m) => EpochIndex -> Text -> (EpochIndex -> m (Maybe a)) -> m a
setNtpLastSlot :: (MonadIO m, WithNodeContext ssc m) => SlotId -> m ()
readNtpLastSlot :: (MonadIO m, WithNodeContext ssc m) => m SlotId
readNtpMargin :: (MonadIO m, WithNodeContext ssc m) => m Microsecond
readNtpData :: (MonadIO m, WithNodeContext ssc m) => m (Microsecond, Microsecond)
readSlotDuration :: (MonadIO m, WithNodeContext ssc m) => m Millisecond

-- | Wrapper for monadic action which brings <a>NodeContext</a>.
newtype ContextHolder ssc m a
ContextHolder :: ReaderT (NodeContext ssc) m a -> ContextHolder ssc m a
[getContextHolder] :: ContextHolder ssc m a -> ReaderT (NodeContext ssc) m a

-- | Run <a>ContextHolder</a> action.
runContextHolder :: NodeContext ssc -> ContextHolder ssc m a -> m a

module Pos.Security.Util
shouldIgnoreAddress :: NodeContext ssc -> NetworkAddress -> Bool
shouldIgnorePkAddress :: NodeContext ssc -> StakeholderId -> Bool


-- | This module re-exports functionality from Pos.Ssc.Extra.* modules.
module Pos.Ssc.Extra
newtype SscHolder ssc m a
SscHolder :: ReaderT (SscState ssc) m a -> SscHolder ssc m a
[getSscHolder] :: SscHolder ssc m a -> ReaderT (SscState ssc) m a
data SscState ssc
runSscHolder :: forall ssc m a. (SscLocalDataClass ssc, MonadIO m) => SscHolder ssc m a -> SscGlobalState ssc -> m a
runSscHolderRaw :: SscState ssc -> SscHolder ssc m a -> m a
class Monad m => MonadSscLD ssc m | m -> ssc where askSscLD = lift askSscLD getLocalData = lift getLocalData setLocalData = lift . setLocalData modifyLocalData = lift . modifyLocalData
askSscLD :: MonadSscLD ssc m => m (TVar (SscLocalData ssc))
getLocalData :: MonadSscLD ssc m => m (SscLocalData ssc)
setLocalData :: MonadSscLD ssc m => SscLocalData ssc -> m ()
modifyLocalData :: MonadSscLD ssc m => ((SscGlobalState ssc, SscLocalData ssc) -> (a, SscLocalData ssc)) -> m a
askSscLD :: (MonadSscLD ssc m, MonadTrans t, MonadSscLD ssc m', t m' ~ m) => m (TVar (SscLocalData ssc))
getLocalData :: (MonadSscLD ssc m, MonadTrans t, MonadSscLD ssc m', t m' ~ m) => m (SscLocalData ssc)
setLocalData :: (MonadSscLD ssc m, MonadTrans t, MonadSscLD ssc m', t m' ~ m) => SscLocalData ssc -> m ()
modifyLocalData :: (MonadSscLD ssc m, MonadTrans t, MonadSscLD ssc m', t m' ~ m) => ((SscGlobalState ssc, SscLocalData ssc) -> (a, SscLocalData ssc)) -> m a
sscApplyGlobalState :: forall ssc m. (MonadSscLD ssc m, SscLocalDataClass ssc) => Richmen -> m ()
sscGetLocalPayload :: forall ssc m. (MonadIO m, MonadSscLD ssc m, SscLocalDataClass ssc) => SlotId -> m (Maybe (SscPayload ssc))

-- | Convenient wrapper to run LocalQuery in MonadSscLD.
sscRunLocalQuery :: forall ssc m a. MonadSscLD ssc m => Reader (SscLocalData ssc) a -> m a

-- | Convenient wrapper to run LocalUpdate in MonadSscLD.
sscRunLocalUpdate :: MonadSscLD ssc m => State (SscLocalData ssc) a -> m a
class WithLogger m => MonadSscGS ssc m | m -> ssc where getGlobalState = lift getGlobalState setGlobalState = lift . setGlobalState modifyGlobalState = lift . modifyGlobalState
getGlobalState :: MonadSscGS ssc m => m (SscGlobalState ssc)
setGlobalState :: MonadSscGS ssc m => SscGlobalState ssc -> m ()
modifyGlobalState :: MonadSscGS ssc m => (SscGlobalState ssc -> (a, SscGlobalState ssc)) -> m a
getGlobalState :: (MonadSscGS ssc m, MonadTrans t, MonadSscGS ssc m', t m' ~ m) => m (SscGlobalState ssc)
setGlobalState :: (MonadSscGS ssc m, MonadTrans t, MonadSscGS ssc m', t m' ~ m) => SscGlobalState ssc -> m ()
modifyGlobalState :: (MonadSscGS ssc m, MonadTrans t, MonadSscGS ssc m', t m' ~ m) => (SscGlobalState ssc -> (a, SscGlobalState ssc)) -> m a
sscRunGlobalQuery :: forall ssc m a. (WithLogger m, MonadSscGS ssc m) => ReaderT (SscGlobalState ssc) m a -> m a
sscRunGlobalModify :: forall ssc m a. (MonadSscGS ssc m) => State (SscGlobalState ssc) a -> m a
sscApplyBlocks :: forall ssc m. (MonadSscGS ssc m, SscStorageClass ssc, WithLogger m) => OldestFirst NE (Block ssc) -> m ()
sscCalculateSeed :: forall ssc m. (MonadSscGS ssc m, SscStorageClass ssc) => EpochIndex -> m (Either (SscSeedError ssc) SharedSeed)
sscRollback :: forall ssc m. (MonadSscGS ssc m, SscStorageClass ssc) => NewestFirst NE (Block ssc) -> m ()

-- | Invariant: all blocks have the same epoch.
sscVerifyBlocks :: forall ssc m. (MonadDB ssc m, MonadSscGS ssc m, WithNodeContext ssc m, SscStorageClass ssc, WithLogger m) => Bool -> OldestFirst NE (Block ssc) -> m (Either (SscVerifyError ssc) ())

-- | Encapsulation manipulation of SSC richmen. We store SSC richmen into
--   database and inmemory.
class Monad m => MonadSscRichmen m


-- | Implementation of statistics gathering and processing utilities.
module Pos.Statistics

-- | Log count statistic event.
statlogCountEvent :: (MonadStats m, StatLabel l, EntryType l ~ CountStat) => l -> Word64 -> m ()

-- | Log value statistic event.
statlogValueEvent :: (MonadStats m, StatLabel l, EntryType l ~ ValueStat) => l -> Double -> m ()

-- | <a>MonadStats</a> is a monad which has methods for stats collecting
class Monad m => MonadStats m where statLog label = lift . statLog label resetStat = lift . resetStat logStatM label action = action >>= statLog label
statLog :: (MonadStats m, StatLabel l) => l -> EntryType l -> m ()
resetStat :: (MonadStats m, StatLabel l) => l -> m ()
statLog :: (MonadStats m, MonadTrans t, MonadStats m', t m' ~ m, StatLabel l) => l -> EntryType l -> m ()
resetStat :: (MonadStats m, MonadTrans t, MonadStats m', t m' ~ m, StatLabel l) => l -> m ()

-- | Default convenience method, which we can override (to truly do nothing
--   in <a>NoStatsT</a>, for example)
logStatM :: (MonadStats m, StatLabel l) => l -> m (EntryType l) -> m ()

-- | Stats wrapper for collecting statistics without collecting it.
newtype NoStatsT m a
NoStatsT :: m a -> NoStatsT m a

-- | action inside wrapper without collecting statistics
[getNoStatsT] :: NoStatsT m a -> m a

-- | Statistics wrapper around some monadic action to collect statistics
--   during execution of this action. Used in benchmarks.
newtype StatsT m a
StatsT :: ReaderT StatsMap m a -> StatsT m a

-- | action inside wrapper with collected statistics
[getStatsT] :: StatsT m a -> ReaderT StatsMap m a
runStatsT :: MonadIO m => StatsT m a -> m a
runStatsT' :: StatsMap -> StatsT m a -> m a
getStatsMap :: Monad m => StatsT m StatsMap

-- | Stat entry is a simple counter or a structure for aggregating
--   statistical data about real value
type StatEntry e = (Monoid e, FullySerializable e)

-- | <a>StatLabel</a> is some datatype which determines a single stat
class (FullySerializable l, Buildable l, Hashable l, StatEntry (EntryType l)) => StatLabel l where type EntryType l :: * where {
    type family EntryType l :: *;
}
labelName :: StatLabel l => Proxy l -> Text
toJLEvent :: StatLabel l => l -> EntryType l -> JLEvent

-- | Counter for specified statistics.
newtype CountStat
CountStat :: Word64 -> CountStat
[getCounter] :: CountStat -> Word64

-- | Value for specified collected statistic.
data ValueStat
ValueStat :: !Word64 -> !Double -> !Double -> !Double -> ValueStat
[valueCount] :: ValueStat -> !Word64
[valueMin] :: ValueStat -> !Double
[valueMax] :: ValueStat -> !Double
[valueSum] :: ValueStat -> !Double

-- | Singleton data type to represent collected statistics about processes
--   <tt>Tx'</tt>s.
data StatProcessTx
StatProcessTx :: StatProcessTx


-- | <a>WorkMode</a> constraint. It is widely used in almost every our
--   code. Simple alias for bunch of useful constraints. This module also
--   contains new monads to extend functional capabilities inside do-block.
module Pos.WorkMode

-- | Bunch of constraints to perform work for real world distributed
--   system.
type WorkMode ssc m = (WithLogger m, MonadIO m, MonadMockable m, MonadDHT m, MonadMask m, MonadSlots m, MonadDB ssc m, MonadTxpLD ssc m, MonadDelegation m, MonadUtxo m, MonadSscGS ssc m, SscStorageClass ssc, SscLocalDataClass ssc, SscHelpersClass ssc, MonadSscLD ssc m, WithNodeContext ssc m, MonadStats m, MonadJL m, WithKademliaDHTInstance m, MonadFail m, WithPeerState ssc m, MonadUSMem m)

-- | More relaxed version of <a>WorkMode</a>.
type MinWorkMode m = (WithLogger m, MonadMockable m, MonadDHT m, MonadIO m, MonadFail m)

-- | ProductionMode is an instance of WorkMode which is used
--   (unsurprisingly) in production.
type ProductionMode ssc = NoStatsT (RawRealMode ssc)

-- | RawRealMode is a basis for <a>WorkMode</a>s used to really run system.
type RawRealMode ssc = PeerStateHolder ssc (KademliaDHT (USHolder (DelegationT (TxpLDHolder ssc (SscHolder ssc (ContextHolder ssc (DBHolder ssc (LoggerNameBox Production))))))))

-- | ServiceMode is the mode in which support nodes work.
type ServiceMode = KademliaDHT (LoggerNameBox Production)

-- | StatsMode is used for remote benchmarking.
type StatsMode ssc = StatsT (RawRealMode ssc)
instance Pos.Types.Utxo.Class.MonadUtxoRead m => Pos.Types.Utxo.Class.MonadUtxoRead (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Types.Utxo.Class.MonadUtxo m => Pos.Types.Utxo.Class.MonadUtxo (Pos.DHT.Real.Types.KademliaDHT m)
instance (GHC.Base.Monad m, Pos.Context.Class.WithNodeContext ssc m) => Pos.Context.Class.WithNodeContext ssc (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.DB.Class.MonadDB ssc m => Pos.DB.Class.MonadDB ssc (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Ssc.Extra.MonadGS.MonadSscGS ssc m => Pos.Ssc.Extra.MonadGS.MonadSscGS ssc (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Delegation.Class.MonadDelegation m => Pos.Delegation.Class.MonadDelegation (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Update.MemState.Class.MonadUSMem m => Pos.Update.MemState.Class.MonadUSMem (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Ssc.Extra.Richmen.MonadSscRichmen m => Pos.Ssc.Extra.Richmen.MonadSscRichmen (Pos.DHT.Real.Types.KademliaDHT m)
instance Pos.Ssc.Extra.MonadLD.MonadSscLD ssc m => Pos.Ssc.Extra.MonadLD.MonadSscLD ssc (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Types.Utxo.Class.MonadUtxoRead m => Pos.Types.Utxo.Class.MonadUtxoRead (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Types.Utxo.Class.MonadUtxo m => Pos.Types.Utxo.Class.MonadUtxo (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance (GHC.Base.Monad m, Pos.Context.Class.WithNodeContext ssc m) => Pos.Context.Class.WithNodeContext ssc (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.DB.Class.MonadDB ssc m => Pos.DB.Class.MonadDB ssc (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Slotting.MonadSlots m => Pos.Slotting.MonadSlots (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.DHT.Model.Class.MonadDHT m => Pos.DHT.Model.Class.MonadDHT (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Ssc.Extra.MonadGS.MonadSscGS ssc m => Pos.Ssc.Extra.MonadGS.MonadSscGS ssc (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Delegation.Class.MonadDelegation m => Pos.Delegation.Class.MonadDelegation (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Txp.Class.MonadTxpLD ssc m => Pos.Txp.Class.MonadTxpLD ssc (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Update.MemState.Class.MonadUSMem m => Pos.Update.MemState.Class.MonadUSMem (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Ssc.Extra.Richmen.MonadSscRichmen m => Pos.Ssc.Extra.Richmen.MonadSscRichmen (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance (GHC.Base.Monad m, Pos.DHT.Real.Types.WithKademliaDHTInstance m) => Pos.DHT.Real.Types.WithKademliaDHTInstance (Pos.Communication.PeerState.PeerStateHolder ssc m)
instance Pos.Util.JsonLog.MonadJL m => Pos.Util.JsonLog.MonadJL (Pos.DHT.Real.Types.KademliaDHT m)

module Pos.DHT.Workers
dhtWorkers :: WorkMode ssc m => [SendActions BiP m -> m ()]

module Pos.Security.Class
class Ssc ssc => SecurityWorkersClass ssc
securityWorkers :: (SecurityWorkersClass ssc, WorkMode ssc m) => Tagged ssc [SendActions BiP m -> m ()]

module Pos.Security


-- | Listeners for network events in SSC algorithm implementation.
module Pos.Ssc.Class.Listeners

-- | Class for defining listeners in DHT <tt>SSC</tt> implementation.
class Ssc ssc => SscListenersClass ssc
sscListeners :: (SscListenersClass ssc, WorkMode ssc m) => Tagged ssc [Listener BiP m]
sscStubListeners :: (SscListenersClass ssc, WithLogger m) => Proxy ssc -> [Listener BiP m]


-- | General purpose workers for <tt>SSC</tt> storage.
module Pos.Ssc.Class.Workers

-- | Class for <tt>SSC</tt> workers.
class Ssc ssc => SscWorkersClass ssc

-- | All workers specific to SSC.
sscWorkers :: (SscWorkersClass ssc, WorkMode ssc m) => Tagged ssc [SendActions BiP m -> m ()]
sscLrcConsumers :: (SscWorkersClass ssc, WorkMode ssc m) => Tagged ssc [LrcConsumer m]


-- | Leaders and richmen computation.
module Pos.Lrc

-- | Datatype for LRC computation client. If you want to compute richmen,
--   you should add such client to LRC framework
data LrcConsumer m
LrcConsumer :: (Coin -> Coin) -> (EpochIndex -> m Bool) -> (EpochIndex -> Coin -> RichmenStake -> m ()) -> Bool -> LrcConsumer m

-- | Function which defines threshold depends on total stake
[lcThreshold] :: LrcConsumer m -> Coin -> Coin

-- | Function which defines necessity of richmen computation
[lcIfNeedCompute] :: LrcConsumer m -> EpochIndex -> m Bool

-- | Callback which will be called when richmen computed
[lcComputedCallback] :: LrcConsumer m -> EpochIndex -> Coin -> RichmenStake -> m ()

-- | Whether delegated stake should be considered
[lcConsiderDelegated] :: LrcConsumer m -> Bool

-- | Create LrcConsumer using constants from RichmenComponent and given
--   actions.
lrcConsumerFromComponent :: forall c m. RichmenComponent c => (EpochIndex -> m Bool) -> (EpochIndex -> Coin -> RichmenStake -> m ()) -> LrcConsumer m

-- | Create simple LrcConsumer using constants from RichmenComponent which
--   uses only LRC DB.
lrcConsumerFromComponentSimple :: forall c ssc m. (RichmenComponent c, MonadDB ssc m) => LrcConsumer m
allLrcConsumers :: (SscWorkersClass ssc, WorkMode ssc m) => [LrcConsumer m]

-- | Find nodes which have at least 'eligibility threshold' coins.
findRichmenStake :: forall m. MonadIterator (StakeholderId, Coin) m => Coin -> m RichmenStake

-- | Pure version of findRichmen which uses in-memory Utxo.
findRichmenPure :: [(StakeholderId, Coin)] -> (Coin -> Coin) -> RichmenType -> FullRichmenData

-- | Function considers all variants of computation and compute using one
--   pass by stake DB and one pass by delegation DB.
findAllRichmenMaybe :: forall ssc m. (MonadDB ssc m, MonadIterator (StakeholderId, Coin) m) => Maybe Coin -> Maybe Coin -> m (RichmenStake, RichmenStake)

-- | Find delegated richmen.
findDelegatedRichmen :: (MonadDB ssc m, MonadIterator (StakeholderId, Coin) m) => Coin -> m RichmenStake
data RichmenType
RTUsual :: RichmenType
RTDelegation :: (HashMap StakeholderId [StakeholderId]) -> RichmenType

-- | Addresses which have enough stake for participation in SSC.
type Richmen = NonEmpty StakeholderId

-- | Hashset of richmen.
type RichmenSet = HashSet StakeholderId

-- | Richmen with Stake
type RichmenStake = HashMap StakeholderId Coin
toRichmen :: RichmenStake -> Richmen

-- | Full richmen data consists of total stake at some point and stake
--   distribution among richmen.
type FullRichmenData = (Coin, RichmenStake)


-- | Re-exports of Pos.Ssc.Class.* modules.
module Pos.Ssc.Class
type SscConstraint ssc = (Ssc ssc, SscListenersClass ssc, SscLocalDataClass ssc, SscHelpersClass ssc, SscStorageClass ssc, SscWorkersClass ssc, SecurityWorkersClass ssc)
type WorkModeSsc ssc = (SscLocalDataClass ssc, SscHelpersClass ssc)


-- | Reexport module
module Pos.Delegation

-- | In-memory storage needed for delegation logic Maybe ncProxyCache
--   should be LRU instead of hashmap, but that's not urgent optimization
--   idea.
data DelegationWrap
DelegationWrap :: HashMap SendProxySK UTCTime -> HashMap ProxySKEpoch UTCTime -> HashMap PublicKey ProxySKSimple -> EpochIndex -> HashSet PublicKey -> DelegationWrap

-- | Message cache to prevent infinite propagation of useless certs.
[_dwMessageCache] :: DelegationWrap -> HashMap SendProxySK UTCTime

-- | Confirmation cache for lightweight PSKs.
[_dwConfirmationCache] :: DelegationWrap -> HashMap ProxySKEpoch UTCTime

-- | Memory pool of hardweight proxy secret keys. Keys of this map are
--   issuer public keys.
[_dwProxySKPool] :: DelegationWrap -> HashMap PublicKey ProxySKSimple

-- | Epoch index <a>DelegationWrap</a> is correct in relation to.
[_dwEpochId] :: DelegationWrap -> EpochIndex

-- | Set of stakeholders that have already posted their PSKs this epoch.
[_dwThisEpochPosted] :: DelegationWrap -> HashSet PublicKey
dwMessageCache :: Lens' DelegationWrap (HashMap SendProxySK UTCTime)
dwConfirmationCache :: Lens' DelegationWrap (HashMap ProxySKEpoch UTCTime)
dwProxySKPool :: Lens' DelegationWrap (HashMap PublicKey ProxySKSimple)
dwEpochId :: Lens' DelegationWrap EpochIndex
dwThisEpochPosted :: Lens' DelegationWrap (HashSet PublicKey)

-- | Equivalent of <tt>MonadReader (TVar DelegationWrap) m</tt>. Currently
--   we're locking on the whole delegation wrap at once. Locking on
--   independent components is better in performance, so there's a place
--   for optimization here.
class (Monad m) => MonadDelegation m where askDelegationState = lift askDelegationState

-- | Retrieves <a>TVar</a> on <a>DelegationWrap</a>
askDelegationState :: MonadDelegation m => m (TVar DelegationWrap)

-- | Retrieves <a>TVar</a> on <a>DelegationWrap</a>
askDelegationState :: (MonadDelegation m, MonadTrans t, MonadDelegation m', t m' ~ m) => m (TVar DelegationWrap)

-- | Wrapper of <tt>ReaderT (TVar DelegationWrap)</tt>, nothing smart.
newtype DelegationT m a
DelegationT :: ReaderT ReaderTCtx m a -> DelegationT m a
[getDelegationT] :: DelegationT m a -> ReaderT ReaderTCtx m a

-- | Executes delegationT transformer creating tvar from given wrap.
runDelegationT :: MonadIO m => DelegationWrap -> DelegationT m a -> m a

-- | Executes delegation wrap using existing delegation wrap tvar.
runDelegationTFromTVar :: TVar DelegationWrap -> DelegationT m a -> m a

-- | Listeners for requests related to delegation processing.
delegationListeners :: (WorkMode ssc m) => [ListenerAction BiP m]
delegationStubListeners :: WithLogger m => [ListenerAction BiP m]

-- | Handler <a>SendProxySK</a> event.
handleSendProxySK :: forall ssc m. (WorkMode ssc m) => ListenerAction BiP m
handleConfirmProxySK :: forall ssc m. (WorkMode ssc m) => ListenerAction BiP m
handleCheckProxySKConfirmed :: forall ssc m. (WorkMode ssc m) => ListenerAction BiP m

-- | Convenient monad to work in <a>DelegationWrap</a> context while being
--   in STM.
newtype DelegationStateAction a
DelegationStateAction :: StateT DelegationWrap STM a -> DelegationStateAction a
[getDelegationStateM] :: DelegationStateAction a -> StateT DelegationWrap STM a

-- | Effectively takes a lock on ProxyCaches mvar in NodeContext and allows
--   you to run some computation producing updated ProxyCaches and return
--   value. Will put MVar back on exception.
runDelegationStateAction :: (MonadIO m, MonadDelegation m) => DelegationStateAction a -> m a

-- | Invalidates proxy caches using built-in constants.
invalidateProxyCaches :: UTCTime -> DelegationStateAction ()

-- | Initializes delegation in-memory storage. * Sets <tt>_dwEpochId</tt>
--   to epoch of tip. * Loads <tt>_dwThisEpochPosted</tt> from database
initDelegation :: (Ssc ssc, MonadDB ssc m, MonadDelegation m) => m ()

-- | Retrieves current mempool of heavyweight psks plus undo part.
getProxyMempool :: (MonadDB ssc m, MonadDelegation m) => m ([ProxySKSimple], [ProxySKSimple])

-- | Datatypes representing a verdict of simple PSK processing.
data PskSimpleVerdict

-- | If we have exactly the same cert in psk mempool
PSExists :: PskSimpleVerdict

-- | Not enough stake
PSForbidden :: PskSimpleVerdict

-- | Broken
PSInvalid :: PskSimpleVerdict

-- | Message is cached
PSCached :: PskSimpleVerdict

-- | Verdict can't be made at the moment (we're updating)
PSIncoherent :: PskSimpleVerdict

-- | Successfully processed/added to psk mempool
PSAdded :: PskSimpleVerdict

-- | Processes simple (hardweight) psk. Puts it into the mempool depending
--   on issuer's stake, overrides if exists, checks validity and cachemsg
--   state.
processProxySKSimple :: (Ssc ssc, MonadDB ssc m, MonadDelegation m, WithNodeContext ssc m) => ProxySKSimple -> m PskSimpleVerdict

-- | Applies a sequence of definitely valid blocks to memory state and
--   returns batchops. It works correctly only in case blocks don't cross
--   over epoch. So genesis block is either absent or the head.
delegationApplyBlocks :: forall ssc m. (DelegationWorkMode ssc m) => OldestFirst NE (Block ssc) -> m (NonEmpty SomeBatchOp)

-- | Verifies if blocks are correct relatively to the delegation logic and
--   returns a non-empty list of proxySKs needed for undoing them.
--   Predicate for correctness here is: * Issuer can post only one cert per
--   epoch * For every new certificate issuer had enough stake at the end
--   of prev. epoch
--   
--   It's assumed blocks are correct from 'Pos.Types.Block#verifyBlocks'
--   point of view.
delegationVerifyBlocks :: forall ssc m. (Ssc ssc, MonadDB ssc m, WithNodeContext ssc m) => OldestFirst NE (Block ssc) -> m (Either Text (OldestFirst NE [ProxySKSimple]))

-- | Rollbacks block list. Erases mempool of certificates. Better to
--   restore them after the rollback (see Txp#normalizeTxpLD). You can
--   rollback arbitrary number of blocks.
delegationRollbackBlocks :: (Ssc ssc, MonadDelegation m, MonadDB ssc m, WithNodeContext ssc m) => NewestFirst NE (Blund ssc) -> m (NonEmpty SomeBatchOp)

-- | PSK check verdict. It can be unrelated (other key or spoiled, no way
--   to differ), exist in storage already or be cached.
data PskEpochVerdict
PEUnrelated :: PskEpochVerdict
PEInvalid :: PskEpochVerdict
PEExists :: PskEpochVerdict
PECached :: PskEpochVerdict
PERemoved :: PskEpochVerdict
PEAdded :: PskEpochVerdict

-- | Processes proxy secret key (understands do we need it, adds/caches on
--   decision, returns this decision).
processProxySKEpoch :: (MonadDelegation m, WithNodeContext ssc m, MonadDB ssc m) => ProxySKEpoch -> m PskEpochVerdict

-- | Verdict of <a>processConfirmProxySk</a> function
data ConfirmPskEpochVerdict

-- | Valid, saved
CPValid :: ConfirmPskEpochVerdict

-- | Invalid, throw away
CPInvalid :: ConfirmPskEpochVerdict

-- | Already saved
CPCached :: ConfirmPskEpochVerdict

-- | Takes a lightweight psk, delegate proof of delivery. Checks if it's
--   valid or not. Caches message in any case.
processConfirmProxySk :: (MonadDelegation m, MonadIO m) => ProxySKEpoch -> ProxySigEpoch ProxySKEpoch -> m ConfirmPskEpochVerdict

-- | Checks if we hold a confirmation for given PSK.
isProxySKConfirmed :: ProxySKEpoch -> DelegationStateAction Bool

-- | Consumer will be called on every Richmen computation.
delegationLrcConsumer :: MonadDB ssc m => LrcConsumer m

-- | Sends epoch psk to neighbours
sendProxySKEpoch :: (MinWorkMode m) => SendActions BiP m -> ProxySKEpoch -> m ()

-- | Sends simple psk to neighbours
sendProxySKSimple :: (MinWorkMode m) => SendActions BiP m -> ProxySKSimple -> m ()

-- | Generates a proof of being a delegate for psk and sends it to
--   neighbors.
sendProxyConfirmSK :: (WorkMode ss m) => SendActions BiP m -> ProxySKEpoch -> m ()

-- | Message with delegated proxy secret key. Is used to propagate both
--   epoch-oriented psks (lightweight) and simple (heavyweight).
data SendProxySK
SendProxySKEpoch :: !ProxySKEpoch -> SendProxySK
SendProxySKSimple :: !ProxySKSimple -> SendProxySK

-- | Confirmation of proxy signature delivery. Delegate should take the
--   proxy signing key he has and sign this key with itself. If the
--   signature is correct, then it was done by delegate (guaranteed by PSK
--   scheme). Checking <tt>w</tt> can be done with <tt>(const True)</tt>
--   predicate, because certificate may be sent in epoch id that's before
--   lower cert's <tt>EpochIndex</tt>.
data ConfirmProxySK
ConfirmProxySK :: !ProxySKEpoch -> !(ProxySigEpoch ProxySKEpoch) -> ConfirmProxySK

-- | Request to check if a node has any info about PSK delivery.
data CheckProxySKConfirmed
CheckProxySKConfirmed :: !ProxySKEpoch -> CheckProxySKConfirmed

-- | Response to the <tt>CheckProxySKConfirmed</tt> call.
data CheckProxySKConfirmedRes
CheckProxySKConfirmedRes :: !Bool -> CheckProxySKConfirmedRes


-- | Framework for Inv<i>Req</i>Dat message handling
module Pos.Util.Relay

-- | Typeclass for general Inv<i>Req</i>Dat framework. It describes monads,
--   that store data described by tag, where "key" stands for node
--   identifier.
class (Buildable tag, Buildable contents, Buildable key, Typeable tag, Typeable contents, Typeable key, NamedMessagePart tag, NamedMessagePart contents) => Relay m tag key contents | tag -> contents, contents -> tag, contents -> key, tag -> key

-- | Converts data to tag. Tag returned in monad <tt>m</tt> for only type
--   matching reason (multiparam type classes are tricky)
contentsToTag :: Relay m tag key contents => contents -> m tag
verifyInvTag :: Relay m tag key contents => tag -> m VerificationRes
verifyReqTag :: Relay m tag key contents => tag -> m VerificationRes
verifyDataContents :: Relay m tag key contents => contents -> m VerificationRes

-- | Handle inv msg and return whether it's useful or not
handleInv :: Relay m tag key contents => tag -> key -> m Bool

-- | Handle req msg and return (Just data) in case requested data can be
--   provided
handleReq :: Relay m tag key contents => tag -> key -> m (Maybe contents)

-- | Handle data msg and return True if message is to be propagated
handleData :: Relay m tag key contents => contents -> key -> m Bool

-- | Inventory message. Can be used to announce the fact that you have some
--   data.
data InvMsg key tag
InvMsg :: !tag -> !(NonEmpty key) -> InvMsg key tag
[imTag] :: InvMsg key tag -> !tag
[imKeys] :: InvMsg key tag -> !(NonEmpty key)

-- | Request message. Can be used to request data (ideally data which was
--   previously announced by inventory message).
data ReqMsg key tag
ReqMsg :: !tag -> !(NonEmpty key) -> ReqMsg key tag
[rmTag] :: ReqMsg key tag -> !tag
[rmKeys] :: ReqMsg key tag -> !(NonEmpty key)

-- | Data message. Can be used to send actual data.
data DataMsg key contents
DataMsg :: !contents -> !key -> DataMsg key contents
[dmContents] :: DataMsg key contents -> !contents
[dmKey] :: DataMsg key contents -> !key
newtype DataMsgGodTossing
DataMsgGT :: DataMsg StakeholderId GtMsgContents -> DataMsgGodTossing
[getDataMsg] :: DataMsgGodTossing -> DataMsg StakeholderId GtMsgContents
handleInvL :: forall m key tag contents. (Bi (ReqMsg key tag), Relay m tag key contents, WithLogger m) => InvMsg key tag -> NodeId -> SendActions BiP m -> m ()
handleReqL :: forall m key tag contents. (Bi (DataMsg key contents), Relay m tag key contents, WithLogger m) => ReqMsg key tag -> NodeId -> SendActions BiP m -> m ()
handleDataL :: forall ssc m key tag contents. (MonadDHT m, Bi (InvMsg key tag), Relay m tag key contents, WithLogger m, WorkMode ssc m) => DataMsg key contents -> NodeId -> SendActions BiP m -> m ()
instance GHC.Classes.Eq Pos.Util.Relay.DataMsgGodTossing
instance GHC.Show.Show Pos.Util.Relay.DataMsgGodTossing
instance (GHC.Show.Show key, GHC.Show.Show tag) => GHC.Show.Show (Pos.Util.Relay.InvMsg key tag)
instance (GHC.Classes.Eq key, GHC.Classes.Eq tag) => GHC.Classes.Eq (Pos.Util.Relay.InvMsg key tag)
instance (GHC.Show.Show key, GHC.Show.Show tag) => GHC.Show.Show (Pos.Util.Relay.ReqMsg key tag)
instance (GHC.Classes.Eq key, GHC.Classes.Eq tag) => GHC.Classes.Eq (Pos.Util.Relay.ReqMsg key tag)
instance (GHC.Show.Show key, GHC.Show.Show contents) => GHC.Show.Show (Pos.Util.Relay.DataMsg key contents)
instance (GHC.Classes.Eq key, GHC.Classes.Eq contents) => GHC.Classes.Eq (Pos.Util.Relay.DataMsg key contents)
instance (Test.QuickCheck.Arbitrary.Arbitrary key, Test.QuickCheck.Arbitrary.Arbitrary tag) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Util.Relay.InvMsg key tag)
instance Pos.Util.NamedMessagePart tag => Node.Message.Message (Pos.Util.Relay.InvMsg key tag)
instance (Test.QuickCheck.Arbitrary.Arbitrary key, Test.QuickCheck.Arbitrary.Arbitrary tag) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Util.Relay.ReqMsg key tag)
instance Pos.Util.NamedMessagePart tag => Node.Message.Message (Pos.Util.Relay.ReqMsg key tag)
instance (Data.Text.Buildable.Buildable key, Data.Text.Buildable.Buildable contents) => Data.Text.Buildable.Buildable (Pos.Util.Relay.DataMsg key contents)
instance Pos.Util.NamedMessagePart contents => Node.Message.Message (Pos.Util.Relay.DataMsg key contents)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Util.Relay.DataMsgGodTossing


-- | Reexports of Pos.Binary.* classes
module Pos.Binary

-- | Simplified definition of serializable object, Data.Binary.Class-alike.
--   
--   Write <tt>instance Bi SomeType where</tt> without any method
--   definitions if you want to use the <tt>Binary</tt> instance for your
--   type.
class Bi t where put = put get = get
put :: Bi t => t -> Put
put :: (Bi t, Binary t) => t -> Put
get :: Bi t => Get t
get :: (Bi t, Binary t) => Get t

-- | Encode a value to a lazy bytestring
encode :: Bi a => a -> LByteString

-- | Encode a value to a strict bytestring. Use with caution, because
--   converting to strict ByteString is expensive.
encodeStrict :: Bi a => a -> ByteString

-- | Decode a value from a lazy ByteString, reconstructing the original
--   structure.
decode :: Bi a => LByteString -> a
decodeOrFail :: Bi a => LByteString -> Either (LByteString, ByteOffset, String) (LByteString, ByteOffset, a)

-- | Like <a>decode</a>, but ensures that the whole input has been
--   consumed.
decodeFull :: Bi a => LByteString -> Either String a
newtype UnsignedVarInt a
UnsignedVarInt :: a -> UnsignedVarInt a
[getUnsignedVarInt] :: UnsignedVarInt a -> a
newtype SignedVarInt a
SignedVarInt :: a -> SignedVarInt a
[getSignedVarInt] :: SignedVarInt a -> a
newtype FixedSizeInt a
FixedSizeInt :: a -> FixedSizeInt a
[getFixedSizeInt] :: FixedSizeInt a -> a
getAsciiString1b :: String -> Word8 -> Get String
putAsciiString1b :: String -> Put


-- | Module providing restoring from backup phrase functionality
module Pos.Util.BackupPhrase

-- | Datatype to contain a valid backup phrase
data BackupPhrase

-- | Make backup phrase from list
mkBackupPhrase :: [Text] -> BackupPhrase

-- | Number of words in backup phrase
backupPhraseWordsNum :: Int
bpToList :: BackupPhrase -> [Text]
toSeed :: BackupPhrase -> ByteString
keysFromPhrase :: BackupPhrase -> (SecretKey, VssKeyPair)
instance GHC.Generics.Generic Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Classes.Eq Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Show.Show Pos.Util.BackupPhrase.BackupPhrase
instance Data.Text.Buildable.Buildable Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Read.Read Pos.Util.BackupPhrase.BackupPhrase


-- | Simplified NIST beacon implementation of SSC.
module Pos.Ssc.NistBeacon

-- | Data type tag for Nist Beacon implementation of Shared Seed
--   Calculation.
data SscNistBeacon
instance GHC.Generics.Generic Pos.Ssc.NistBeacon.SscNistBeacon
instance GHC.Show.Show Pos.Ssc.NistBeacon.SscNistBeacon
instance GHC.Classes.Eq Pos.Ssc.NistBeacon.SscNistBeacon
instance Data.Text.Buildable.Buildable ()
instance Data.Default.Class.Default Pos.Ssc.NistBeacon.LocalData
instance Pos.Ssc.Class.Types.Ssc Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Helpers.SscHelpersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Workers.SscWorkersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Listeners.SscListenersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.LocalData.SscLocalDataClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Storage.SscStorageClass Pos.Ssc.NistBeacon.SscNistBeacon


-- | Re-exports of GodTossing modules.
--   
--   GodTossing is a coin tossing with guaranteed output delivery. Nodes
--   exchange commitments, openings, and shares, and in the end arrive at a
--   shared seed.
--   
--   See <a>https://eprint.iacr.org/2015/889.pdf</a> (“A Provably Secure
--   Proof-of-Stake Blockchain Protocol”), section 4 for more details.
module Pos.Ssc.GodTossing

-- | Pair of <a>Commitment</a> and <a>Opening</a>.
data CommitmentOpening
CommitmentOpening :: !Commitment -> !Opening -> CommitmentOpening
[coCommitment] :: CommitmentOpening -> !Commitment
[coOpening] :: CommitmentOpening -> !Opening

-- | Data type for error during seed calculation.
data SeedError

-- | Some nodes in the <tt>OpeningsMap</tt> aren't in the set of
--   participants
ExtraneousOpenings :: (HashSet StakeholderId) -> SeedError

-- | Some nodes in the <tt>SharesMap</tt> aren't in the set of participants
ExtraneousShares :: (HashSet StakeholderId) -> SeedError

-- | There were no participants so a random string couldn't be generated
NoParticipants :: SeedError

-- | Commitment can't be deserialized or didn't match secret (either
--   recovered or in openings)
BrokenCommitment :: StakeholderId -> SeedError

-- | Secret couldn't be recovered, or wasn't found in either
--   <tt>OpeningsMap</tt> or <tt>SharesMap</tt>
NoSecretFound :: StakeholderId -> SeedError

-- | Secret can't be deserialized
BrokenSecret :: StakeholderId -> SeedError

-- | Share can't be deserialized
BrokenShare :: StakeholderId -> SeedError

-- | Generate securely random SharedSeed.
genCommitmentAndOpening :: (MonadFail m, MonadIO m) => Threshold -> NonEmpty (AsBinary VssPublicKey) -> m (Commitment, Opening)
isCommitmentId :: SlotId -> Bool
isCommitmentIdx :: LocalSlotIndex -> Bool
isOpeningId :: SlotId -> Bool
isOpeningIdx :: LocalSlotIndex -> Bool
isSharesId :: SlotId -> Bool
isSharesIdx :: LocalSlotIndex -> Bool
hasCommitment :: Bi Commitment => EpochIndex -> StakeholderId -> GtGlobalState -> Bool
hasOpening :: StakeholderId -> GtGlobalState -> Bool
hasShares :: StakeholderId -> GtGlobalState -> Bool
hasVssCertificate :: StakeholderId -> GtGlobalState -> Bool

-- | Make signed commitment from commitment and epoch index using secret
--   key.
mkSignedCommitment :: Bi Commitment => SecretKey -> EpochIndex -> Commitment -> SignedCommitment

-- | Convert Secret to SharedSeed.
secretToSharedSeed :: Secret -> SharedSeed

-- | Check that the VSS certificate is signed properly #checkPubKeyAddress
--   #checkSig
checkCertSign :: (StakeholderId, VssCertificate) -> Bool

-- | Check that the VSS certificate has valid TTL: more than 0 and less
--   than vssMaxTTL
checkCertTTL :: EpochIndex -> VssCertificate -> Bool

-- | Verify that Commitment is correct.
--   
--   #verifyEncShare
verifyCommitment :: Commitment -> Bool

-- | Verify signature in SignedCommitment using epoch index.
--   
--   #checkSig
verifyCommitmentSignature :: Bi Commitment => EpochIndex -> SignedCommitment -> Bool

-- | Verify SignedCommitment using public key and epoch index.
--   
--   #verifyCommitmentPK #verifyCommitmentSignature #verifyCommitment
verifySignedCommitment :: Bi Commitment => StakeholderId -> EpochIndex -> SignedCommitment -> VerificationRes

-- | Verify that Secret provided with Opening corresponds to given
--   commitment.
--   
--   #verifySecretProof
verifyOpening :: Commitment -> Opening -> Bool

-- | Check that the decrypted share matches the encrypted share in the
--   commitment
--   
--   #verifyShare
checkShare :: (SetContainer set, ContainerKey set ~ StakeholderId) => CommitmentsMap -> set -> VssCertificatesMap -> (StakeholderId, StakeholderId, AsBinary Share) -> Bool
checkShares :: (SetContainer set, ContainerKey set ~ StakeholderId) => CommitmentsMap -> set -> VssCertificatesMap -> StakeholderId -> InnerSharesMap -> Bool

-- | Check that the secret revealed in the opening matches the secret proof
--   in the commitment
checkOpeningMatchesCommitment :: CommitmentsMap -> (StakeholderId, Opening) -> Bool
checkCommShares :: [AsBinary VssPublicKey] -> SignedCommitment -> Bool
verifyGtPayload :: (SscPayload ssc ~ GtPayload, Bi Commitment) => MainBlockHeader ssc -> SscPayload ssc -> Either TossVerFailure ()
verifyEntriesGuard :: MonadError TossVerFailure m => (entry -> key) -> (entry -> verificationVal) -> (NonEmpty key -> TossVerFailure) -> (verificationVal -> Bool) -> [entry] -> m ()

-- | Figure out the threshold (i.e. how many secret shares would be
--   required to recover each node's secret) using number of participants.
vssThreshold :: Integral a => a -> Threshold
computeParticipants :: Richmen -> VssCertificatesMap -> VssCertificatesMap
getStableCertsPure :: EpochIndex -> VssCertData -> VssCertificatesMap

-- | Certificates in genesis represented as <a>VssCertificatesMap</a>.
genesisCertificates :: VssCertificatesMap

-- | List of <a>VssKeyPair</a> in genesis.
genesisVssKeyPairs :: [VssKeyPair]

-- | Clean-up some data when new slot starts.
localOnNewSlot :: MonadSscLD SscGodTossing m => RichmenSet -> SlotId -> m ()

-- | Check whether SSC data with given tag and public key can be added to
--   local data.
sscIsDataUseful :: MonadSscLD SscGodTossing m => GtMsgTag -> StakeholderId -> m Bool

-- | Process message and save it if needed. Result is whether message has
--   been actually added.
sscProcessMessage :: (MonadSscLD SscGodTossing m, SscBi) => Richmen -> GtMsgContents -> StakeholderId -> m (Either TossVerFailure ())
getLocalPayload :: LocalQuery SscGodTossing (SlotId, GtPayload)
data GtLocalData
GtLocalData :: !CommitmentsMap -> !OpeningsMap -> !SharesMap -> !VssCertData -> !SlotId -> GtLocalData

-- | Local set of <tt>Commitment</tt>s. These are valid commitments which
--   are known to the node and not stored in blockchain. It is useful only
--   for the first <tt>k</tt> slots, after that it should be discarded.
[_ldCommitments] :: GtLocalData -> !CommitmentsMap

-- | Local set of openings
[_ldOpenings] :: GtLocalData -> !OpeningsMap

-- | Local set of decrypted shares (encrypted shares are stored in
--   commitments).
[_ldShares] :: GtLocalData -> !SharesMap

-- | Local set of VSS certificates
[_ldCertificates] :: GtLocalData -> !VssCertData

-- | Last slot we are aware of.
[_ldLastProcessedSlot] :: GtLocalData -> !SlotId
ldCommitments :: Lens' GtLocalData CommitmentsMap
ldOpenings :: Lens' GtLocalData OpeningsMap
ldShares :: Lens' GtLocalData SharesMap
ldCertificates :: Lens' GtLocalData VssCertData
ldLastProcessedSlot :: Lens' GtLocalData SlotId

-- | Get our commitment for given epoch if it's known.
getOurCommitment :: MonadDB SscGodTossing m => EpochIndex -> m (Maybe SignedCommitment)

-- | Get our opening corresponding for given epoch if it's known.
getOurOpening :: MonadDB SscGodTossing m => EpochIndex -> m (Maybe Opening)

-- | Put our secret for given epoch.
putOurSecret :: MonadDB SscGodTossing m => SignedCommitment -> Opening -> EpochIndex -> m ()

-- | Calculate SharedSeed. SharedSeed is a random bytestring that all nodes
--   generate together and agree on.
--   
--   TODO: do we need to check secrets' lengths? Probably not.
calculateSeed :: CommitmentsMap -> OpeningsMap -> SharesMap -> Either SeedError SharedSeed
getGlobalCerts :: (MonadSscGS SscGodTossing m) => SlotId -> m VssCertificatesMap
gtGetGlobalState :: (MonadSscGS SscGodTossing m) => m GtGlobalState

-- | Get stable VSS certificates for given epoch.
getStableCerts :: MonadSscGS SscGodTossing m => EpochIndex -> m VssCertificatesMap

-- | Commitment is a message generated during the first stage of
--   GodTossing. It contains encrypted shares and proof of secret.
--   Invariant which must be ensured: commShares is not empty.
data Commitment
Commitment :: !(AsBinary SecretSharingExtra) -> !(AsBinary SecretProof) -> !(HashMap (AsBinary VssPublicKey) (AsBinary EncShare)) -> Commitment
[commExtra] :: Commitment -> !(AsBinary SecretSharingExtra)
[commProof] :: Commitment -> !(AsBinary SecretProof)
[commShares] :: Commitment -> !(HashMap (AsBinary VssPublicKey) (AsBinary EncShare))

-- | Signature which ensures that commitment was generated by node with
--   given public key for given epoch.
type CommitmentSignature = Signature (EpochIndex, Commitment)
type SignedCommitment = (PublicKey, Commitment, CommitmentSignature)
type CommitmentsMap = HashMap StakeholderId SignedCommitment

-- | Each node generates a <tt>SharedSeed</tt>, breaks it into
--   <a>Share</a>s, and sends those encrypted shares to other nodes. In a
--   <a>SharesMap</a>, for each node we collect shares which said node has
--   received and decrypted.
--   
--   Specifically, if node identified by <tt>Address</tt> X has received a
--   share from node identified by key Y, this share will be at
--   <tt>sharesMap ! X ! Y</tt>.
type InnerSharesMap = HashMap StakeholderId (AsBinary Share)

-- | Opening reveals secret.
newtype Opening
Opening :: (AsBinary Secret) -> Opening
[getOpening] :: Opening -> (AsBinary Secret)
type OpeningsMap = HashMap StakeholderId Opening
type SharesMap = HashMap StakeholderId InnerSharesMap

-- | VssCertificate allows VssPublicKey to participate in MPC. Each
--   stakeholder should create a Vss keypair, sign public key with signing
--   key and send it into blockchain.
--   
--   A public key of node is included in certificate in order to enable
--   validation of it using only node's P2PKH address. Expiry epoch is last
--   epoch when certificate is valid, expiry epoch is included in
--   certificate and signature.
--   
--   Other nodes accept this certificate if it is valid and if node really
--   has some stake.
data VssCertificate
VssCertificate :: !(AsBinary VssPublicKey) -> !EpochIndex -> !(Signature (AsBinary VssPublicKey, EpochIndex)) -> !PublicKey -> VssCertificate
[vcVssKey] :: VssCertificate -> !(AsBinary VssPublicKey)
[vcExpiryEpoch] :: VssCertificate -> !EpochIndex
[vcSignature] :: VssCertificate -> !(Signature (AsBinary VssPublicKey, EpochIndex))
[vcSigningKey] :: VssCertificate -> !PublicKey
mkVssCertificate :: SecretKey -> AsBinary VssPublicKey -> EpochIndex -> VssCertificate

-- | VssCertificatesMap contains all valid certificates collected during
--   some period of time.
type VssCertificatesMap = HashMap StakeholderId VssCertificate
type NodeSet = HashSet StakeholderId

-- | Tag associated with message.
data GtMsgTag
CommitmentMsg :: GtMsgTag
OpeningMsg :: GtMsgTag
SharesMsg :: GtMsgTag
VssCertificateMsg :: GtMsgTag
isGoodSlotForTag :: GtMsgTag -> LocalSlotIndex -> Bool
isGoodSlotIdForTag :: GtMsgTag -> SlotId -> Bool

-- | Data message. Can be used to send actual data.
data GtMsgContents
MCCommitment :: !SignedCommitment -> GtMsgContents
MCOpening :: !Opening -> GtMsgContents
MCShares :: !InnerSharesMap -> GtMsgContents
MCVssCertificate :: !VssCertificate -> GtMsgContents

-- | GtMsgTag appropriate for given DataMsg.
msgContentsTag :: GtMsgContents -> GtMsgTag

-- | Data type which represents shared seed calculation tag in
--   -XTypeApplication hacks with type families.
data SscGodTossing

-- | Block payload
data GtPayload
CommitmentsPayload :: !CommitmentsMap -> !VssCertificatesMap -> GtPayload
OpeningsPayload :: !OpeningsMap -> !VssCertificatesMap -> GtPayload
SharesPayload :: !SharesMap -> !VssCertificatesMap -> GtPayload
CertificatesPayload :: !VssCertificatesMap -> GtPayload

-- | Proof of MpcData. We can use ADS for commitments, openings, shares as
--   well, if we find it necessary.
data GtProof
CommitmentsProof :: !(Hash CommitmentsMap) -> !(Hash VssCertificatesMap) -> GtProof
OpeningsProof :: !(Hash OpeningsMap) -> !(Hash VssCertificatesMap) -> GtProof
SharesProof :: !(Hash SharesMap) -> !(Hash VssCertificatesMap) -> GtProof
CertificatesProof :: !(Hash VssCertificatesMap) -> GtProof

-- | Global state of GodTossing, contains relevant SSC data from blocks.
data GtGlobalState
GtGlobalState :: !CommitmentsMap -> !OpeningsMap -> !SharesMap -> !VssCertData -> GtGlobalState

-- | Commitments are added during the first phase of epoch.
[_gsCommitments] :: GtGlobalState -> !CommitmentsMap

-- | Openings are added during the second phase of epoch.
[_gsOpenings] :: GtGlobalState -> !OpeningsMap

-- | Decrypted shares to be used in the third phase.
[_gsShares] :: GtGlobalState -> !SharesMap

-- | Vss certificates are added at any time if they are valid and received
--   from stakeholders.
[_gsVssCertificates] :: GtGlobalState -> !VssCertData
data GtContext
GtContext :: !VssKeyPair -> !(TVar Bool) -> !(TVar Bool) -> GtContext

-- | Vss key pair used for MPC.
[gtcVssKeyPair] :: GtContext -> !VssKeyPair
[gtcParticipateSsc] :: GtContext -> !(TVar Bool)
[gtcVssCertificateVerified] :: GtContext -> !(TVar Bool)
data GtParams
GtParams :: !Bool -> !Bool -> !VssKeyPair -> GtParams
[gtpRebuildDb] :: GtParams -> !Bool

-- | Whether node should participate in SSC in case SSC requires
--   participation.
[gtpSscEnabled] :: GtParams -> !Bool

-- | Key pair used for secret sharing
[gtpVssKeyPair] :: GtParams -> !VssKeyPair
data GtSecretStorage
GtSecretStorage :: !(SignedCommitment) -> !Opening -> !EpochIndex -> GtSecretStorage

-- | Our commitment.
[gssCommitment] :: GtSecretStorage -> !(SignedCommitment)

-- | Corresponding opening
[gssOpening] :: GtSecretStorage -> !Opening

-- | Epoch for which this secret were generated
[gssEpoch] :: GtSecretStorage -> !EpochIndex
data TossVerFailure
TossVerFailure :: !TossVerErrorTag -> !(NonEmpty StakeholderId) -> TossVerFailure
[tvfErrorTag] :: TossVerFailure -> !TossVerErrorTag
[tvfStakeholders] :: TossVerFailure -> !(NonEmpty StakeholderId)
NotCommitmentPhase :: !SlotId -> TossVerFailure
NotOpeningPhase :: !SlotId -> TossVerFailure
NotSharesPhase :: !SlotId -> TossVerFailure
CertificateInvalidSign :: !(NonEmpty (StakeholderId, VssCertificate)) -> TossVerFailure
CertificateInvalidTTL :: !(NonEmpty (VssCertificate, EpochIndex)) -> TossVerFailure
TossInternallError :: !Text -> TossVerFailure
data TossVerErrorTag
CommitmentInvalid :: TossVerErrorTag
CommitingNoParticipants :: TossVerErrorTag
CommitmentAlreadySent :: TossVerErrorTag
CommSharesOnWrongParticipants :: TossVerErrorTag
OpeningAlreadySent :: TossVerErrorTag
OpeningWithoutCommitment :: TossVerErrorTag
OpeningNotMatchCommitment :: TossVerErrorTag
SharesNotRichmen :: TossVerErrorTag
InternalShareWithoutCommitment :: TossVerErrorTag
SharesAlreadySent :: TossVerErrorTag
DecrSharesNotMatchCommitment :: TossVerErrorTag
CertificateAlreadySent :: TossVerErrorTag
CertificateNotRichmen :: TossVerErrorTag
gsCommitments :: Lens' GtGlobalState CommitmentsMap
gsOpenings :: Lens' GtGlobalState OpeningsMap
gsShares :: Lens' GtGlobalState SharesMap
gsVssCertificates :: Lens' GtGlobalState VssCertData

-- | Smart constructor for <a>GtProof</a> from <a>GtPayload</a>.
mkGtProof :: (Bi VssCertificate, Bi Commitment, Bi Opening) => GtPayload -> GtProof
createGtContext :: MonadIO m => GtParams -> m GtContext
_gpCertificates :: GtPayload -> VssCertificatesMap
emptyPayload :: GtPayload
type SscBi = (Bi GtProof, Bi GtPayload, Bi Opening, Bi VssCertificate, Bi Commitment)

-- | Wrapper around <a>VssCertificate</a> with TTL. Every
--   <a>VssCertificate</a> has own TTL. Wrapper supports simple
--   <a>HashMap</a> operations. Wrapper holds <a>VssCertificatesMap</a> and
--   <a>Set</a> of certificates sorted by expiry epoch.
data VssCertData
VssCertData :: !EpochOrSlot -> !VssCertificatesMap -> !(HashMap StakeholderId EpochOrSlot) -> !(Set (EpochOrSlot, StakeholderId)) -> !(Set (EpochOrSlot, StakeholderId)) -> !(Set (EpochOrSlot, (StakeholderId, EpochOrSlot, VssCertificate))) -> VssCertData

-- | Last known slot, every element of expirySlotSet &gt; lastKnownEoS
[lastKnownEoS] :: VssCertData -> !EpochOrSlot

-- | Not expired certificates
[certs] :: VssCertData -> !VssCertificatesMap

-- | Slot when certs was inserted. It is needed for deletion from
--   <tt>insSlotSet</tt> (by <a>StakeholderId</a>).
[whenInsMap] :: VssCertData -> !(HashMap StakeholderId EpochOrSlot)

-- | Set of pairs (insertion slot, address hash) Every element of
--   insSlotSet &lt;= lastKnownEoS
[whenInsSet] :: VssCertData -> !(Set (EpochOrSlot, StakeholderId))

-- | Set of pairs (expiry slot, address hash). Expiry slot is first slot
--   when certificate expires. Pairs are sorted by expiry slot (in
--   increasing order, so the oldest certificate is first element).
[whenExpire] :: VssCertData -> !(Set (EpochOrSlot, StakeholderId))

-- | Set of expired certs for current <a>lastKnownEoS</a>. We store only
--   certificates which expried no earlier than in previous epoch. Set
--   (full expired slot, (id, insertion slot, cert))
[expiredCerts] :: VssCertData -> !(Set (EpochOrSlot, (StakeholderId, EpochOrSlot, VssCertificate)))

-- | Create empty <a>VssCertData</a>.
empty :: VssCertData

-- | Remove old certificate corresponding to the specified
--   <a>StakeholderId</a> and insert new certificate.
insert :: StakeholderId -> VssCertificate -> VssCertData -> VssCertData

-- | Lookup certificate corresponding to the specified
--   <a>StakeholderId</a>.
lookup :: StakeholderId -> VssCertData -> Maybe VssCertificate

-- | Lookup expiry epoch of certificate corresponding to the specified
--   <a>StakeholderId</a>.
lookupExpiryEpoch :: StakeholderId -> VssCertData -> Maybe EpochIndex
setLastKnownSlot :: SlotId -> VssCertData -> VssCertData

-- | Set last known slot (lks). 1. If new lks is bigger than
--   <a>lastKnownEoS</a> then some expired certificates will be removed. 2.
--   If new lks is less than <a>lastKnownEoS</a> then some inserted after
--   <tt>nlks</tt> certificates will be removed (and <a>whenExpire</a>)
--   also will be updated.
setLastKnownEoS :: EpochOrSlot -> VssCertData -> VssCertData

-- | Ids of stakeholders issued certificates.
keys :: VssCertData -> [StakeholderId]

-- | Return True if the specified address hash is present in the map, False
--   otherwise.
member :: StakeholderId -> VssCertData -> Bool

-- | Convert expiry epoch of certificate to <tt>FlatSlotId</tt>.
expiryEpoch :: VssCertificate -> EpochIndex
expiryEoS :: VssCertificate -> EpochOrSlot

-- | Delete certificate corresponding to the specified
--   <a>StakeholderId</a>. This function is dangerous, because after using
--   it you can't rollback deleted certificates. Use carefully.
delete :: StakeholderId -> VssCertData -> VssCertData

-- | This function is dangerous, because after you using it you can't
--   rollback deleted certificates. Use carefully.
difference :: VssCertData -> HashMap StakeholderId a -> VssCertData

-- | Filtering the certificates. This function is dangerous, because after
--   you using it you can't rollback deleted certificates. Use carefully.
filter :: (StakeholderId -> Bool) -> VssCertData -> VssCertData


-- | Server which handles transactions.
module Pos.Txp.Listeners
txListeners :: WorkMode ssc m => [ListenerAction BiP m]
txStubListeners :: WithLogger m => Proxy ssc -> [ListenerAction BiP m]
processTx :: MinTxpWorkMode ssc m => (TxId, TxAux) -> m ProcessTxRes
instance Pos.WorkMode.WorkMode ssc m => Pos.Util.Relay.Relay m Pos.Txp.Types.Communication.TxMsgTag Pos.Types.Types.TxId Pos.Txp.Types.Communication.TxMsgContents


-- | Arbitrary instances for Update System types.
module Pos.Update.Arbitrary


-- | Web-related part of cardano-sl.
module Pos.Web
baseDocsText :: Text
gtDocsText :: Text
type MyWorkMode ssc m = (WorkMode ssc m, SscConstraint ssc)
type WebHandler ssc = ContextHolder ssc (TxpLDHolder ssc (DBHolder ssc Production))
serveImpl :: MonadIO m => m Application -> Word16 -> m ()
nat :: forall ssc m. (MyWorkMode ssc m) => m (WebHandler ssc :~> Handler)
serveWebBase :: MyWorkMode ssc m => Word16 -> m ()
applicationBase :: MyWorkMode ssc m => m Application
serveWebGT :: MyWorkMode SscGodTossing m => Word16 -> m ()
applicationGT :: MyWorkMode SscGodTossing m => m Application


-- | Re-export of Pos.Block.Network.*
module Pos.Block.Network
announceBlock :: WorkMode ssc m => SendActions BiP m -> MainBlockHeader ssc -> m ()
handleHeadersCommunication :: WorkMode ssc m => ConversationActions (MsgHeaders ssc) MsgGetHeaders m -> m ()
blockListeners :: (WorkMode ssc m) => [ListenerAction BiP m]
blockStubListeners :: (Ssc ssc, WithLogger m) => Proxy ssc -> [ListenerAction BiP m]
retrievalWorker :: forall ssc m. (SscWorkersClass ssc, WorkMode ssc m) => SendActions BiP m -> m ()
handleUnsolicitedHeaders :: forall ssc m. (WorkMode ssc m) => NonEmpty (BlockHeader ssc) -> NodeId -> ConversationActions MsgGetHeaders (MsgHeaders ssc) m -> m ()
requestTip :: forall ssc m. (WorkMode ssc m) => NodeId -> ConversationActions MsgGetHeaders (MsgHeaders ssc) m -> m ()
requestHeaders :: forall ssc m. (WorkMode ssc m) => MsgGetHeaders -> Maybe (BlockHeader ssc) -> NodeId -> ConversationActions MsgGetHeaders (MsgHeaders ssc) m -> m ()

-- | Given nonempty list of valid blockheaders and nodeid, this function
--   will put them into download queue and they will be processed later.
--   Second argument is optional recovery mode tip -- after pack of blocks
--   is processed, next pack of headers will be requested until this header
--   hash is received.
addToBlockRequestQueue :: forall ssc m. (WorkMode ssc m) => NewestFirst NE (BlockHeader ssc) -> Maybe (BlockHeader ssc) -> NodeId -> m ()

-- | Make <tt>GetHeaders</tt> message using our main chain. This function
--   chooses appropriate <tt>from</tt> hashes and puts them into
--   <tt>GetHeaders</tt> message.
mkHeadersRequest :: WorkMode ssc m => Maybe HeaderHash -> m (Maybe MsgGetHeaders)

-- | <tt>GetHeaders</tt> message (see protocol specification).
data MsgGetHeaders
MsgGetHeaders :: ![HeaderHash] -> !(Maybe HeaderHash) -> MsgGetHeaders
[mghFrom] :: MsgGetHeaders -> ![HeaderHash]
[mghTo] :: MsgGetHeaders -> !(Maybe HeaderHash)

-- | <tt>GetHeaders</tt> message (see protocol specification).
data MsgGetBlocks
MsgGetBlocks :: !HeaderHash -> !HeaderHash -> MsgGetBlocks
[mgbFrom] :: MsgGetBlocks -> !HeaderHash
[mgbTo] :: MsgGetBlocks -> !HeaderHash

-- | <tt>Headers</tt> message (see protocol specification).
newtype MsgHeaders ssc
MsgHeaders :: (NewestFirst NE (BlockHeader ssc)) -> MsgHeaders ssc

-- | <a>Block</a> message (see protocol specification).
--   
--   The <tt>s</tt> parameter is used for passing block size limit to
--   deserialization instances (using <a>Data.Reflection</a>). Grep for
--   <tt>reify</tt> and <tt>reflect</tt> to see usage examples.
newtype MsgBlock s ssc
MsgBlock :: (Block ssc) -> MsgBlock s ssc

module Pos.Block.Arbitrary
newtype BlockHeaderList ssc
BHL :: ([BlockHeader ssc], [PublicKey]) -> BlockHeaderList ssc
[getHeaderList] :: BlockHeaderList ssc -> ([BlockHeader ssc], [PublicKey])
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.BlockSignature ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.GenesisBlockHeader ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.BodyProof (Pos.Types.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.ConsensusData (Pos.Types.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.Body (Pos.Types.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.GenericBlock (Pos.Types.Types.GenesisBlockchain ssc))
instance Pos.Binary.Class.Bi Pos.Util.Raw => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Merkle.MerkleRoot Pos.Types.Types.Tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Merkle.MerkleTree Pos.Types.Types.Tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.MainBlockHeader ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary h => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Data.Attributes.Attributes h)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.MainExtraHeaderData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Types.MainExtraBodyData
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Raw) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.BodyProof (Pos.Types.Types.MainBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.ConsensusData (Pos.Types.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.Body (Pos.Types.Types.MainBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Types.GenericBlock (Pos.Types.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Network.Types.MsgGetHeaders
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Network.Types.MsgGetBlocks
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Util.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Network.Types.MsgHeaders ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Network.Types.MsgBlock s ssc)
instance Pos.Types.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Types.BlockHeader ssc, Pos.Crypto.Signing.PublicKey)
instance Pos.Types.Types.BiSsc ssc => GHC.Show.Show (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BlockHeaderList ssc)

module Pos.Security.Workers
class Ssc ssc => SecurityWorkersClass ssc
securityWorkers :: (SecurityWorkersClass ssc, WorkMode ssc m) => Tagged ssc [SendActions BiP m -> m ()]
instance Pos.Ssc.GodTossing.Types.Types.SscBi => Pos.Security.Class.SecurityWorkersClass Pos.Ssc.GodTossing.Types.Type.SscGodTossing
instance Pos.Security.Class.SecurityWorkersClass Pos.Ssc.NistBeacon.SscNistBeacon


-- | Whole Update System in one module :)
module Pos.Update

-- | Download a file by its hash.
--   
--   Tries all servers in turn, fails if none of them work.
downloadHash :: Hash LByteString -> IO (Either String LByteString)

-- | Download and save archive update by given
--   <a>ConfirmedProposalState</a>
downloadUpdate :: WorkMode ssc m => ConfirmedProposalState -> m ()

-- | Apply chain of <i>definitely</i> valid blocks to US part of GState DB
--   and to US local data. This function assumes that no other thread
--   applies block in parallel. It also assumes that parent of oldest block
--   is current tip. If verification is done prior to application, one can
--   pass <a>PollModifier</a> obtained from verification to this function.
usApplyBlocks :: (MonadThrow m, USGlobalApplyMode ssc m) => OldestFirst NE (Block ssc) -> Maybe PollModifier -> m [SomeBatchOp]

-- | Checks whether our software can create block according to current
--   global state.
usCanCreateBlock :: (WithLogger m, WithNodeContext ssc m, MonadDB ssc m) => m Bool

-- | Revert application of given blocks to US part of GState DB and US
--   local data. The caller must ensure that the tip stored in DB is
--   <a>headerHash</a> of head.
usRollbackBlocks :: forall ssc m. USGlobalApplyMode ssc m => NewestFirst NE (Block ssc, USUndo) -> m [SomeBatchOp]

-- | Verify whether sequence of blocks can be applied to US part of current
--   GState DB. This function doesn't make pure checks, they are assumed to
--   be done earlier, most likely during objects construction.
usVerifyBlocks :: (USGlobalVerifyMode ssc m) => OldestFirst NE (Block ssc) -> m (PollModifier, OldestFirst NE USUndo)

-- | This function returns true if update proposal with given identifier
--   should be requested.
isProposalNeeded :: (MonadIO m, MonadUSMem m) => UpId -> m Bool

-- | Get update proposal with given id if it is known.
getLocalProposalNVotes :: (MonadIO m, MonadUSMem m) => UpId -> m (Maybe (UpdateProposal, [UpdateVote]))

-- | Process proposal received from network, checking it against current
--   state (global + local) and adding to local state if it's valid with
--   respect to it. If proposal is added to store, 'Right ()' is returned.
--   Otherwise 'Left err' is returned and <tt>err</tt> lets caller decide
--   whether sender could be sure that error would happen.
processProposal :: (USLocalLogicMode ssc m) => UpdateProposal -> m (Either PollVerFailure ())

-- | This function returns true if update vote proposal with given
--   identifier issued by stakeholder with given PublicKey and with given
--   decision should be requested.
isVoteNeeded :: USLocalLogicMode ssc m => UpId -> PublicKey -> Bool -> m Bool

-- | Get update vote for proposal with given id from given issuer and with
--   given decision if it is known.
getLocalVote :: (MonadIO m, MonadUSMem m) => UpId -> PublicKey -> Bool -> m (Maybe UpdateVote)

-- | Process vote received from network, checking it against current state
--   (global + local) and adding to local state if it's valid with respect
--   to it. If vote is added to store, 'Right ()' is returned. Otherwise
--   'Left err' is returned and <tt>err</tt> lets caller decide whether
--   sender could be sure that error would happen.
processVote :: (USLocalLogicMode ssc m) => UpdateVote -> m (Either PollVerFailure ())

-- | Remove local data from memory state to make it consistent with current
--   GState. This function assumes that GState is locked. It tries to leave
--   as much data as possible. It assumes that <tt>blkSemaphore</tt> is
--   taken.
usNormalize :: (USLocalLogicMode ssc m) => m ()

-- | Update memory state to make it correct for given slot.
processNewSlot :: (USLocalLogicMode ssc m) => SlotId -> m ()

-- | Prepare UpdatePayload for inclusion into new block with given SlotId.
--   This function assumes that <tt>blkSemaphore</tt> is taken and nobody
--   can apply/rollback blocks in parallel. Sometimes payload can't be
--   created. It can happen if we are trying to create block for slot which
--   has already passed, for example.
usPreparePayload :: (USLocalLogicMode ssc m) => SlotId -> m (Maybe UpdatePayload)

-- | Consumer will be called on every Richmen computation.
usLrcConsumer :: MonadDB ssc m => LrcConsumer m

-- | Reduced equivalent of <tt>MonadReader MemVar m</tt>.
class Monad m => MonadUSMem m where askUSMemVar = lift askUSMemVar

-- | Retrieve <a>MemVar</a>.
askUSMemVar :: MonadUSMem m => m MemVar

-- | Retrieve <a>MemVar</a>.
askUSMemVar :: (MonadUSMem m, MonadTrans t, MonadUSMem m', t m' ~ m) => m MemVar
askUSMemState :: MonadUSMem m => m (TVar MemState)
withUSLock :: (MonadUSMem m, MonadIO m, MonadMask m) => m a -> m a

-- | Modify MemPool using UpdatePayload and PollModifier.
--   
--   UpdatePayload is used to add new data to MemPool. Data must be
--   verified by caller. It's added directly to MemPool.
--   
--   PollModifier is used to remove or modify some data in MemPool. All
--   deleted proposals and votes for them are removed. TODO [CSL-625]
--   Deleted and modified votes from non-deleted proposals are not handled
--   properly.
modifyMemPool :: UpdatePayload -> PollModifier -> MemPool -> MemPool

-- | Trivial monad transformer based on <tt>ReaderT (MemVar)</tt>.
newtype USHolder m a
USHolder :: ReaderT MemVar m a -> USHolder m a
[getUSHolder] :: USHolder m a -> ReaderT MemVar m a

-- | Run USHolder using default (empty) MemState.
runUSHolder :: MonadIO m => USHolder m a -> m a

-- | Run USHolder using existing MemVar.
runUSHolderFromVar :: MemVar -> USHolder m a -> m a

-- | MemState contains all in-memory data necesary for Update System.
data MemState
MemState :: !SlotId -> !HeaderHash -> !MemPool -> !PollModifier -> MemState

-- | Slot for which data is valid. In reality EpochIndex should be enough,
--   but we sometimes overgeneralize things.
[msSlot] :: MemState -> !SlotId

-- | Tip for which data is valid.
[msTip] :: MemState -> !HeaderHash

-- | Pool of data to be included into block.
[msPool] :: MemState -> !MemPool

-- | Modifier of GState corresponding to <a>msPool</a>.
[msModifier] :: MemState -> !PollModifier

-- | MemVar uses concurrency primitives and stores MemState.
data MemVar
MemVar :: !(TVar MemState) -> !Lock -> MemVar

-- | MemState itself.
[mvState] :: MemVar -> !(TVar MemState)

-- | Lock for modifting MemState.
[mvLock] :: MemVar -> !Lock
newMemVar :: MonadIO m => m MemVar

-- | MemPool is data maintained by node to be included into block and
--   relayed to other nodes.
data MemPool
MemPool :: !UpdateProposals -> !LocalVotes -> MemPool
[mpProposals] :: MemPool -> !UpdateProposals
[mpLocalVotes] :: MemPool -> !LocalVotes
type UpdateProposals = HashMap UpId UpdateProposal
type LocalVotes = HashMap UpId (HashMap PublicKey UpdateVote)

-- | Listeners for requests related to update system
usListeners :: (WorkMode ssc m) => [ListenerAction BiP m]
usStubListeners :: (WithLogger m) => [ListenerAction BiP m]

-- | Tag for proposal messages
data ProposalMsgTag
ProposalMsgTag :: ProposalMsgTag

-- | Tag for vote messages
data VoteMsgTag
VoteMsgTag :: VoteMsgTag

-- | Type class which provides function necessary for read-only
--   verification of US data.
class (Monad m, WithLogger m) => MonadPollRead m where getAdoptedBV = fst <$> getAdoptedBVFull getAdoptedBVData = snd <$> getAdoptedBVFull getBVState = lift . getBVState getProposedBVs = lift getProposedBVs getConfirmedBVStates = lift getConfirmedBVStates getAdoptedBVFull = lift getAdoptedBVFull getLastConfirmedSV = lift . getLastConfirmedSV hasActiveProposal = lift . hasActiveProposal getProposal = lift . getProposal getConfirmedProposals = lift getConfirmedProposals getEpochTotalStake = lift . getEpochTotalStake getRichmanStake e = lift . getRichmanStake e getOldProposals = lift . getOldProposals getDeepProposals = lift . getDeepProposals getBlockIssuerStake e = lift . getBlockIssuerStake e

-- | Retrieve state of given block version.
getBVState :: MonadPollRead m => BlockVersion -> m (Maybe BlockVersionState)

-- | Retrieve all proposed block version.
getProposedBVs :: MonadPollRead m => m [BlockVersion]

-- | Get all confirmed <a>BlockVersion</a>s and their states.
getConfirmedBVStates :: MonadPollRead m => m [(BlockVersion, BlockVersionState)]

-- | Retrieve last adopted block version and its state.
getAdoptedBVFull :: MonadPollRead m => m (BlockVersion, BlockVersionData)

-- | Get numeric component of last confirmed version of application
getLastConfirmedSV :: MonadPollRead m => ApplicationName -> m (Maybe NumSoftwareVersion)

-- | Check if given application has an active (non-confirmed) proposal
hasActiveProposal :: MonadPollRead m => ApplicationName -> m Bool

-- | Get active proposal
getProposal :: MonadPollRead m => UpId -> m (Maybe ProposalState)

-- | Get all known confirmed proposals.
getConfirmedProposals :: MonadPollRead m => m [ConfirmedProposalState]

-- | Get total stake from distribution corresponding to give epoch
getEpochTotalStake :: MonadPollRead m => EpochIndex -> m (Maybe Coin)

-- | Get stake of ricmhan corresponding to given epoch (if she is really
--   rich)
getRichmanStake :: MonadPollRead m => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Get all proposals which are in undecided state and were included into
--   block with slot less than or equal to given.
getOldProposals :: MonadPollRead m => SlotId -> m [UndecidedProposalState]

-- | Get all proposals which are in decided state and become decided deeper
--   than given <a>ChainDifficulty</a>.
getDeepProposals :: MonadPollRead m => ChainDifficulty -> m [DecidedProposalState]

-- | Get stake of issuer of one of the blocks created so far using stake
--   distribution which is stable in given epoch. Only issuer of stable
--   block can be passed to this function, otherwise <a>Nothing</a> will be
--   returned.
getBlockIssuerStake :: MonadPollRead m => EpochIndex -> StakeholderId -> m (Maybe Coin)
getAdoptedBV :: MonadPollRead m => m BlockVersion
getAdoptedBVData :: MonadPollRead m => m BlockVersionData

-- | Retrieve state of given block version.
getBVState :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => BlockVersion -> m (Maybe BlockVersionState)

-- | Retrieve all proposed block version.
getProposedBVs :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m [BlockVersion]

-- | Get all confirmed <a>BlockVersion</a>s and their states.
getConfirmedBVStates :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m [(BlockVersion, BlockVersionState)]

-- | Retrieve last adopted block version and its state.
getAdoptedBVFull :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m (BlockVersion, BlockVersionData)

-- | Get numeric component of last confirmed version of application
getLastConfirmedSV :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => ApplicationName -> m (Maybe Word32)

-- | Check if given application has an active (non-confirmed) proposal
hasActiveProposal :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => ApplicationName -> m Bool

-- | Get active proposal
getProposal :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => UpId -> m (Maybe ProposalState)

-- | Get all known confirmed proposals.
getConfirmedProposals :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => m [ConfirmedProposalState]

-- | Get total stake from distribution corresponding to give epoch
getEpochTotalStake :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => EpochIndex -> m (Maybe Coin)

-- | Get stake of ricmhan corresponding to given epoch (if she is really
--   rich)
getRichmanStake :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Get all proposals which are in undecided state and were included into
--   block with slot less than or equal to given.
getOldProposals :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => SlotId -> m [UndecidedProposalState]

-- | Get all proposals which are in decided state and become decided deeper
--   than given <a>ChainDifficulty</a>.
getDeepProposals :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => ChainDifficulty -> m [DecidedProposalState]

-- | Get stake of issuer of one of the blocks created so far using stake
--   distribution which is stable in given epoch. Only issuer of stable
--   block can be passed to this function, otherwise <a>Nothing</a> will be
--   returned.
getBlockIssuerStake :: (MonadPollRead m, MonadTrans t, MonadPollRead m', t m' ~ m) => EpochIndex -> StakeholderId -> m (Maybe Coin)

-- | Type class which provides function necessary for verification of US
--   data with ability to modify state.
class MonadPollRead m => MonadPoll m where putBVState pv = lift . putBVState pv delBVState = lift . delBVState setAdoptedBV = lift . setAdoptedBV setLastConfirmedSV = lift . setLastConfirmedSV delConfirmedSV = lift . delConfirmedSV addConfirmedProposal = lift . addConfirmedProposal delConfirmedProposal = lift . delConfirmedProposal addActiveProposal = lift . addActiveProposal deactivateProposal = lift . deactivateProposal

-- | Put state of BlockVersion overriding if it exists.
putBVState :: MonadPoll m => BlockVersion -> BlockVersionState -> m ()

-- | Delete BlockVersion and associated state.
delBVState :: MonadPoll m => BlockVersion -> m ()

-- | Set last adopted block version. State is taken from competing states.
setAdoptedBV :: MonadPoll m => BlockVersion -> m ()

-- | Set last confirmed version of application.
setLastConfirmedSV :: MonadPoll m => SoftwareVersion -> m ()

-- | Del last confirmed version of application.
delConfirmedSV :: MonadPoll m => ApplicationName -> m ()

-- | Add new confirmed update proposal.
addConfirmedProposal :: MonadPoll m => ConfirmedProposalState -> m ()

-- | Del confirmed update proposal (for rollback only).
delConfirmedProposal :: MonadPoll m => SoftwareVersion -> m ()

-- | Add new active proposal with its state.
addActiveProposal :: MonadPoll m => ProposalState -> m ()

-- | Delete active proposal given its name and identifier.
deactivateProposal :: MonadPoll m => UpId -> m ()

-- | Put state of BlockVersion overriding if it exists.
putBVState :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => BlockVersion -> BlockVersionState -> m ()

-- | Delete BlockVersion and associated state.
delBVState :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => BlockVersion -> m ()

-- | Set last adopted block version. State is taken from competing states.
setAdoptedBV :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => BlockVersion -> m ()

-- | Set last confirmed version of application.
setLastConfirmedSV :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => SoftwareVersion -> m ()

-- | Del last confirmed version of application.
delConfirmedSV :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => ApplicationName -> m ()

-- | Add new confirmed update proposal.
addConfirmedProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => ConfirmedProposalState -> m ()

-- | Del confirmed update proposal (for rollback only).
delConfirmedProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => SoftwareVersion -> m ()

-- | Add new active proposal with its state.
addActiveProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => ProposalState -> m ()

-- | Delete active proposal given its name and identifier.
deactivateProposal :: (MonadPoll m, MonadTrans t, MonadPoll m', t m' ~ m) => UpId -> m ()
newtype DBPoll m a
DBPoll :: m a -> DBPoll m a
[runDBPoll] :: DBPoll m a -> m a

-- | Verify UpdatePayload with respect to data provided by MonadPoll. If
--   data is valid it is also applied. Otherwise PollVerificationFailure is
--   thrown using MonadError type class. When first flag is true and
--   proposal is present, <a>genesisUpdateProposalThd</a> is checked for
--   it, otherwise it's not checked. When second argument is 'Left epoch',
--   it means that temporary payload for given slot is applied. When it is
--   'Right header', it means that payload from block with given header is
--   applied.
verifyAndApplyUSPayload :: forall ssc m. (ApplyMode m, Ssc ssc) => Bool -> Either SlotId (MainBlockHeader ssc) -> UpdatePayload -> m ()

-- | Rollback application of UpdatePayload in MonadPoll using payload
--   itself and undo data.
rollbackUS :: forall m. MonadPoll m => USUndo -> m ()

-- | Normalize given proposals and votes with respect to current Poll
--   state, i. e. remove everything that is invalid. Valid data is applied.
--   This function doesn't consider <a>genesisUpdateProposalThd</a>.
normalizePoll :: forall ssc m. (MonadPoll m, Ssc ssc) => SlotId -> UpdateProposals -> LocalVotes -> m (UpdateProposals, LocalVotes)
filterProposalsByThd :: forall m. (MonadPollRead m) => EpochIndex -> UpdateProposals -> m (UpdateProposals, HashSet UpId)

-- | Check whether block with given <a>BlockVersion</a> can be created
--   according to current Poll.
--   
--   Specifically, one of the following conditions must be true. • Given
--   block version is equal to last adopted block version. • '(major,
--   minor)' from given block version must be greater than '(major, minor)'
--   if last adopted version and this block version must be confirmed.
canCreateBlockBV :: MonadPollRead m => BlockVersion -> m Bool

-- | Verify that size of block doesn't exceed currently adopted limit.
verifyBlockSize :: (MonadError PollVerFailure m, MonadPollRead m) => HeaderHash -> Byte -> m ()

-- | Process creation of genesis block for given epoch.
processGenesisBlock :: (MonadError PollVerFailure m, MonadPoll m) => EpochIndex -> m ()

-- | Record the fact that main block with given version has been issued by
--   stakeholder with given id for the given slot.
recordBlockIssuance :: (MonadError PollVerFailure m, MonadPoll m) => StakeholderId -> BlockVersion -> SlotId -> HeaderHash -> m ()

-- | Unite two PollModifiers. Second argument dominates, i. e. if there are
--   two confliciting modifications, the second one wins.
modifyPollModifier :: PollModifier -> PollModifier -> PollModifier
newtype RollT m a
RollT :: StateT USUndo m a -> RollT m a
[getRollT] :: RollT m a -> StateT USUndo m a
runRollT :: RollT m a -> m (a, USUndo)
execRollT :: Monad m => RollT m a -> m USUndo

-- | Monad transformer which stores PollModifier and implements writable
--   MonadPoll.
--   
--   <ul>
--   <li><i>WARNING</i> This transformer uses StateT and is intended for
--   single-threaded usage only.</li>
--   </ul>
newtype PollT m a
PollT :: StateT PollModifier m a -> PollT m a
[getPollT] :: PollT m a -> StateT PollModifier m a
runPollT :: PollModifier -> PollT m a -> m (a, PollModifier)
evalPollT :: Functor m => PollModifier -> PollT m a -> m a
execPollT :: Functor m => PollModifier -> PollT m a -> m PollModifier

-- | State of UpdateProposal which can't be classified as approved or
--   rejected.
data UndecidedProposalState
UndecidedProposalState :: !StakeholderVotes -> !UpdateProposal -> !SlotId -> !Coin -> !Coin -> !(Maybe UpsExtra) -> UndecidedProposalState

-- | Votes given for this proposal.
[upsVotes] :: UndecidedProposalState -> !StakeholderVotes

-- | Proposal itself.
[upsProposal] :: UndecidedProposalState -> !UpdateProposal

-- | SlotId from block in which update was proposed.
[upsSlot] :: UndecidedProposalState -> !SlotId

-- | Total stake of all positive votes.
[upsPositiveStake] :: UndecidedProposalState -> !Coin

-- | Total stake of all negative votes.
[upsNegativeStake] :: UndecidedProposalState -> !Coin

-- | Extra data
[upsExtra] :: UndecidedProposalState -> !(Maybe UpsExtra)

-- | State of UpdateProposal which can be classified as approved or
--   rejected.
data DecidedProposalState
DecidedProposalState :: !Bool -> !UndecidedProposalState -> !(Maybe ChainDifficulty) -> !(Maybe DpsExtra) -> DecidedProposalState

-- | Whether proposal is approved.
[dpsDecision] :: DecidedProposalState -> !Bool

-- | Corresponding UndecidedProposalState
[dpsUndecided] :: DecidedProposalState -> !UndecidedProposalState

-- | Difficulty at which this proposal became approved/rejected. Can be
--   Nothing in temporary state.
[dpsDifficulty] :: DecidedProposalState -> !(Maybe ChainDifficulty)

-- | Extra data
[dpsExtra] :: DecidedProposalState -> !(Maybe DpsExtra)

-- | State of UpdateProposal.
data ProposalState
PSUndecided :: !UndecidedProposalState -> ProposalState
PSDecided :: !DecidedProposalState -> ProposalState

-- | Extra data required by wallet, stored in UndecidedProposalState
data UpsExtra
UpsExtra :: !HeaderHash -> UpsExtra

-- | Block in which this update was proposed
[ueProposedBlk] :: UpsExtra -> !HeaderHash

-- | Extra data required by wallet, stored in DecidedProposalState.
data DpsExtra
DpsExtra :: !HeaderHash -> !Bool -> DpsExtra

-- | HeaderHash of block in which this update was approved/rejected
[deDecidedBlk] :: DpsExtra -> !HeaderHash

-- | Which way we approve/reject this update proposal: implicit or explicit
[deImplicit] :: DpsExtra -> !Bool

-- | Information about confirmed proposals stored in DB.
data ConfirmedProposalState
ConfirmedProposalState :: !UpdateProposal -> !Bool -> !HeaderHash -> !HeaderHash -> !HeaderHash -> !(Maybe HeaderHash) -> !StakeholderVotes -> !Coin -> !Coin -> ConfirmedProposalState
[cpsUpdateProposal] :: ConfirmedProposalState -> !UpdateProposal
[cpsImplicit] :: ConfirmedProposalState -> !Bool
[cpsProposed] :: ConfirmedProposalState -> !HeaderHash
[cpsDecided] :: ConfirmedProposalState -> !HeaderHash
[cpsConfirmed] :: ConfirmedProposalState -> !HeaderHash
[cpsAdopted] :: ConfirmedProposalState -> !(Maybe HeaderHash)
[cpsVotes] :: ConfirmedProposalState -> !StakeholderVotes
[cpsPositiveStake] :: ConfirmedProposalState -> !Coin
[cpsNegativeStake] :: ConfirmedProposalState -> !Coin

-- | Get <a>BlockVersion</a> from <a>ConfirmedProposalState</a>.
cpsBlockVersion :: ConfirmedProposalState -> BlockVersion

-- | Get <a>SoftwareVersion</a> from <a>ConfirmedProposalState</a>.
cpsSoftwareVersion :: ConfirmedProposalState -> SoftwareVersion
psProposal :: ProposalState -> UpdateProposal
psVotes :: ProposalState -> StakeholderVotes

-- | Make UndecidedProposalState from immutable data, i. e. SlotId and
--   UpdateProposal.
mkUProposalState :: SlotId -> UpdateProposal -> UndecidedProposalState

-- | State of BlockVersion from update proposal.
data BlockVersionState
BlockVersionState :: !BlockVersionData -> !Bool -> !(HashSet StakeholderId) -> !(HashSet StakeholderId) -> !(Maybe HeaderHash) -> !(Maybe HeaderHash) -> BlockVersionState

-- | <tt>BlockVersioData</tt> associated with this block version.
[bvsData] :: BlockVersionState -> !BlockVersionData

-- | Whether proposal with this block version is confirmed.
[bvsIsConfirmed] :: BlockVersionState -> !Bool

-- | Identifiers of stakeholders which issued stable blocks with this
--   <a>BlockVersion</a>. Stability is checked by the same rules as used in
--   LRC. That is, <a>SlotId</a> is considered. If block is created after
--   crucial slot of <tt>i</tt>-th epoch, it is not stable when 'i+1'-th
--   epoch starts.
[bvsIssuersStable] :: BlockVersionState -> !(HashSet StakeholderId)

-- | Identifiers of stakeholders which issued unstable blocks with this
--   <a>BlockVersion</a>. See description of <a>bvsIssuersStable</a> for
--   details.
[bvsIssuersUnstable] :: BlockVersionState -> !(HashSet StakeholderId)

-- | Identifier of last block which modified set of
--   <a>bvsIssuersStable</a>.
[bvsLastBlockStable] :: BlockVersionState -> !(Maybe HeaderHash)

-- | Identifier of last block which modified set of
--   <a>bvsIssuersUnstable</a>.
[bvsLastBlockUnstable] :: BlockVersionState -> !(Maybe HeaderHash)
bvsScriptVersion :: BlockVersionState -> ScriptVersion
bvsSlotDuration :: BlockVersionState -> Millisecond
bvsMaxBlockSize :: BlockVersionState -> Byte

-- | PollModifier is used in verification. It represents operation which
--   one should apply to global state to obtain result of application of
--   MemPool or blocks which are verified.
data PollModifier
PollModifier :: !(HashMap BlockVersion BlockVersionState) -> !(HashSet BlockVersion) -> !(Maybe (BlockVersion, BlockVersionData)) -> !(HashMap ApplicationName NumSoftwareVersion) -> !(HashSet ApplicationName) -> !(HashMap SoftwareVersion ConfirmedProposalState) -> !(HashSet SoftwareVersion) -> !(HashMap UpId ProposalState) -> !(HashSet UpId) -> !(HashMap ApplicationName UpId) -> !(HashMap ApplicationName UpId) -> PollModifier
[pmNewBVs] :: PollModifier -> !(HashMap BlockVersion BlockVersionState)
[pmDelBVs] :: PollModifier -> !(HashSet BlockVersion)
[pmAdoptedBVFull] :: PollModifier -> !(Maybe (BlockVersion, BlockVersionData))
[pmNewConfirmed] :: PollModifier -> !(HashMap ApplicationName NumSoftwareVersion)
[pmDelConfirmed] :: PollModifier -> !(HashSet ApplicationName)
[pmNewConfirmedProps] :: PollModifier -> !(HashMap SoftwareVersion ConfirmedProposalState)
[pmDelConfirmedProps] :: PollModifier -> !(HashSet SoftwareVersion)
[pmNewActiveProps] :: PollModifier -> !(HashMap UpId ProposalState)
[pmDelActiveProps] :: PollModifier -> !(HashSet UpId)
[pmNewActivePropsIdx] :: PollModifier -> !(HashMap ApplicationName UpId)
[pmDelActivePropsIdx] :: PollModifier -> !(HashMap ApplicationName UpId)
pmNewBVsL :: Lens' PollModifier (HashMap BlockVersion BlockVersionState)
pmDelBVsL :: Lens' PollModifier (HashSet BlockVersion)
pmAdoptedBVFullL :: Lens' PollModifier (Maybe (BlockVersion, BlockVersionData))
pmNewConfirmedL :: Lens' PollModifier (HashMap ApplicationName NumSoftwareVersion)
pmDelConfirmedL :: Lens' PollModifier (HashSet ApplicationName)
pmNewConfirmedPropsL :: Lens' PollModifier (HashMap SoftwareVersion ConfirmedProposalState)
pmDelConfirmedPropsL :: Lens' PollModifier (HashSet SoftwareVersion)
pmNewActivePropsL :: Lens' PollModifier (HashMap UpId ProposalState)
pmDelActivePropsL :: Lens' PollModifier (HashSet UpId)
pmNewActivePropsIdxL :: Lens' PollModifier (HashMap ApplicationName UpId)
pmDelActivePropsIdxL :: Lens' PollModifier (HashMap ApplicationName UpId)

-- | PollVerificationFailure represents all possible errors which can
--   appear in Poll data verification.
data PollVerFailure
PollWrongScriptVersion :: !ScriptVersion -> !ScriptVersion -> !UpId -> PollVerFailure
[pwsvExpected] :: PollVerFailure -> !ScriptVersion
[pwsvFound] :: PollVerFailure -> !ScriptVersion
[pwsvUpId] :: PollVerFailure -> !UpId

-- | Slot duration for this block version is already known and the one we
--   saw doesn't match it
PollWrongSlotDuration :: !Millisecond -> !Millisecond -> !UpId -> PollVerFailure
[pwsdExpected] :: PollVerFailure -> !Millisecond
[pwsdFound] :: PollVerFailure -> !Millisecond
[pwsdUpId] :: PollVerFailure -> !UpId

-- | Max block size for this block version is already known and the one we
--   saw doesn't match it
PollWrongMaxBlockSize :: !Byte -> !Byte -> !UpId -> PollVerFailure
[pwmbsExpected] :: PollVerFailure -> !Byte
[pwmbsFound] :: PollVerFailure -> !Byte
[pwmbsUpId] :: PollVerFailure -> !UpId

-- | A proposal tried to increase the block size limit more than it was
--   allowed to
PollLargeMaxBlockSize :: !Byte -> !Byte -> !UpId -> PollVerFailure
[plmbsMaxPossible] :: PollVerFailure -> !Byte
[plmbsFound] :: PollVerFailure -> !Byte
[plmbsUpId] :: PollVerFailure -> !UpId
PollNotFoundScriptVersion :: !BlockVersion -> PollVerFailure
PollSmallProposalStake :: !Coin -> !Coin -> !UpId -> PollVerFailure
[pspsThreshold] :: PollVerFailure -> !Coin
[pspsActual] :: PollVerFailure -> !Coin
[pspsUpId] :: PollVerFailure -> !UpId
PollNotRichman :: !StakeholderId -> !Coin -> !(Maybe Coin) -> PollVerFailure
[pnrStakeholder] :: PollVerFailure -> !StakeholderId
[pnrThreshold] :: PollVerFailure -> !Coin
[pnrStake] :: PollVerFailure -> !(Maybe Coin)
PollUnknownProposal :: !StakeholderId -> !UpId -> PollVerFailure
[pupStakeholder] :: PollVerFailure -> !StakeholderId
[pupProposal] :: PollVerFailure -> !UpId
PollUnknownStakes :: !EpochIndex -> PollVerFailure
Poll2ndActiveProposal :: !SoftwareVersion -> PollVerFailure
PollWrongSoftwareVersion :: !(Maybe NumSoftwareVersion) -> !ApplicationName -> !NumSoftwareVersion -> !UpId -> PollVerFailure
[pwsvStored] :: PollVerFailure -> !(Maybe NumSoftwareVersion)
[pwsvApp] :: PollVerFailure -> !ApplicationName
[pwsvGiven] :: PollVerFailure -> !NumSoftwareVersion
[pwsvUpId] :: PollVerFailure -> !UpId
PollProposalIsDecided :: !UpId -> !StakeholderId -> PollVerFailure
[ppidUpId] :: PollVerFailure -> !UpId
[ppidStakeholder] :: PollVerFailure -> !StakeholderId
PollExtraRevote :: !UpId -> !StakeholderId -> !Bool -> PollVerFailure
[perUpId] :: PollVerFailure -> !UpId
[perStakeholder] :: PollVerFailure -> !StakeholderId
[perDecision] :: PollVerFailure -> !Bool
PollWrongHeaderBlockVersion :: !BlockVersion -> !BlockVersion -> PollVerFailure
[pwhpvGiven] :: PollVerFailure -> !BlockVersion
[pwhpvAdopted] :: PollVerFailure -> !BlockVersion
PollBadBlockVersion :: !UpId -> !BlockVersion -> !BlockVersion -> PollVerFailure
[pbpvUpId] :: PollVerFailure -> !UpId
[pbpvGiven] :: PollVerFailure -> !BlockVersion
[pbpvAdopted] :: PollVerFailure -> !BlockVersion
PollTooBigBlock :: !HeaderHash -> !Byte -> !Byte -> PollVerFailure
[ptbbHash] :: PollVerFailure -> !HeaderHash
[ptbbSize] :: PollVerFailure -> !Byte
[ptbbLimit] :: PollVerFailure -> !Byte
PollInternalError :: !Text -> PollVerFailure

-- | Previous value of something that could be missing.
data PrevValue a
PrevValue :: a -> PrevValue a
NoExist :: PrevValue a
maybeToPrev :: Maybe a -> PrevValue a

-- | Data necessary to unapply US data.
data USUndo
USUndo :: !(HashMap BlockVersion (PrevValue BlockVersionState)) -> !(Maybe BlockVersion) -> !(HashMap UpId (PrevValue ProposalState)) -> !(HashMap ApplicationName (PrevValue NumSoftwareVersion)) -> !(HashMap SoftwareVersion (PrevValue ConfirmedProposalState)) -> USUndo
[unChangedBV] :: USUndo -> !(HashMap BlockVersion (PrevValue BlockVersionState))
[unLastAdoptedBV] :: USUndo -> !(Maybe BlockVersion)
[unChangedProps] :: USUndo -> !(HashMap UpId (PrevValue ProposalState))
[unChangedSV] :: USUndo -> !(HashMap ApplicationName (PrevValue NumSoftwareVersion))
[unChangedConfProps] :: USUndo -> !(HashMap SoftwareVersion (PrevValue ConfirmedProposalState))
unChangedSVL :: Lens' USUndo (HashMap ApplicationName (PrevValue NumSoftwareVersion))
unChangedPropsL :: Lens' USUndo (HashMap UpId (PrevValue ProposalState))
unChangedBVL :: Lens' USUndo (HashMap BlockVersion (PrevValue BlockVersionState))
unLastAdoptedBVL :: Lens' USUndo (Maybe BlockVersion)
unChangedConfPropsL :: Lens' USUndo (HashMap SoftwareVersion (PrevValue ConfirmedProposalState))

-- | Update System related workers.
usWorkers :: WorkMode ssc m => [SendActions BiP m -> m ()]


-- | Re-exports of Pos.Communication.*
module Pos.Communication
data BiP
BiP :: BiP

-- | Send Tx to given address.
sendTx :: (MinWorkMode m) => SendActions BiP m -> NetworkAddress -> TxAux -> m ()
sendVote :: (MinWorkMode m) => SendActions BiP m -> NetworkAddress -> UpdateVote -> m ()
sendUpdateProposal :: (MinWorkMode m) => SendActions BiP m -> NetworkAddress -> UpId -> UpdateProposal -> [UpdateVote] -> m ()

-- | All listeners running on one node.
allListeners :: (SscListenersClass ssc, WorkMode ssc m) => [Listener BiP m]

-- | All listeners running on one node.
allStubListeners :: (SscListenersClass ssc, WithLogger m) => Proxy ssc -> [Listener BiP m]

-- | Logger name for server.
serverLoggerName :: LoggerName

-- | Listener for <a>SysStartRequest</a> message.
sysStartReqListener :: MinWorkMode m => Timestamp -> Listener BiP m

-- | Listener for <tt>SysStartResponce</tt> message.
sysStartRespListener :: MinWorkMode m => MVar Timestamp -> Listener BiP m
handleSysStartResp :: MinWorkMode m => MVar Timestamp -> NodeId -> SendActions BiP m -> SysStartResponse -> m ()

-- | Version request message. <a>VersionResp</a> is expected as response.
data VersionReq
VersionReq :: VersionReq

-- | Version response (on <a>VersionReq</a> response).
data VersionResp
VersionResp :: Int32 -> BlockVersion -> VersionResp
[vRespMagic] :: VersionResp -> Int32
[vRespBlockVersion] :: VersionResp -> BlockVersion

-- | PeerState type aggregates socket states needed for different parts of
--   system.
data PeerState ssc
peerVersion :: HasPeerState c_a6dGi ssc_a6dFS => Lens' c_a6dGi (Maybe BlockVersion)

-- | Communication request for system start.
data SysStartRequest
SysStartRequest :: SysStartRequest

-- | Response to <a>SysStartRequest</a>.
data SysStartResponse
SysStartResponse :: !Timestamp -> SysStartResponse
data TxMsgTag
TxMsgTag :: TxMsgTag

-- | Data message. Can be used to send one transaction per message.
data TxMsgContents
TxMsgContents :: !Tx -> !TxWitness -> !TxDistribution -> TxMsgContents
[dmTx] :: TxMsgContents -> !Tx
[dmWitness] :: TxMsgContents -> !TxWitness
[dmDistribution] :: TxMsgContents -> !TxDistribution


-- | High level workers.
module Pos.Worker

-- | Run all necessary workers in separate threads. This call doesn't
--   block.
--   
--   A note about order: currently all onNewSlot updates can be run in
--   parallel and we try to maintain this rule. If at some point order
--   becomes important, update this comment! I don't think you will read
--   it, but who knows…
runWorkers :: (SscWorkersClass ssc, SecurityWorkersClass ssc, WorkMode ssc m) => SendActions BiP m -> m ()

-- | Workers for collecting statistics about transactions in background.
statsWorkers :: WorkMode ssc m => [SendActions BiP m -> m ()]


-- | High-level code capable of running various scenarios in various modes.
module Pos.Launcher

-- | Run full node in real mode.
runNodeProduction :: forall ssc. SscConstraint ssc => RealModeResources -> [SendActions BiP (ProductionMode ssc) -> ProductionMode ssc ()] -> NodeParams -> SscParams ssc -> Production ()

-- | Run full node in benchmarking node
runNodeStats :: forall ssc. SscConstraint ssc => RealModeResources -> [SendActions BiP (StatsMode ssc) -> StatsMode ssc ()] -> NodeParams -> SscParams ssc -> Production ()
stakesDistr :: DistrOption -> DistrOption -> Bool -> StakeDistribution

-- | Contains all parameters required for hierarchical logger
--   initialization.
data LoggingParams
LoggingParams :: !LoggerName -> !(Maybe FilePath) -> !(Maybe FilePath) -> LoggingParams

-- | prefix for logger, like "time-slave"
[lpRunnerTag] :: LoggingParams -> !LoggerName

-- | prefix of path for all logs
[lpHandlerPrefix] :: LoggingParams -> !(Maybe FilePath)

-- | path to logger configuration
[lpConfigPath] :: LoggingParams -> !(Maybe FilePath)

-- | Contains basic &amp; networking parameters for running node.
data BaseParams
BaseParams :: !NetworkAddress -> ![DHTNode] -> !(Maybe DHTKey) -> !Bool -> !LoggingParams -> !FilePath -> BaseParams

-- | port to run on
[bpIpPort] :: BaseParams -> !NetworkAddress

-- | peers passed from CLI
[bpDHTPeers] :: BaseParams -> ![DHTNode]
[bpDHTKey] :: BaseParams -> !(Maybe DHTKey)
[bpDHTExplicitInitial] :: BaseParams -> !Bool

-- | logger parameters
[bpLoggingParams] :: BaseParams -> !LoggingParams

-- | Path to kademlia dump file
[bpKademliaDump] :: BaseParams -> !FilePath

-- | Contains algorithm specific &amp; storage parameters for Node.
data NodeParams
NodeParams :: !FilePath -> !Bool -> !Timestamp -> !SecretKey -> !UserSecret -> !BaseParams -> !Utxo -> !Bool -> !(Maybe FilePath) -> ![AttackType] -> ![AttackTarget] -> !Bool -> NodeParams

-- | Modern path to node's data-base.
[npDbPathM] :: NodeParams -> !FilePath

-- | <tt>True</tt> if data-base should be rebuilt
[npRebuildDb] :: NodeParams -> !Bool

-- | System start
[npSystemStart] :: NodeParams -> !Timestamp

-- | Primary secret key of node
[npSecretKey] :: NodeParams -> !SecretKey

-- | All node secret keys
[npUserSecret] :: NodeParams -> !UserSecret

-- | See <a>BaseParams</a>
[npBaseParams] :: NodeParams -> !BaseParams

-- | predefined custom utxo
[npCustomUtxo] :: NodeParams -> !Utxo

-- | <tt>True</tt> if node started as time-lord
[npTimeLord] :: NodeParams -> !Bool
[npJLFile] :: NodeParams -> !(Maybe FilePath)

-- | List of attack types used by malicious emulation
[npAttackTypes] :: NodeParams -> ![AttackType]

-- | List of targets to attack by malicious emulation
[npAttackTargets] :: NodeParams -> ![AttackTarget]

-- | Whether to propagate txs, ssc data, blocks to neighbors
[npPropagation] :: NodeParams -> !Bool

-- | RawRealMode runner.
runRawRealMode :: forall ssc a. SscConstraint ssc => RealModeResources -> NodeParams -> SscParams ssc -> [Listener BiP (RawRealMode ssc)] -> (SendActions BiP (RawRealMode ssc) -> RawRealMode ssc a) -> Production a

-- | ProductionMode runner.
runProductionMode :: forall ssc a. (SscConstraint ssc) => RealModeResources -> NodeParams -> SscParams ssc -> (SendActions BiP (ProductionMode ssc) -> ProductionMode ssc a) -> Production a

-- | StatsMode runner. [CSL-169]: spawn here additional listener, which
--   would accept stat queries can be done as part of refactoring (or
--   someone who will refactor will create new issue).
runStatsMode :: forall ssc a. (SscConstraint ssc) => RealModeResources -> NodeParams -> SscParams ssc -> (SendActions BiP (StatsMode ssc) -> StatsMode ssc a) -> Production a

-- | ServiceMode runner.
runServiceMode :: RealModeResources -> BaseParams -> [Listener BiP ServiceMode] -> (SendActions BiP ServiceMode -> ServiceMode a) -> Production a

-- | Runs node as time-slave inside IO monad.
runTimeSlaveReal :: SscListenersClass ssc => Proxy ssc -> RealModeResources -> BaseParams -> Production Timestamp

-- | Runs time-lord to acquire system start.
runTimeLordReal :: LoggingParams -> Production Timestamp
addDevListeners :: MinWorkMode m => Timestamp -> [Listener BiP m] -> [Listener BiP m]
setupLoggers :: MonadIO m => LoggingParams -> m ()
bracketDHTInstance :: BaseParams -> (KademliaDHTInstance -> Production a) -> Production a
runServer :: (MonadIO m, MonadMockable m, MonadFix m, WithLogger m) => Transport -> [Listener BiP m] -> (SendActions BiP m -> m b) -> m b

-- | RAII for node starter.
loggerBracket :: LoggingParams -> IO a -> IO a
createTransport :: (MonadIO m, WithLogger m, Mockable Throw m) => String -> Word16 -> m Transport
bracketTransport :: BaseParams -> (Transport -> Production a) -> Production a
bracketResources :: BaseParams -> (RealModeResources -> Production a) -> IO a
data RealModeResources
RealModeResources :: Transport -> KademliaDHTInstance -> RealModeResources
[rmTransport] :: RealModeResources -> Transport
[rmDHT] :: RealModeResources -> KademliaDHTInstance

-- | Run full node in any WorkMode.
runNode :: (SscConstraint ssc, WorkMode ssc m) => [SendActions BiP m -> m ()] -> SendActions BiP m -> m ()
initSemaphore :: (WorkMode ssc m) => m ()
initLrc :: WorkMode ssc m => m ()

module Pos.Wallet
data WalletParams
WalletParams :: !(Maybe FilePath) -> !Bool -> !FilePath -> !Timestamp -> !Bool -> !BaseParams -> WalletParams
[wpDbPath] :: WalletParams -> !(Maybe FilePath)
[wpRebuildDb] :: WalletParams -> !Bool
[wpKeyFilePath] :: WalletParams -> !FilePath
[wpSystemStart] :: WalletParams -> !Timestamp
[wpGenesisKeys] :: WalletParams -> !Bool
[wpBaseParams] :: WalletParams -> !BaseParams
runRawRealWallet :: RealModeResources -> WalletParams -> [Listener BiP WalletRealMode] -> (SendActions BiP WalletRealMode -> WalletRealMode a) -> Production a

-- | WalletMode runner
runWalletRealMode :: RealModeResources -> WalletParams -> (SendActions BiP WalletRealMode -> WalletRealMode a) -> Production a
runWalletReal :: RealModeResources -> WalletParams -> [SendActions BiP WalletRealMode -> WalletRealMode ()] -> Production ()
runWallet :: WalletMode ssc m => [SendActions BiP m -> m ()] -> SendActions BiP m -> m ()

-- | Makes a transaction which use P2PKH addresses as a source
makePubKeyTx :: SecretKey -> TxInputs -> TxOutputs -> TxAux
makeMOfNTx :: Script -> [Maybe SecretKey] -> TxInputs -> TxOutputs -> TxAux

-- | Construct Tx using secret key and given list of desired outputs
submitTx :: TxMode ssc m => SendActions BiP m -> SecretKey -> [NetworkAddress] -> [TxOutAux] -> m (Either TxError TxAux)

-- | Send the ready-to-use transaction
submitTxRaw :: MinWorkMode m => SendActions BiP m -> [NetworkAddress] -> TxAux -> m ()

-- | Make a multi-transaction using given secret key and info for outputs
createTx :: Utxo -> SecretKey -> TxOutputs -> Either TxError TxAux

-- | Make a transaction, using M-of-N script as a source
createMOfNTx :: Utxo -> [(PublicKey, Maybe SecretKey)] -> TxOutputs -> Either TxError TxAux

-- | Send UpdateVote to given addresses
submitVote :: MinWorkMode m => SendActions BiP m -> [NetworkAddress] -> UpdateVote -> m ()

-- | Send UpdateProposal with one positive vote to given addresses
submitUpdateProposal :: MinWorkMode m => SendActions BiP m -> SecretKey -> [NetworkAddress] -> UpdateProposal -> m ()

-- | A class which have the methods to get state of address' balance
class Monad m => MonadBalances m where getBalance addr = unsafeIntegerToCoin . sumCoins . map (txOutValue . fst) . toList <$> getOwnUtxo addr getOwnUtxo = lift . getOwnUtxo
getOwnUtxo :: MonadBalances m => Address -> m Utxo
getBalance :: MonadBalances m => Address -> m Coin
getOwnUtxo :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Address -> m Utxo

-- | A class which have methods to get transaction history
class Monad m => MonadTxHistory m where getTxHistory = lift . getTxHistory saveTx = lift . saveTx
getTxHistory :: MonadTxHistory m => Address -> m [TxHistoryEntry]
saveTx :: MonadTxHistory m => (TxId, TxAux) -> m ()
getTxHistory :: (MonadTxHistory m, MonadTrans t, MonadTxHistory m', t m' ~ m) => Address -> m [TxHistoryEntry]
saveTx :: (MonadTxHistory m, MonadTrans t, MonadTxHistory m', t m' ~ m) => (TxId, TxAux) -> m ()
class Monad m => MonadBlockchainInfo m where networkChainDifficulty = lift networkChainDifficulty localChainDifficulty = lift localChainDifficulty
networkChainDifficulty :: MonadBlockchainInfo m => m ChainDifficulty
localChainDifficulty :: MonadBlockchainInfo m => m ChainDifficulty
networkChainDifficulty :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m ChainDifficulty
localChainDifficulty :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m ChainDifficulty

-- | Abstraction over getting update proposals
class Monad m => MonadUpdates m where waitForUpdate = lift waitForUpdate
waitForUpdate :: MonadUpdates m => m ConfirmedProposalState
waitForUpdate :: (MonadUpdates m, MonadTrans t, MonadUpdates m', t m' ~ m) => m ConfirmedProposalState
type TxMode ssc m = (MinWorkMode m, MonadBalances m, MonadTxHistory m, MonadMockable m, MonadFail m, MonadMask m)
type WalletMode ssc m = (TxMode ssc m, MonadKeys m, MonadBlockchainInfo m, MonadUpdates m, WithWalletContext m, MonadDHT m, MonadSlots m)
type WalletRealMode = KademliaDHT (KeyStorage (WalletDB (ContextHolder (LoggerNameBox Production))))


-- | Web part of wallet.
module Pos.Wallet.Web

-- | Servant API which provides access to wallet.
type WalletApi = ("api" :> ("get_wallet" :> (Capture "address" CAddress :> Get '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("get_wallets" :> Get '[JSON] (Either WalletError [CWallet]))) :<|> (("api" :> ("send" :> (Capture "from" CAddress :> (Capture "to" CAddress :> (Capture "amount" Coin :> Post '[JSON] (Either WalletError CTx)))))) :<|> (("api" :> ("send" :> (Capture "from" CAddress :> (Capture "to" CAddress :> (Capture "amount" Coin :> (Capture "currency" CCurrency :> (Capture "title" Text :> (Capture "description" Text :> Post '[JSON] (Either WalletError CTx))))))))) :<|> (("api" :> ("txhistory" :> (Capture "address" CAddress :> (Capture "skip" Word :> (Capture "limit" Word :> Get '[JSON] (Either WalletError ([CTx], Word))))))) :<|> (("api" :> ("search_txhistory" :> (Capture "address" CAddress :> (Capture "search" Text :> (Capture "skip" Word :> (Capture "limit" Word :> Get '[JSON] (Either WalletError ([CTx], Word)))))))) :<|> (("api" :> ("update_transaction" :> (Capture "address" CAddress :> (Capture "transaction" CTxId :> (ReqBody '[JSON] CTxMeta :> Post '[JSON] (Either WalletError ())))))) :<|> (("api" :> ("new_wallet" :> (ReqBody '[JSON] CWalletInit :> Post '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("restore_wallet" :> (ReqBody '[JSON] BackupPhrase :> Post '[JSON] (Either WalletError CWallet)))) :<|> (("api" :> ("update_wallet" :> (Capture "address" CAddress :> (ReqBody '[JSON] CWalletMeta :> Post '[JSON] (Either WalletError CWallet))))) :<|> (("api" :> ("delete_wallet" :> (Capture "address" CAddress :> Post '[JSON] (Either WalletError ())))) :<|> (("api" :> ("valid_address" :> (Capture "currency" CCurrency :> (Capture "address" Text :> Get '[JSON] (Either WalletError Bool))))) :<|> (("api" :> ("get_profile" :> Get '[JSON] (Either WalletError CProfile))) :<|> (("api" :> ("update_profile" :> (ReqBody '[JSON] CProfile :> Post '[JSON] (Either WalletError CProfile)))) :<|> (("api" :> ("redeem_ada" :> (Capture "seed" Text :> (ReqBody '[JSON] BackupPhrase :> Post '[JSON] (Either WalletError CWallet))))) :<|> (("api" :> ("next_update" :> Get '[JSON] (Either WalletError CUpdateInfo))) :<|> (("api" :> ("apply_update" :> Post '[JSON] (Either WalletError ()))) :<|> (("api" :> ("slot_duration" :> Get '[JSON] (Either WalletError Word))) :<|> ("api" :> ("system_version" :> Get '[JSON] (Either WalletError SoftwareVersion))))))))))))))))))))

-- | Helper Proxy.
walletApi :: Proxy WalletApi

-- | Client address
data CAddress

-- | currencies handled by client Note: Cardano does not deal with other
--   currency than ADA yet
data CCurrency
ADA :: CCurrency
BTC :: CCurrency
ETH :: CCurrency

-- | Client hash
data CHash

-- | type of transactions It can be an input <i> output </i> exchange
--   transaction CTInOut CTExMeta -- Ex == exchange
data CTType
CTIn :: CTxMeta -> CTType
CTOut :: CTxMeta -> CTType

-- | Client profile (CP) all data of client are "meta data" - that is not
--   provided by Cardano (Flow type: accountType)
data CProfile
CProfile :: Text -> Text -> Text -> CPwHash -> POSIXTime -> Text -> Text -> CProfile
[cpName] :: CProfile -> Text
[cpEmail] :: CProfile -> Text
[cpPhoneNumber] :: CProfile -> Text
[cpPwHash] :: CProfile -> CPwHash
[cpPwCreated] :: CProfile -> POSIXTime
[cpLocale] :: CProfile -> Text
[cpPicture] :: CProfile -> Text

-- | Password hash of client profile
type CPwHash = Text

-- | Client transaction (CTx) Provides all Data about a transaction needed
--   by client. It includes meta data which are not part of Cardano, too
--   (Flow type: transactionType)
data CTx
CTx :: CTxId -> Coin -> Word -> CTType -> CTx
[ctId] :: CTx -> CTxId
[ctAmount] :: CTx -> Coin
[ctConfirmations] :: CTx -> Word
[ctType] :: CTx -> CTType

-- | Client transaction id
data CTxId

-- | meta data of transactions
data CTxMeta
CTxMeta :: CCurrency -> Text -> Text -> POSIXTime -> CTxMeta
[ctmCurrency] :: CTxMeta -> CCurrency
[ctmTitle] :: CTxMeta -> Text
[ctmDescription] :: CTxMeta -> Text
[ctmDate] :: CTxMeta -> POSIXTime

-- | meta data of exchanges
data CTExMeta
CTExMeta :: CCurrency -> Text -> Text -> Text -> Text -> Text -> CAddress -> CTExMeta
[cexCurrency] :: CTExMeta -> CCurrency
[cexTitle] :: CTExMeta -> Text
[cexDescription] :: CTExMeta -> Text
[cexDate] :: CTExMeta -> Text
[cexRate] :: CTExMeta -> Text
[cexLabel] :: CTExMeta -> Text
[cexAddress] :: CTExMeta -> CAddress

-- | Client Wallet (CW) (Flow type: walletType)
data CWallet
CWallet :: !CAddress -> !Coin -> !CWalletMeta -> CWallet
[cwAddress] :: CWallet -> !CAddress
[cwAmount] :: CWallet -> !Coin
[cwMeta] :: CWallet -> !CWalletMeta

-- | A wallet can be used as personal or shared wallet
data CWalletType
CWTPersonal :: CWalletType
CWTShared :: CWalletType

-- | Meta data of CWallet Includes data which are not provided by Cardano
data CWalletMeta
CWalletMeta :: !CWalletType -> !CCurrency -> !Text -> CWalletMeta
[cwType] :: CWalletMeta -> !CWalletType
[cwCurrency] :: CWalletMeta -> !CCurrency
[cwName] :: CWalletMeta -> !Text

-- | Query data for wallet creation (wallet meta + backup phrase)
data CWalletInit
CWalletInit :: !BackupPhrase -> !CWalletMeta -> CWalletInit
[cwBackupPhrase] :: CWalletInit -> !BackupPhrase
[cwInitMeta] :: CWalletInit -> !CWalletMeta

-- | Update system data
data CUpdateInfo
CUpdateInfo :: !SoftwareVersion -> !BlockVersion -> !ScriptVersion -> !Bool -> !Int -> !Int -> !Coin -> !Coin -> CUpdateInfo
[cuiSoftwareVersion] :: CUpdateInfo -> !SoftwareVersion
[cuiBlockVesion] :: CUpdateInfo -> !BlockVersion
[cuiScriptVersion] :: CUpdateInfo -> !ScriptVersion
[cuiImplicit] :: CUpdateInfo -> !Bool
[cuiVotesFor] :: CUpdateInfo -> !Int
[cuiVotesAgainst] :: CUpdateInfo -> !Int
[cuiPositiveStake] :: CUpdateInfo -> !Coin
[cuiNegativeStake] :: CUpdateInfo -> !Coin
data NotifyEvent
ConnectionOpened :: NotifyEvent

-- | NewWalletTransaction CAddress | NewTransaction
NetworkDifficultyChanged :: ChainDifficulty -> NotifyEvent
LocalDifficultyChanged :: ChainDifficulty -> NotifyEvent
UpdateAvailable :: NotifyEvent
ConnectionClosed :: NotifyEvent

-- | transform Address into CAddress TODO: this is not complitely safe. If
--   someone changes implementation of Buildable Address. It should be
--   probably more safe to introduce `class PSSimplified` that would have
--   the same implementation has it is with Buildable Address but then
--   person will know it will probably change something for purescript.
addressToCAddress :: Address -> CAddress
cAddressToAddress :: CAddress -> Either Text Address
mkCTx :: Address -> ChainDifficulty -> TxHistoryEntry -> CTxMeta -> CTx
mkCTxId :: Text -> CTxId

-- | transform TxId into CTxId
txIdToCTxId :: TxId -> CTxId
ctTypeMeta :: CTType -> CTxMeta
txContainsTitle :: Text -> CTx -> Bool

-- | Creates <tt>CTUpdateInfo</tt> from <a>ConfirmedProposalState</a>
toCUpdateInfo :: ConfirmedProposalState -> CUpdateInfo
walletDocsText :: Text
data WalletError

-- | Some internal error.
Internal :: !Text -> WalletError
walletServeWebFull :: SscConstraint ssc => SendActions BiP (RawRealMode ssc) -> Bool -> FilePath -> Bool -> Word16 -> RawRealMode ssc ()
walletServeWebLite :: SendActions BiP WalletRealMode -> FilePath -> Bool -> Word16 -> WalletRealMode ()
walletApplication :: WalletWebMode ssc m => m (Server WalletApi) -> m Application
walletServer :: (Monad m, WalletWebMode ssc (WalletWebHandler m)) => SendActions BiP m -> WalletWebHandler m (WalletWebHandler m :~> Handler) -> WalletWebHandler m (Server WalletApi)
walletServeImpl :: (MonadIO m, MonadMask m, WalletWebMode ssc (WalletWebHandler m)) => WalletWebHandler m Application -> FilePath -> Bool -> Word16 -> m ()

-- | Holder for web wallet data
data WalletWebSockets m a
type WebWalletSockets m = (MonadWalletWebSockets m, MonadIO m)

-- | MonadWalletWebSockets stands for monad which is able to get web wallet
--   sockets
class Monad m => MonadWalletWebSockets m
getWalletWebSockets :: MonadWalletWebSockets m => m ConnectionsVar
type ConnectionsVar = TVar (Maybe Connection)
initWSConnection :: MonadIO m => m ConnectionsVar
closeWSConnection :: MonadIO m => ConnectionsVar -> m ()
upgradeApplicationWS :: ConnectionsVar -> Application -> Application
notify :: WebWalletSockets m => NotifyEvent -> m ()
runWalletWS :: ConnectionsVar -> WalletWebSockets m a -> m a
getWalletWebSocketsState :: Monad m => WalletWebSockets m ConnectionsVar

-- | Holder for web wallet data
newtype WalletWebDB m a
WalletWebDB :: ReaderT WalletState m a -> WalletWebDB m a
[getWalletWebDB] :: WalletWebDB m a -> ReaderT WalletState m a

-- | Execute <a>WalletWebDB</a> action with given <a>WalletState</a>
runWalletWebDB :: WalletState -> WalletWebDB m a -> m a
getWalletState :: Monad m => WalletWebDB m WalletState
type WalletState = ExtendedState WalletStorage

-- | MonadWalletWebDB stands for monad which is able to get web wallet
--   state
class Monad m => MonadWalletWebDB m
getWalletWebState :: MonadWalletWebDB m => m WalletState

-- | Constraint for working with web wallet DB
type WebWalletModeDB m = (MonadWalletWebDB m, MonadIO m, MonadMockable m)
openState :: MonadIO m => Bool -> FilePath -> m WalletState
openMemState :: MonadIO m => m WalletState
closeState :: MonadIO m => WalletState -> m ()
getProfile :: WebWalletModeDB m => m (Maybe CProfile)
getWalletMetas :: WebWalletModeDB m => m [CWalletMeta]
getWalletMeta :: WebWalletModeDB m => CAddress -> m (Maybe CWalletMeta)
getTxMeta :: WebWalletModeDB m => CAddress -> CTxId -> m (Maybe CTxMeta)
getWalletHistory :: WebWalletModeDB m => CAddress -> m (Maybe [CTxMeta])
getUpdates :: WebWalletModeDB m => m [CUpdateInfo]
getNextUpdate :: WebWalletModeDB m => m (Maybe CUpdateInfo)
createWallet :: WebWalletModeDB m => CAddress -> CWalletMeta -> m ()
setProfile :: WebWalletModeDB m => CProfile -> m ()
setWalletMeta :: WebWalletModeDB m => CAddress -> CWalletMeta -> m ()
setWalletTransactionMeta :: WebWalletModeDB m => CAddress -> CTxId -> CTxMeta -> m ()
setWalletHistory :: WebWalletModeDB m => CAddress -> [(CTxId, CTxMeta)] -> m ()
addOnlyNewTxMeta :: WebWalletModeDB m => CAddress -> CTxId -> CTxMeta -> m ()
removeWallet :: WebWalletModeDB m => CAddress -> m ()
addUpdate :: WebWalletModeDB m => CUpdateInfo -> m ()
removeNextUpdate :: WebWalletModeDB m => m ()
