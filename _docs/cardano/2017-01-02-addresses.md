---
layout: default
title: Addresses in Cardano SL
permalink: /cardano/addresses/
group: cardano
---
[//]: # (Reviewed at 403cea2d897aba95163b709bd13c35d343116f3f)

# Addresses in Cardano SL

To send and receive value, addresses are used in virtually any cryptocurrency.
Cardano [supports](https://github.com/input-output-hk/cardano-sl/blob/f37c6cf6a43f42cd7c0a0477e33ae95155d50450/src/Pos/Types/Core.hs#L231)
two types of addresses: `PubKeyAddress` and `ScriptAddress`.

The former is a normal address like in any other cryptocurrency. It is nothing but a
[hashed](https://github.com/input-output-hk/cardano-sl/blob/ce90b5d86ff35a6b416cf5261833a46f91f50497/src/Pos/Types/Core.hs#L242)
[public key](https://github.com/input-output-hk/cardano-sl/blob/f37c6cf6a43f42cd7c0a0477e33ae95155d50450/src/Pos/Types/Core.hs#L231). See more about
[public key addresses](#public-key-addresses).

The latter is used in so-called "Pay to Script Hash" (P2SH) transactions. It operates
autonomously and acts somewhat like a bank deposit: you can send money to it, but
in order to redeem it you have to satisfy certain conditions, determined by a
[script](https://github.com/input-output-hk/cardano-sl/blob/f37c6cf6a43f42cd7c0a0477e33ae95155d50450/src/Pos/Script/Type.hs#L38)
associated with the address. The address itself is the hash of the serialized script.
See more about [P2SH](#pay-to-script-hash).

## What Does an Address Look Like?

In Cardano, we adopt Bitcoin way of encoding the address. It's called
“Base 58” because it uses 58-symbol alphabet to encode data. Here is the
alphabet we are using:

    123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

It avoids both non-alphanumeric characters and letters which might look
ambiguous when printed; therefore it is suitable for human users who enter
the data manually, copying it from some visual source, and also
allows easy copy and paste because a double-click will usually select
the whole string.

We also adopt a way to make sure that an address is
entered correctly by appending a 32-bit Cyclic Redundancy Code checksum
(CRC32) to the end of the part of the address which encodes public key
or script hash. This way, the full address is generated by the following
rule, where `<>` is a concatenation operator:
`toBase58(addr<>crc32(addr))`.

The addresses are 224 bits (28 bytes) long.

Here is an example of a valid address:

    1EWYSJnvgnSUmp8Gi4mADvU2zkJgVAA7McgFRXiqwDBs8

which can be decoded into the following byte string (space separates
address from checksum):

    C8B9519459F5D4E42B002EF06AE94DC9C0A5B87E52D0D0375FD83ECE C52CEB43

## Public Key Addresses

As said in the [Introduction](/#you-own-your-money), the
wallets you see in the user interface are a convenient representation of
the fact that you own a secret key to spend money in this particular
wallet. But how is such spending verified by the network and how can you
receive money from others? The answer is that along with the secret key
which is used to control the value in your wallets, a public key is
generated. This public component can be known by anybody, hence the name.
Public key mostly serves two purposes:

 1. When you create a transaction, anyone with the corresponding public
    key can verify that you indeed control the secret key.
 2. When someone wants to send you the money, they use your public key
    encoded in Base58 as the address.

The public key is also used to verify some protocol messages that have to be
signed with the secret key.

As we have discussed before, your address is exactly the hash of your public
key plus its CRC32, all encoded in Base58.

## Pay to Script Hash

The idea of P2SH is to provide a lot of flexibility to formulating complex
rules for spending money. Instead of sending a transaction to a public key
address, we create a validator script where redemption script can
be plugged in. To redeem funds, we evaluate validator script with
redemption script as an argument. If validator script evaluates to
`success`, money is getting sent as specified by the redeemer.
Otherwise nothing happens.

To quote Bitcoin Wiki,

> Using P2SH, you can send bitcoins to an address that is secured in
> various unusual ways without knowing anything about the details of how
> the security is set up. The recipient might need the signatures of
> several people to spend these bitcoins, or a password might be
> required, or the requirements could be completely unique.

## Advanced Topics

### Hashing

For a number of reasons, it is useful to have fixed-length
representation of arbitrary data; for example, when we're working with
P2SH, we want validator scripts of arbitrary length to be hashed in a
P2SH address of the same length that is easy to type in and operate
with. Also, in order to have an authenticated data structure capturing
information stored on the blockchain, we should have the same kind of
primitive. The requirements on such a function are manyfold:

 1. On the same input data it always returns the same output string.
 2. It is computationally simple to calculate output for a given input.
 3. It is computationally complex to reverse the process.
 4. A small change in input produces big change in output.
 5. It is computationally complex to find two pieces of input data that
    produce the same output.

The way we transform arbitrary input into output complying with (1-5)
is called “a cryptographic hash function”.

We are currently using two hash functions: `SHA3` with 256 digest and
`BLAKE2S` with 224 bit digest.

For example, for addresses, we wrap SHA3 digest into BLAKE2s, as shown
in the code snippet below.

~~~ haskell
type AddressHash = AbstractHash Blake2s_224

addressHash :: Bi a => a -> AddressHash b
adressHash = AbstractHash . secondHash . firstHash
  where
    firstHash :: Bi a => a -> Digest SHA3_256
    firstHash = hashlazy . Bi.encode
    secondHash :: Digest SHA3_256 -> Digest Blake2s_224
    secondHash = CryptoHash.hash
~~~
