---
layout: default
title: Daedalus Bridge
permalink: /cardano/wallets/
group: cardano
---
[//]: # (Reviewed at e74b95fd7e04b43c03198dbed0f8599d53df5235)

# What is Daedalus

In developing Cardano SL, the need arose for a UI from which users could access
their funds, send and receive transactions, and perform other tasks related to
managing a personal cryptocurrency wallet. The Daedalus wallet is the Cardano's
solution to these necessities.

Currently, it allows a user to use their ADA in the aforementioned actions, and
support for other currencies is planned for the near future, as is the exchange
between different currencies, both digital and not.

## Building `daedalus-bridge`

To run `daedalus-bridge` locally you have to start the `wallet-api` of [`cardano-sl`](https://github.com/input-output-hk/cardano-sl/) as follows. Make sure that your are on the root folder of `cardano-sl`.

```bash
# build app
stack build
# remove old PureScript types if they exist
rm -rf daedalus/src/Generated
# generate PureScript types
stack exec -- cardano-wallet-hs2purs
```

This should create PureScript modules with datatypes bridged from Haskell. You should have similar structure like:

```bash
$ tree daedalus/src/Generated/
daedalus/src/Generated/
└── Pos
    ├── Types
    │   └── Core.purs
    ├── Util
    │   └── BackupPhrase.purs
    └── Wallet
        └── Web
            ├── ClientTypes.purs
            └── Error.purs
```

## Running and testing `daedalus-bridge`

In order to see `daedalus-bridge` in action first run local cardano network:

```bash
# run tmux in another window
tmux
# launch nodes
export WALLET_TEST=1; ./scripts/launch.sh
```

By default this should launch cardano network consisting of 3 nodeds talking to each other. `WALLET_TEST=1` tells the launcher script to run `wallet-api` with one node. This one node running `wallet-api` will behave the same as Daedalus wallet that is run in production. If you run into some issues remove the following content first and build `wallet-api` again as described above.

```
rm -rf ./run/*
rm -rf wallet-db
rm node-*.*.key
```

With a running `wallet-api` you can run `daedalus-bridge` locally as follows.
Please note that [yarn](https://yarnpkg.com/) is required to build `daedalus-bridge`.

```bash
cd daedalus
yarn install
yarn build:prod
```

Now we can try using the bridge with [nodejs](https://nodejs.org/):

```bash
$ node
> var api = require('../output/Daedalus.ClientApi')
undefined
> api
{ applyUpdate: [Function],
  blockchainSlotDuration: [Function],
  deleteWallet: [Function],
  generateMnemonic: [Function: generateMnemonic],
  getHistory: [Function],
  getProfile: [Function],
  getWallet: [Function],
  getWallets: [Function],
  isValidAddress: [Function],
  newWallet: [Function],
  nextUpdate: [Function],
  notify: [Function],
  postponeUpdatesUntil: [Function],
  redeemADA: [Function],
  restoreWallet: [Function],
  restoreWalletIgnoreChecksum: [Function],
  searchHistory: [Function],
  send: [Function],
  sendExtended: [Function],
  systemVersion: [Function],
  updateProfile: [Function],
  updateTransaction: [Function],
  updateWallet: [Function] }
```

This will load and show all functions that can be run from from this library to interact with the wallet. For example, to fetch all available wallets we can do:

```bash
> api.getWallets().then(console.log).catch(console.log)
Promise { <pending> }
> [ { cwMeta:
     { cwType: 'CWTPersonal',
       cwName: 'Personal Wallet',
       cwCurrency: 'ADA' },
    cwAmount: { getCoin: 33333 },
    cwAddress: '1gLFDJAKutVJCYioMANx4gthHru5K12Tk9YpEmXKQfggKZu' } ]
```

Note: `daedalus-bridge`, also sometimes refered as `daedalus-client-api`, is not optimized / compressed. This is will be a job for Daedalus.

## How it's structured

In the [PureScript Type Bridge](/cardano/pstypebridge) section, it was
discussed how the backend types are translated into PureScript via type
bridges. In this section, the way they're used in the frontend will be
described.

TODO: explain ClientApi -> BackendApi -> HaskellBackend workflow

First, an explanation on the type of `Daedalus.ClientApi.send`, which is
`forall eff. EffFn3 (ajax :: AJAX | eff) String String Int (Promise Json)`.

While these documents do not aim to be an introduction to PureScript,
(one can be found [here](http://www.purescript.org/learn/getting-started/)),
the effect monad's functioning is slightly different than in Haskell. In
Haskell, when interaction with the system in an "impure", stateful way is
required, the `IO` monad is often used.

However, it's usually too coarse since `IO` can do anything from
reading/writing to files and sending data over a wired connection to getting
the user's input from the console or closing a program's window. In PureScript,
the `Eff` monad is used instead, and then the required effects are added as
type constraints, like so:

```purescript
forall e. Eff (console :: CONSOLE, random :: RANDOM | e) Unit`
```

This, means that the code which has this type performs an effectful action,
which requires an environment that supports console IO and random number
generation, along with any other effect (`forall e`).

Going back to the previous `Daedalus.Client.Api.send` example,

```purescript
forall eff. EffFn3 (ajax :: AJAX | eff) String String Int (Promise Json)
```

means that the `send` function works in an environment where at least `AJAX`
requests are supported, aside from other, maybe none, effects - hence the
`forall eff`. `AJAX` requests are asynchronous HTTP requests in JavaScript,
which is where the `Promise` datatype comes from. Without going into excessive
detail, this datatype encapsulates the concept that an asynchronous result will
eventually have a result.
