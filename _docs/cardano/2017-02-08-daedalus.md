---
layout: default
title: Daedalus Bridge
permalink: /cardano/wallets/
group: cardano
---
[//]: # (Reviewed at e74b95fd7e04b43c03198dbed0f8599d53df5235)

# What is Daedalus

In developing Cardano SL, the need arose for a UI from which users could access
their funds, send and receive transactions, and perform other tasks related to
managing a personal cryptocurrency wallet. The Daedalus wallet is the Cardano's
solution to these necessities.

Currently, it allows a user to use their ADA in the aforementioned actions, and
support for other currencies is planned for the near future, as is the exchange
between different currencies, both digital and not.

## Building `daedalus-bridge`

To run `daedalus-bridge` locally you have to start the `wallet-api` of [`cardano-sl`](https://github.com/input-output-hk/cardano-sl/) as follows. Make sure that your are on the root folder of `cardano-sl`.

```bash
# build app
stack build
# remove old PureScript types if they exist
rm -rf daedalus/src/Generated
# generate PureScript types
stack exec -- cardano-wallet-hs2purs
```

This should create PureScript modules with datatypes bridged from Haskell. You should have similar structure like:

```bash
$ tree daedalus/src/Generated/
daedalus/src/Generated/
└── Pos
    ├── Types
    │   └── Core.purs
    ├── Util
    │   └── BackupPhrase.purs
    └── Wallet
        └── Web
            ├── ClientTypes.purs
            └── Error.purs
```

## Running and testing `daedalus-bridge`

In order to see `daedalus-bridge` in action first run local cardano network:

```bash
# run tmux in another window
tmux
# launch nodes
export WALLET_TEST=1; ./scripts/launch.sh
```

By default this should launch cardano network consisting of 3 nodeds talking to each other. `WALLET_TEST=1` tells the launcher script to run `wallet-api` with one node. This one node running `wallet-api` will behave the same as Daedalus wallet that is run in production. If you run into some issues remove the following content first and build `wallet-api` again as described above.

```
rm -rf ./run/*
rm -rf wallet-db
rm node-*.*.key
```

With a running `wallet-api` you can run `daedalus-bridge` locally as follows.
Please note that [yarn](https://yarnpkg.com/) and [Bower](https://bower.io/) are required to build `daedalus-bridge.

```bash
cd daedalus
yarn install
yarn start
open http://localhost:3080/
```

To try the examples in the [`index.html`](https://github.com/input-output-hk/cardano-sl/blob/master/daedalus/src/index.html) file, just open the console in your
browser, copy and then paste the example code there.


## Building `daedalus-bridge` for production

```bash
yarn build:prod
```

`daedalus-bridge` is build to `dist/Daedalus.js`.

Note: `daedalus-bridge` is not optimized / compressed. This is will be a job for Daedalus.

## How it's structured

In the [PureScript Type Bridge](/cardano/pstypebridge) section, it was
discussed how the backend types are translated into PureScript via type
bridges. In this section, the way they're used in the frontend will be
described.

For each of the backend's endpoints in the [Wallets](/cardano/wallets/#Wallet API)
section, like for example the `get-wallet` request, there will be a
corresponding caller written in PureScript in the [`Daedalus.BackendApi`](https://github.com/input-output-hk/cardano-sl/blob/ecb17402b433a838426f554ee0ad5e52b5848754/daedalus/src/Daedalus/BackendApi.purs#L88)
module. An exhaustive enumeration will not be done here as the API requests are
all explain in that page.

This is essentially the separation between frontend and backend, with
the [`Pos.Wallet.Web.Api`](https://github.com/input-output-hk/cardano-sl/commit/9193e6e6dde59c1c292374c52a5cb4ceb6231eca) module being the part of the Haskell backend, and the `Daedalus.BackendApi`
module being the foundation of the PureScript/JavaScript frontend. It is from
here that the Haskell backend is called when the user performs some action in
the UI.

However, there are two other modules that rely on `BackendApi` and
are built on top of it, hierarchically, which are [`index.html`](https://github.com/input-output-hk/cardano-sl/blob/ecb17402b433a838426f554ee0ad5e52b5848754/daedalus/src/index.html) and [`Daedalus.ClientApi`](https://github.com/input-output-hk/cardano-sl/blob/ecb17402b433a838426f554ee0ad5e52b5848754/daedalus/src/Daedalus/ClientApi.purs).

The JavaScript API whose requests are used for each user action, such as, for
example, a click on the button to [send a transaction](https://github.com/input-output-hk/cardano-sl/blob/ecb17402b433a838426f554ee0ad5e52b5848754/daedalus/src/index.html#L16), is written in `index.html`.

These methods perform a callback to their corresponding PureScript functions in
`ClientApi`, which in the previous example is [here](https://github.com/input-output-hk/cardano-sl/blob/ecb17402b433a838426f554ee0ad5e52b5848754/daedalus/src/Daedalus/ClientApi.purs#L47).

The function in `ClientApi`, in turn, will then call its corresponding request
in `BackendApi`. In the previous example, it would call [this request](https://github.com/input-output-hk/cardano-sl/blob/ecb17402b433a838426f554ee0ad5e52b5848754/daedalus/src/Daedalus/BackendApi.purs#L96), which
would finally invoke the backend's Haskell API.

This requires an additional note on the necessity of the module `ClientApi`,
and the type annotations of the functions therein.

First, an explanation on the type of `Daedalus.ClientApi.send`, which is
`forall eff. EffFn3 (ajax :: AJAX | eff) String String Int (Promise Json)`.

While these documents do not aim to be an introduction to PureScript,
(one can be found [here](http://www.purescript.org/learn/getting-started/)),
the effect monad's functioning is slightly different than in Haskell. In
Haskell, when interaction with the system in an "impure", stateful way is
required, the `IO` monad is often used.

However, it's usually too coarse since `IO` can do anything from
reading/writing to files and sending data over a wired connection to getting
the user's input from the console or closing a program's window. In PureScript,
the `Eff` monad is used instead, and then the required effects are added as
type constraints, like so:

~~~ purescript
forall e. Eff (console :: CONSOLE, random :: RANDOM | e) Unit`
~~~

This, means that the code which has this type performs an effectful action,
which requires an environment that supports console IO and random number
generation, along with any other effect (`forall e`).

Going back to the previous `Daedalus.Client.Api.send` example,

~~~ purescript
`forall eff. EffFn3 (ajax :: AJAX | eff) String String Int (Promise Json)`
~~~

means that the `send` function works in an environment where at least `AJAX`
requests are supported, aside from other, maybe none, effects - hence the
`forall eff`. `AJAX` requests are asynchronous HTTP requests in JavaScript,
which is where the `Promise` datatype comes from. Without going into excessive
detail, this datatype encapsulates the concept that an asynchronous result will
eventually have a result.
